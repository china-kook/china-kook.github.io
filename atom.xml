<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ikook Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ikookblog.com/"/>
  <updated>2017-08-11T10:38:19.311Z</updated>
  <id>http://ikookblog.com/</id>
  
  <author>
    <name>ikook</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java 实现排序算法之「选择排序」</title>
    <link href="http://ikookblog.com/2017/08/11/java_sort_algorithm_series2/"/>
    <id>http://ikookblog.com/2017/08/11/java_sort_algorithm_series2/</id>
    <published>2017-08-10T16:00:00.000Z</published>
    <updated>2017-08-11T10:38:19.311Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>java 实现排序算法系列</p>
</blockquote>
<a id="more"></a>
<p>继冒泡排序算法之后，选择排序终于和大家见面了。为什么冒泡排序之后要说选择排序呢，是因为它俩是最相似的两种排序算法，血缘关系最为接近。</p>
<p>还是那句话，本人能力拙劣，有不当之处还请不吝赐教，可关注我公号后台留言，见底部二维码。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序（Selection sort）是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度。可以把它看做是冒泡排序算法的一种改进算法。</p>
<h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>假设要给有 n 个元素的数组 arr[] 排序。注意，在数组中第一个元素的下标为 0</p>
<h5 id="n-1"><a href="#n-1" class="headerlink" title="n = 1:"></a>n = 1:</h5><p>无需排序</p>
<h5 id="n-gt-1"><a href="#n-gt-1" class="headerlink" title="n &gt; 1:"></a>n &gt; 1:</h5><ul>
<li>将第一个元素和第二个元素进行比较，如果 arr[0] 大于 arr[1]，那么 arr[0] 一定不是最小元素。里我们暂时不交换元素，而是设置临时变量，将目前较小元素 arr[1] 设置为临时变量 a，用来存储 arr[1] 的下标。然后将目前较小元素 a 继续和第三个元素比较，如果 a 大于 arr[2]，则修改 a 的值为 arr[2] 的下标，即 2；如果不大于 arr[2]，则将 a 和第四个元素比较，如前者大，则修改 a 的值，前者小，则继续往下比较。这样直到与最后一个元素比较，则 a 的值肯定是最小值的下标。<br></li>
<li>如果 a 的值不为 0（即元素 arr[0] 的下标)，则交换下标为 0 和 a 的元素，即将 arr[a] 和 arr[0] 进行交换。<br></li>
<li>到此，第一趟排序完成，将最小值找出来，然后进行第二趟排序。重复上述过程，从第二个元素（即 arr[1]）开始比较。第一个元素已经是最小元素了，不参与比较。<br></li>
<li>重复步骤直到剩下最后一个元素，即 arr[n-1]，可以肯定这个值为最大值。<br></li>
<li>排序完成，不够直观？见下面示例动画。</li>
</ul>
<center><br><img src="http://meto.chinakook.com/blog-images/java_sort_algorithm_series2.gif" alt=""></center>

<blockquote>
<p>注: 红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。</p>
</blockquote>
<p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n 个元素的表进行排序总共进行至多 n-1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<p>需要注意的是，上述过程只是每次找最小值的办法。实际上也可以每次找最大值，思路是一样的。</p>
<p>选择排序的示意图（图片来自维基百科）：</p>
<center><br><img src="http://meto.chinakook.com/blog-images/Selection_sort_animation.gif" alt=""></center>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>设要给数组 arr[] 排序，它有 n 个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> min, temp, len = arr.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</div><div class="line">            min = i;<span class="comment">//未排序序列中最小数据数组下标</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123; <span class="comment">//在未排序元素中继续寻找最小元素，并保存其下标</span></div><div class="line">                <span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</div><div class="line">                    min = j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (min != i) &#123;</div><div class="line">                temp = arr[min]; <span class="comment">//将最小元素放到已排序序列的末尾</span></div><div class="line">                arr[min] = arr[i];</div><div class="line">                arr[i] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>选择排序需要进行 n-1 轮比较。很显然，比较次数 O(n^2)，比较次数与关键字的初始状态无关，总的比较次数 N = (n-1) + (n-2) + … + 1 = nx(n-1)/2。</p>
<p>交换次数 O(n)，最好情况是，已经有序，交换 0 次；最坏情况是，逆序，交换 n-1 次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，n 值较小时，选择排序比冒泡排序快。</p>
<p>选择排序的赋值次数：最坏情形下需要交换 n-1 次，对于上面的代码，需要赋值 3(n-1) 次。而最佳情况下，则需要 0 次。如果假定平均分布，大约需要3n/2。</p>
<p>冒泡排序可以在最佳情况下有 O(n) 复杂度，那么选择排序行不行呢？ 很遗憾，不行。选择排序每次只找最小值，但它并不能知道其他值是否有序排列。因此，选择排序在最优、最坏、平均情况下的<strong>时间复杂度</strong>均为 O(n^2)，<strong>空间复杂度</strong>（额外空间）为 O(1).</p>
<h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><p>对于选择排序的稳定性是存在一定争议的。但在本例中，最小值和另一个值相同的时候我们并不需要交换它们，选择排序是稳定排序。其实排序算法中，有些稳定算法可以变换成不稳定算法，而不稳定排序算法又有很多办法可以变成稳定的，这在《算法》第四版中有所提及。所以，没有严格意义上的稳定与不稳定排序。</p>
<h3 id="算法适用场景"><a href="#算法适用场景" class="headerlink" title="算法适用场景"></a>算法适用场景</h3><p>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的 O(n^2) 复杂度，选择排序在数据量较大的时候显得力不从心。因此，它适用于简单数据排序。</p>
<p><br>ikook<br>2017.08.11</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;java 实现排序算法系列&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="论算法" scheme="http://ikookblog.com/categories/%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机技术" scheme="http://ikookblog.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://ikookblog.com/tags/java/"/>
    
      <category term="排序算法" scheme="http://ikookblog.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ikookblog.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>你付费了吗？</title>
    <link href="http://ikookblog.com/2017/07/28/essay01/"/>
    <id>http://ikookblog.com/2017/07/28/essay01/</id>
    <published>2017-07-27T16:00:00.000Z</published>
    <updated>2017-07-28T15:39:55.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>时间是世界上的一切成就的土壤。时间给空想者痛苦，给创造者幸福。  —— 麦金西</p>
</blockquote>
<p>今天的重点不是时间，上面的引用语也许会误导你。今天，我要和你们说说付费。付费省下来的就是时间，所以拿时间做引用也就合理了。</p>
<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>免费，免除费用，也就是不要钱。可免费真的就是「免费」吗？免费，免掉的是钱，可付出的是时间和效率成本。</p>
<p>之前一直想学习投资理财，可苦于不知道如何入手迟迟没有接触。前些日子无意中在一位前辈的博客中看到「21 天小白理财训练营」，付费，9 块钱。钱很少，但就是有人不买单。</p>
<p>我加了，因为最起码能让我了解理财是个什么东西，能让我了解以后怎么去学。我之前一直自己找书，找资料看，光找资料就花费很多时间，然后看到各种术语、各种看不懂，就放弃了。付出了时间不说，关键是还什么都没有学到。</p>
<p>前天「21 天小白理财训练营」结束了，我知道了到底什么是理财，知道了常见的理财产品有哪些，知道了哪些产品低风险低收入，哪些产品高风险高收入，还知道了以后该怎么继续深入学习理财。对了，我还在华泰证券开了户，就是用于买股票和基金的账户。这就是我花 9 块钱得到的东西，结束的时候还抢了 6 块钱的红包，比我自己折腾半年学到得多的多。</p>
<p>松浦太郎说过：“想要真正学到东西，就得花钱”，这件事正好说明了这个道理。</p>
<p>其实我不能理解，为什么社会上每天都有人想要绞尽脑汁去免费学东西。学习这件事，免费的东西，永远是最昂贵的。除了钱之外，你必然要花掉人际、时间、心情等各方面的成本。这个世界上，好的、可共享的资源或思想，必然是别人付出心血的结果，为别人的时间和精力还有知识成本付费，是现代人的基本操守。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>为什么付费的东西就能够快速掌握？</p>
<p>付过费的东西，下意识就会去重视，因为你花了钱。花了钱的东西你会不在意吗？不会。并且花钱买的东西，是别人花时间和精力打磨出来的，必然会是一套整体的事物，省去了自己筛选和过滤的时间，自然就能够快速掌握。往往自己折腾过程中会偏离主线，会走错路。</p>
<p>在这个时代，我们要努力培养的，是维系雇佣关系的能力，而不是人情关系的能力。</p>
<p>很多人，有些事情需要别人帮助，第一时间想到的是亲戚，而不是雇佣劳动力。但往往最后发现反而不比请一个需要的专业人员来的轻松。那是因为，你没办法展现出你雇主的本色，不能坦率的提出你的需求，达到一种合作的平衡，所以，往往找朋友找亲戚帮助永远觉得很累很疲倦。</p>
<p>一旦成为了雇主，你们的关系就不一样了。关系就是一切，一切为了关系。相比人情，雇佣关系是最飒爽的关系，它让你们双方都绽放出最舒服的工作状态。不满意的雇员可以一换再换，换到满意为止，亲戚朋友你能这样吗？</p>
<p>其实，我们就生活在一个雇佣的时代，每天我们每个人都在服务别人，也被别人服务。有些人会觉得自己很迷茫，生活没有改进，那是因为，你既不知道怎么服务别人，也不知道如何服务自己、如何被别人服务。</p>
<p>如果不知道，那就去花钱吧，从花钱开始，花小钱开始。</p>
<p>花钱是一门艺术，一旦开始把钱花对了地方，你的状态就活了，你的人际关系，你的专业，你的社交，你的眼界，随即就会开始发生变化。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>那么该如何花钱呢？</p>
<p>不管你现在一个月有多少收入，你一定要养成每个月「 为自己的未来花点钱的习惯」，一开始，最低要把这个标准订到 5%，以后根据自己的经济实力调整。</p>
<p>就好比我一个月有 1500 元的生活费，我每月都会拿出 200 元花给未来的自己。</p>
<p>怎么花呢？为一切优质内容付费。</p>
<p>订阅对你有用的内容。比如我加入了刘欣老师组织的「2017编程能力提高社群」，每季 300 元，一季 3 个月，时长为一年；我还加入了stormzhang 的小密圈，一年 129 元；我还准备学习长投学堂的投资理财初级课；我每月都会买书，技术类、文学类等都有。这些都是为优质内容付费。</p>
<p>这些优质内容，都会结结实实长在我的气质和见识上，就算我很瘦弱。我相信 30 岁之后，我就会知道我是如何成为一个更好的人的。</p>
<p>当你学会花钱的时候，周围人的才会觉得你是一个不为花钱拧巴的人， 才会愿意和你分享更多的资源。就好比 stormzhang （开发者，目前做管理，维护了一个优质的公众号）做付费订阅的时候，就是因为我懂得为他的内容赞赏，所以才邀请了我。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>学会远离一切免费的东西。</p>
<p>在这个信息爆炸的时代，有很多免费的东西已经可以让我们生活得比较好，不花钱也不会有什么问题。</p>
<p>可是你想想，你会为免费的东西付出多少钱之外的东西，时间、精力哪样都比钱值钱。慢慢你会发现，你通过免费所得永远都不比你花钱所得到的来容易和轻松，并且你花的时间要比付费多得多。</p>
<p>我们整个社会正在进入转型期，很多东西都会收费，很多人都会为优质内容付费。未来你是否进步，一定是我们能否自己拿钱去买别人的技能、思想，你有多愿意为知识付费，你就成长得有多快。未来最值钱的， 一定是你需要为别人的专业付费。</p>
<p>你为别人的思想输出付费，他们有了经济输入，才能更好地输出。这个时代，一定要学会付费，一定要学会远离免费的东西。这个观念一定要有。学会了为优质内容付费，你就会收获金钱以外的很多东西，知识、时间、气质、内涵 …</p>
<p><br>ikook<br>2017.07.28</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时间是世界上的一切成就的土壤。时间给空想者痛苦，给创造者幸福。  —— 麦金西&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天的重点不是时间，上面的引用语也许会误导你。今天，我要和你们说说付费。付费省下来的就是时间，所以拿时间做引用也就合理了。&lt;/
    
    </summary>
    
      <category term="随笔集" scheme="http://ikookblog.com/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
      <category term="随笔" scheme="http://ikookblog.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="http://ikookblog.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 常用命令归纳</title>
    <link href="http://ikookblog.com/2017/07/24/mysql_crash_course/"/>
    <id>http://ikookblog.com/2017/07/24/mysql_crash_course/</id>
    <published>2017-07-23T16:00:00.000Z</published>
    <updated>2017-08-06T13:25:45.407Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>《MySQL 必知必会》学习总结&amp;&amp;常用命令归纳，看完这篇文章就不用买《MySQL 必知必会》了，这篇就够了。</p>
</blockquote>
<h2 id="数据库基础概念-amp-amp-什么是-SQL、MySQL"><a href="#数据库基础概念-amp-amp-什么是-SQL、MySQL" class="headerlink" title="数据库基础概念&amp;&amp;什么是 SQL、MySQL"></a>数据库基础概念&amp;&amp;什么是 SQL、MySQL</h2><h3 id="数据库基础概念"><a href="#数据库基础概念" class="headerlink" title="数据库基础概念"></a>数据库基础概念</h3><ul>
<li><strong>数据库(database)</strong> 保存有组织的数据的容器(通常是一个文件或者一组文件)。<br><br></li>
<li><strong>表(table)</strong> 某种特定类型数据的结构化清单。<br><br></li>
<li><strong>模式(schema)</strong> 关于数据库和表的布局及特定的信息。<br><br>模式可以用来描述数据库中特定的表以及整个数据库(和其中表的关系)。<br><br></li>
<li><strong>列(column)</strong> 表中的一个字段。所有表都是由一个或者多个列组成的。<br><br></li>
<li><strong>数据类型(datatype)</strong> 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。<br><br></li>
<li><strong>行(row)</strong> 表中的一个记录。<br><br></li>
<li><strong>主键(primary key)</strong> 一列（或一组列），其值能够唯一区分表中每个行。<br>主键的条件：<br>1.任意两行都不具有相同的主键值；<br>2.每个行都必须具有一个主键值（主键列不允许 NULL 值）</li>
</ul>
<h3 id="什么是-SQL"><a href="#什么是-SQL" class="headerlink" title="什么是 SQL"></a>什么是 SQL</h3><p>SQL 是结构化查询语言（Structured Query Language）的缩写。SQL 是一种专门用来与数据库通信的语言。</p>
<h5 id="SQL-有以下优点："><a href="#SQL-有以下优点：" class="headerlink" title="SQL 有以下优点："></a>SQL 有以下优点：</h5><ul>
<li>SQL 不是某个特定数据库供应商专有的语言。几乎所有重要的 DBMS 都支持 SQL，所以，学习此语言几乎能与所有数据库打交道。<br><br></li>
<li>SQL 简单易学。它的语句全都是由描述性很强的英语单词组成，而且这些单词的数目不多。<br><br></li>
<li>SQL 尽管看上去很简单，但它实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库错操作。</li>
</ul>
<h3 id="什么是-MySQL"><a href="#什么是-MySQL" class="headerlink" title="什么是 MySQL"></a>什么是 MySQL</h3><p>数据的所有存储、检索、管理和处理实际上是由数据库软件 —— DBMS（数据库管理系统）完成的。MySQL 是一种 DBMS，即它是一种数据库软件。</p>
<h5 id="MySQL-的优点："><a href="#MySQL-的优点：" class="headerlink" title="MySQL 的优点："></a>MySQL 的优点：</h5><ul>
<li>成本 —— MySQL 是开放源代码的，一般可以免费使用（甚至可以免费修改）。<br><br></li>
<li>性能 —— MySQL 执行很快，非常快。<br><br></li>
<li>可信赖 —— 某些非常重要和声望很高的公司、站点使用 MySQL，这些公司和站点都用 MySQL 来处理自己的重要数据。<br><br></li>
<li>简单 —— MySQL 很容易安装和使用。</li>
</ul>
<h2 id="使用-MySQL-的常用命令归纳（前方高能，很长，很详细）"><a href="#使用-MySQL-的常用命令归纳（前方高能，很长，很详细）" class="headerlink" title="使用 MySQL 的常用命令归纳（前方高能，很长，很详细）"></a>使用 MySQL 的常用命令归纳（前方高能，很长，很详细）</h2><h3 id="USE-mysql"><a href="#USE-mysql" class="headerlink" title="USE mysql;"></a>USE mysql;</h3><p>  输出：<code>Database changed</code><br>  分析：选择并打开「mysql」这个数据库，记住，必须先使用 USE 打开数据库，才能读取其中的数据。</p>
<blockquote>
<p>注：这里的 mysql 是指所选数据库的名字。该数据库是 MySQL 软件内部使用的数据库。</p>
</blockquote>
<h3 id="SHOW-语句"><a href="#SHOW-语句" class="headerlink" title="SHOW 语句"></a>SHOW 语句</h3><ul>
<li><code>SHOW DATABASES;</code><br><br>分析：返回一个可用的数据库列表。该列表中可能包含 MySQL 内部使用的数据库。<br><br></li>
<li><code>SHOW TABLES;</code><br><br>分析：获得一个所选数据库内的表的列表，即返回当前选择的数据库内可用表的列表。<br><br></li>
<li><code>SHOW COLUMNS FROM test_table;</code><br><br>分析：返回要求显示的表的表列。<code>SHOW COLUMNS</code> 要求给出一个表名(这里例子中的 FROM test_table，test_table 为表名)，它对每个字段返回一行，行中包括字段名、数据类型、是否允许 NULL、键信息、默认值以及其他信息。<br><br>注：DESCRIBE 语句，MySQL 支持用 DESCRIBE 作为 SHOW COLUMNS FROM 的一种快捷方式。即 <code>DESCRIBE test_table;</code> 是 <code>SHOW COLUMNS FROM test_table;</code> 的一种快捷方式。<br><br></li>
<li>所支持的其他 <code>SHOW</code> 语句还有：<br><br>1.<code>SHOW STATUS;</code> 用于显示广泛的服务器状态信息；<br><br>2.<code>SHOW CREATE DATABASE;</code> 和 <code>SHOW CREATE TABLE;</code> 分别用来显示创建特定数据库或表的 MySQL 语句；<br><br>3.<code>SHOW GRANTS;</code> 用来显示授予用户（所有用户或特定用户）的安全权限；<br><br>4.<code>SHOW ERRORS;</code> 和 <code>SHOW WARNINGS;</code> 用来显示服务器错误或者警告信息。<br><blockquote>
<p>注：在 MySQL 命令行程序中，执行命令 <code>HELP SHOW</code> 显示允许操作的 SHOW 语句。</p>
</blockquote>
</li>
</ul>
<h3 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h3><p>最经常使用的 SQL 语句可能就是 SELECT 语句了，它的用途是从一个或多个表中检索信息。为了使用 SELECT 检索表数据，必须至少给出两条信息 —— 想选择什么，以及从什么地方选择。</p>
<blockquote>
<p>注：以下例子使用的数据库、表名、以及表列等如下：<br>数据库：<br>crashcourse<br>表：<br><img src="http://meto.chinakook.com/blog-images/mysql/tables.png" alt="SHOW TABLES"><br><br>表列：</p>
<ul>
<li>customers<br><img src="http://meto.chinakook.com/blog-images/mysql/customers.png" alt=""><br><br></li>
<li>orderitems<br><img src="http://meto.chinakook.com/blog-images/mysql/orderitems.png" alt=""><br><br></li>
<li>orders;<br><img src="http://meto.chinakook.com/blog-images/mysql/orders.png" alt=""><br><br></li>
<li>productnotes;<br><img src="http://meto.chinakook.com/blog-images/mysql/productnotes.png" alt=""><br><br></li>
<li>products;<br><img src="http://meto.chinakook.com/blog-images/mysql/products.png" alt=""><br><br></li>
<li>vendors;<br><img src="http://meto.chinakook.com/blog-images/mysql/vendors.png" alt=""></li>
</ul>
</blockquote>
<h4 id="检索单个列"><a href="#检索单个列" class="headerlink" title="检索单个列"></a>检索单个列</h4><p>输入：<code>SELECT prod_name FROM products;</code><br>分析：上述语句利用 SELECT 语句从 products 表中检索一个名为 prod_name 的列。所需的列名在 SELECT 关键字之后给出，FROM 关键字指出从其中检索数据的表名。</p>
<blockquote>
<p>注： 输出的结果为未排序的数据；SQL 语句是不区分大小写的，但是建议对所有 SQL 关键字使用大写，而对所有列和表名使用小写，这样做有助于使代码更加易于阅读和调试。</p>
</blockquote>
<h4 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h4><p>输入：<code>SELECT prod_id, prod_name, prod_price FROM products;</code><br>分析：从一个表中检索多个列，和前一个例子使用相同的 SELECT 语句，唯一不同的地方是必须在 SELECT 关键字后给出多个列名，列名之间必须用逗号分隔。</p>
<h4 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h4><p>输入：<code>SELECT * FROM products;</code> 命令<br>分析：如果给定一个通配符*，则返回表中所有列。列的顺序一般是列在表定义中出现的顺序。</p>
<blockquote>
<p>注： 一般，除非你确实需要表中的每个列，否则最 好别使用*通配符。虽然使用通配符可能会使你自己省事，不 用明确列出所需列，但检索不需要的列通常会降低检索和应 用程序的性能。</p>
</blockquote>
<h4 id="检索不同的行"><a href="#检索不同的行" class="headerlink" title="检索不同的行"></a>检索不同的行</h4><p>如何检索出有不同值的列表呢？解决办法是使用 DISTINCT 关键字，顾名思义，此关键字指示 MySQL 只返回不同的值。</p>
<p>输入：<code>SELECT DISTINCT vend_id FROM products;</code><br>分析：SELECT DISTINCT vend_id 告诉 MySQL 只返回不同（唯一）的 vend_id 行。如果使用 DISTINCT 关键字，它必须直接放在列名的前面。</p>
<blockquote>
<p>注：不能部分使用 DISTINCT。DISTINCT 关键字应用于所有列而不仅是前置它的列。如果给出 SELECT DISTINCT vend_id, prod_price，除非指定的两个列的值相同，否则所有行都将被检索出来。<br>如下：<br>没有使用 DISTINCT 关键字<br><img src="http://meto.chinakook.com/blog-images/mysql/no_distinct.png" alt=""><br><br><br>使用 DISTINCT 关键字<br><img src="http://meto.chinakook.com/blog-images/mysql/distinct.png" alt=""></p>
</blockquote>
<h4 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h4><p>输入：<code>SELECT prod_name FROM products LIMIT 5;</code><br>分析：为了返回第一行或者前几行，可使用 LIMIT 子句。此语句使用 SELECT 语句检索单个列。LIMIT 5 指示 MySQL 返回不多于5行。</p>
<p>为得出下一个 5 行，可指定要检索的开始行和行数。</p>
<p>输入：<code>SELECT prod_name FROM products LIMIT 5,5;</code><br>分析：LIMIT 5, 5 指示 MySQL 返回从行 5 开始的 5 行。第一个数为开始位置，第二个数为要检索的行数。</p>
<p>所以，带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始。</p>
<blockquote>
<p>注：检索出来的第一行为行 0 而不是行 1。因此，LIMIT 1, 1将检索出第二行而不是第一行；MySQL 5 支持 LIMIT 的另一种替代语法。LIMIT4OFFSET 3意为从行 3 开始取 4 行，就像 LIMIT 3, 4 一样。</p>
</blockquote>
<h4 id="使用完全限定的表名"><a href="#使用完全限定的表名" class="headerlink" title="使用完全限定的表名"></a>使用完全限定的表名</h4><p>到此为止使用的 SQL 例子只通过列名引用列。也可能会使用完全限定的名字来引用列（同时使用表名和列字）。请看以下例子：</p>
<p>输入：<code>SELECT products.prod_name FROM products;</code><br>分析：这条语句在功能上和 <code>SELECT prod_name FROM products;</code> 语句是一样的。但这里指定了一个完全限定的列名。</p>
<p>表名也是可以完全限定的，例如：<code>SELECT products.prod_name FROM crashcourse.products;</code> 这条语句和刚才的那条语句是一样的。</p>
<h3 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h3><p>如何使用 SELECT 语句的 ORDER BY 子句，根据需要排序检索出来的数据呢？下面我们来看一下。</p>
<h4 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h4><p>我们上面使用 SELECT 语句检索出来的数据都是没有经过排序的。关系数据库理论认为，如果不明确规定排序顺序，则不应该假定检索出来的数据的顺序有意义。</p>
<p>为了明确地排序用 SELECT 语句检索出来的数据，可使用 ORDER BY 子句。</p>
<p>输入：<code>SELECT prod_name FROM products ORDER BY prod_name;</code><br>分析：<br>未完待续…</p>
<p><br>ikook<br>2017.07.24</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《MySQL 必知必会》学习总结&amp;amp;&amp;amp;常用命令归纳，看完这篇文章就不用买《MySQL 必知必会》了，这篇就够了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数据库基础概念-amp-amp-什么是-SQL、MySQL&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="数据库" scheme="http://ikookblog.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://ikookblog.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://ikookblog.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>如果你很忙，你一定在什么地方做错了</title>
    <link href="http://ikookblog.com/2017/06/18/view-text-01/"/>
    <id>http://ikookblog.com/2017/06/18/view-text-01/</id>
    <published>2017-06-17T16:00:00.000Z</published>
    <updated>2017-07-02T10:20:34.317Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文为观文记，原文链接：<a href="http://www.jianshu.com/p/4dc3518089a0" target="_blank" rel="external">http://www.jianshu.com/p/4dc3518089a0</a></p>
</blockquote>
<a id="more"></a>
<p>如果你很忙，你一定是在什么地方做错了。我们不应艰苦地工作，而应艰苦工作。艰苦工作不是艰苦地工作，两个有本质的区别。如果你的目标是为了创造一种卓越的人生和生活，那么，忙碌和精疲力竭就是你最大的敌人。</p>
<h2 id="柏林研究项目"><a href="#柏林研究项目" class="headerlink" title="柏林研究项目"></a>柏林研究项目</h2><p>1990 年初，三名心理学家组成研究小组拜访了柏林艺术大学。他们此行的目的是为了专门研究小提琴演奏者。</p>
<p>他们分别对比研究了两个小组：优秀演奏者小组、普通演奏者小组。这三位研究者参照不同主题安排了一系列的深度访谈。他们给了两个小组的每个成员人手一册日记本，日记本把每 24 小时划分为一个个 50 分钟的时间区块。他们请小组成员返回宿舍并且要求他们对今后每天的活动情况进行详细的记录。</p>
<center> <img src="http://meto.chinakook.com/blog-images/view-text-01.jpg" alt="Violinist Diana Yukawa"> </center><br><center> <em>Violinist Diana Yukawa</em> </center>

<p>研究者们希望通过这些数据分析出一个最基本的问题： <strong>为什么优秀演奏者比普通演奏者更加出色？</strong></p>
<h2 id="解密优秀演奏者模式"><a href="#解密优秀演奏者模式" class="headerlink" title="解密优秀演奏者模式"></a>解密优秀演奏者模式</h2><p>在时间上，<strong>两个小组花费在音乐上的时间，平均计算的话，几乎完全一样（大约每周 50 个小时）。</strong> 差异在于他们如何利用这些时间。<strong>优秀演奏者在刻意练习「deliberate practice」上投入的时间几乎是普通演奏者的三倍。</strong></p>
<p>研究者们着手研究这些学生到底是如何安排他们的时间的。那些<strong>普通演奏者</strong>，他们发现，把正常的音乐课业和练习分配在一个全天范围。他们几乎均匀地分配了学习和练习的时间。<strong>优秀演奏者</strong>，与之形成强烈的对比，优秀演奏者把他们的学习和练习都集中在两个预先精心规划好的时段。这两个时段分别为：早上、下午。</p>
<p>这种将课业学习和休闲生活相互隔离的做法，已经在这些演奏者生活的其他方面产生了相应的影响。睡眠就是一个很好的例证：<strong>优秀演奏者平均来说，要比普通演奏者在睡眠方面至少多出一个小时。</strong></p>
<p>再来看看演奏者们的放松和休闲活动。统计显示，<strong>优秀演奏者的休闲时间要大大多于普通演奏者，</strong> 而且，那些最佳演奏者，精英中的精英，在放松和休闲上的时间花费更加突出。</p>
<h2 id="艰苦工作「Hard-Work」不同于艰苦地工作「Hard-to-Do-Work」"><a href="#艰苦工作「Hard-Work」不同于艰苦地工作「Hard-to-Do-Work」" class="headerlink" title="艰苦工作「Hard Work」不同于艰苦地工作「Hard to Do Work」"></a>艰苦工作「Hard Work」不同于艰苦地工作「Hard to Do Work」</h2><p>针对研究结果的结论：</p>
<ul>
<li>普通演奏者花费练习时间和优秀演奏者一样多<br><br></li>
<li>普通演奏者没有将主要精力用在必要的练习类型上「在一些关键性的刻意练习上花费的时间几乎只有优秀演奏者的三分之一」<br><br></li>
<li>普通演奏者将其学习和练习时间近乎随意地安排在一天之中。因此，即使他们花费在课业上时间不比优秀演奏者更长的话，他们每天用于睡眠的时间也会减少，而且在心理方面同样会感受到更多的压力。不言而明，在小提琴演奏方面，他们仍然会处于平庸的状态。</li>
</ul>
<p>柏林研究提供了一项重要的实验依据，证明了艰苦工作与艰苦地工作之间的差异：</p>
<ul>
<li><strong>艰苦工作</strong> 就是刻意练习。当你进行这些刻意练习时，它其实很缺乏趣味性，但是你没有必要在一天中过多地进行这项活动。刻意练习提供了一个可测量技能进展的工具 - 它可以让你产生强烈的满足感和足够的动机。因而，尽管刻意练习的确非常辛苦，但他不会使你精疲力尽，而且它还可以很好地与轻松和惬意生活相融合。<br><br></li>
<li><strong>艰苦地工作</strong>，与之恰恰相反，它几乎让你精疲力竭。你一整天都处在一种错误的忙碌状态中。就像来自柏林研究报告中那些普通演奏者一样，不断感受疲惫和压力。但同时，正如你所看到的，对你的实际成就或能力的改进却只能产生很小的影响。</li>
</ul>
<p>这项分析引发了一个重要的结论。无论你是一名学生，还是一名正走在职业发展道路上的专业人士，<strong>如果你的目标是为了创造一种卓越的人生和生活，那么，忙碌和精疲力竭就是你最大的敌人。</strong> 如果你正在经历周而复始的工作或生活压力，你一定是在什么地方做错了！你就是那些来自柏林艺术大学的普通演奏者 - 而不是优秀演奏者。你将你的生活（错误地）构建在艰苦地工作之上，而不是（正确的）艰苦工作。</p>
<p>这项研究报告建议的解决方案，正如我经常倡导的那样，超乎寻常的简单：Do less 。但必须全情投入，而且聚焦在关键环节。在你完成它们之后，请尽情享受一天之中的剩余时光并且快乐地生活吧。</p>
<h2 id="我的感悟"><a href="#我的感悟" class="headerlink" title="我的感悟"></a>我的感悟</h2><p>这篇文章很好的讲述了「艰苦工作」与「艰苦地工作」 的区别。我们应当在学习提高时全身心的投入其中，并享受其中的乐趣。在完成任务或者疲倦之后尽情享受欢乐的时光，释放自己，尽情玩耍，喝杯农药。主题是，不要让自己陷入 <strong>假学习</strong> 的状态，千万不要每天都在学习，却不知道自己在干什么，到头来学习娱乐两悲伤，抛弃了惬意的生活更远离了优秀的自己。</p>
<p>如果你的目标是为了创造一种卓越的人生和生活，那么，忙碌和精疲力竭就是你最大的敌人 | 刻意练习很重要 | Do less</p>
<hr>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27506733&auto=1&height=66"></iframe></p>
<center> Oh Father，Happy Father’s Day </center>

<p><br><br><br>ikook<br>2017.06.18</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文为观文记，原文链接：&lt;a href=&quot;http://www.jianshu.com/p/4dc3518089a0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/4dc3518089a0&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="观文记" scheme="http://ikookblog.com/categories/%E8%A7%82%E6%96%87%E8%AE%B0/"/>
    
    
      <category term="感悟" scheme="http://ikookblog.com/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="观文" scheme="http://ikookblog.com/tags/%E8%A7%82%E6%96%87/"/>
    
      <category term="学习技巧" scheme="http://ikookblog.com/tags/%E5%AD%A6%E4%B9%A0%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin-开始</title>
    <link href="http://ikookblog.com/2017/06/16/kotlin01/"/>
    <id>http://ikookblog.com/2017/06/16/kotlin01/</id>
    <published>2017-06-15T16:00:00.000Z</published>
    <updated>2017-07-02T10:23:48.920Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Kotlin 从入门到放弃–开始</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是-Kotlin"><a href="#什么是-Kotlin" class="headerlink" title="什么是 Kotlin"></a>什么是 Kotlin</h2><p>简单来说，Kotlin 是一门由「JetBrains」开发的基于 JVM 的静态类型编程语言，它 100% 兼容 Java。</p>
<p>它可以用于：</p>
<ul>
<li>服务器开发</li>
<li>Android 开发</li>
<li>前端开发</li>
<li>本地执行程序</li>
</ul>
<p>这是要全栈的节奏啊，它的目标应该就是要成为一门全栈编程语言。</p>
<h3 id="维基百科介绍"><a href="#维基百科介绍" class="headerlink" title="维基百科介绍"></a>维基百科介绍</h3><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，它也可以被编译成为 JavaScript 源代码。它主要是由俄罗斯圣彼得堡的 JetBrains 开发团队所发展出来的编程语言，其名称来自于圣彼得堡附近的科特林岛。2012 年 1 月，著名期刊《 Dr. Dobb’s Journal 》中 Kotlin 被认定为该月的最佳语言。虽然与 Java 语法并不兼容，但 Kotlin 被设计成可以和 Java 代码相互运作，并可以重复使用如 Java 集合框架等的现有 Java 类库。</p>
<h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><p>2011 年 7 月，JetBrains 推出 Kotlin 项目，这是一个面向 JVM 的新语言，它已被开发一年之久。JetBrains 负责人Dmitry Jemerov 说，大多数语言没有他们正在寻找的特性，Scala 除外，他指出了 Scala 的编译时间慢这一明显缺陷。Kotlin 的既定目标之一是像 Java 一样快速编译。</p>
<p>2012 年 2 月，JetBrains 以 Apache 2 许可证开源此项目，Jetbrains 希望这个新语言能够推动 IntelliJ IDEA 的销售。</p>
<p>Kotlin v1.0 于 2016 年 2 月 15 日发布。这被认为是第一个官方稳定版本，并且 JetBrains 已准备从该版本开始的长期向后兼容性。</p>
<p>在 Google I/O 2017 中，Google 宣布在 Android 上为 Kotlin 提供支持。</p>
<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><h3 id="安装-Java"><a href="#安装-Java" class="headerlink" title="安装 Java"></a>安装 Java</h3><p>Kotlin 是基于 JVM 的编程语言，所以首先一定要先安装好 Java 开发环境，并配置好环境变量。点击链接：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">Java SE</a> 下载对应版本，安装完成后配置环境变量。安装过程自行 Google。</p>
<p>下面贴一下 Windows 下配置环境变量的过程。</p>
<ol>
<li>打开，我的电脑 –&gt; 属性 –&gt; 高级 –&gt; 环境变量 <br><br></li>
<li>新建系统变量 JAVA_HOME 和 CLASSPATH：<br>变量名：JAVA_HOME<br>  变量值：C:\Program Files\Java\jdk1.7.0（这个是你JDK安装的位置，注意变量值到JAVA JDK文件夹，复制粘贴）<br>变量名：CLASSPATH<br>变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;（复制即可）<br><br></li>
<li>选择「系统变量」中变量名为「Path」的环境变量，双击该变量，把 JDK 安装路径中 bin 目录的绝对路径，添加到「Path」变量的值中，并使用半角的分号和已有的路径进行分隔。 <br>变量名：Path <br>变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;（在系统变量中找到「Path」变量，把前面的变量放到原有变量最前面）</li>
</ol>
<h3 id="安装-Kotlin"><a href="#安装-Kotlin" class="headerlink" title="安装 Kotlin"></a>安装 Kotlin</h3><p>我这里选择 Working with the Command Line Compiler 的方式来开始学习 Kotlin。使用这种方式便于理解 Kotlin 的运行原理，并且命令行其实也是蛮炫酷的，更没有想象的那么难，命令不会可以查。</p>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>在  <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.1.2-5" target="_blank" rel="external">GitHub</a> 中下载安装包，然后手动解压到自己想要的目录，解压完成后，配置环境变量。将 Kotlin 解压目录下的 bin 路径添加到环境变量的「系统变量」中「Path」下。</p>
<h4 id="Mac-amp-Linux"><a href="#Mac-amp-Linux" class="headerlink" title="Mac &amp; Linux"></a>Mac &amp; Linux</h4><p>如果你是 Mac 或者 Linux 系统可以使用下面方式中的任意一种。由于我用的是 Windows，不保证下列方式均可行，并且没有测试过，只是将官方的方法照搬过来而已。</p>
<h5 id="SDKMAN"><a href="#SDKMAN" class="headerlink" title="SDKMAN!"></a>SDKMAN!</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ curl -s https://get.sdkman.io | bash</div><div class="line">$ sdk install kotlin</div></pre></td></tr></table></figure>
<h5 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ brew update</div><div class="line">$ brew install kotlin</div></pre></td></tr></table></figure>
<h5 id="MacPorts"><a href="#MacPorts" class="headerlink" title="MacPorts"></a>MacPorts</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo port install kotlin</div></pre></td></tr></table></figure>
<h2 id="创建并运行第一个-Kotlin-程序"><a href="#创建并运行第一个-Kotlin-程序" class="headerlink" title="创建并运行第一个 Kotlin 程序"></a>创建并运行第一个 Kotlin 程序</h2><p>新建一个名为 hell.kt 的文件，扩展名 .kt 代表是 Kotlin 文件。在文件中输入以下内容：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    println(<span class="string">"Hello, World!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在终端(Terminal)中输入以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kotlinc hello.kt -include-runtime -d hello.jar</div></pre></td></tr></table></figure></p>
<p>注：「kotlinc」 是编译的意思，类似于 javac；「hello.kt」 是需要编译的文件名；「-include-runtime」代表包含进 kotlin 运行时库来运行 hello.kt 的代码来生成 .jar 文件；「-d」代表打包成 .jar 文件的名字。由于 Kotlin 是 JVM 语言，所以最终是转换成 jar 包的。</p>
<p>然后，继续在终端输入以下命令来运行程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ java -jar hello.jar</div></pre></td></tr></table></figure></p>
<p>输出 <code>Hello, World!</code> 代表运行成功。</p>
<hr>
<p>如果要开发由其他 Kotlin 程序使用的库，则可以生成 .jar 文件，而不包含运行时库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kotlinc hello.kt -d hello.jar</div></pre></td></tr></table></figure></p>
<p>在使用该 library 时，需要依赖 Kotlin 运行时环境，所以在编译时，应将出现在类路径中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kotlin -classpath hello.jar HelloKt</div></pre></td></tr></table></figure></p>
<p>注：HelloKt 是 Kotlin 编译器为 hello.kt 文件生成的主类名。</p>
<p>这种方式和上面的区别在于第二步给 hello.jar 指定了一个类 HelloKt，让 hello.jar 中的代码运行在 HelloKt 类里。</p>
<h2 id="交互式-Kotlin-shell"><a href="#交互式-Kotlin-shell" class="headerlink" title="交互式 Kotlin shell"></a>交互式 Kotlin shell</h2><p>Kotlin 内置有一个交互式的 Shell。交互式 shell 的意思是可以直接在 shell 里输入代码，然后回车直接立即执行。</p>
<p>在终端输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kotlinc-jvm</div></pre></td></tr></table></figure></p>
<p>会输出以下欢迎信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Welcome to Kotlin version 1.1.2-5 (JRE 1.8.0_112-b15)</div><div class="line">Type :help for help, :quit for quit</div></pre></td></tr></table></figure></p>
<p>欢迎信息中给出了退出的方式「:quit」</p>
<h2 id="Kotlin-脚本"><a href="#Kotlin-脚本" class="headerlink" title="Kotlin 脚本"></a>Kotlin 脚本</h2><p>Kotlin 也可以直接执行脚本。「脚本」就是在一个文件中写入想要执行的代码，然后输入一个命令就可以直接执行脚本里面的代码，不需要编译。Kotlin 脚本以 .kts 拓展名结尾。</p>
<p>例如：<br>新建名为 hello.kts 的脚本，在其中输入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">println(&quot;Hello Kotlin Script!&quot;)</div></pre></td></tr></table></figure></p>
<p>然后在终端输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kotlinc -script hello.kts</div></pre></td></tr></table></figure></p>
<p>脚本执行，然后输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello Kotlin Script!</div></pre></td></tr></table></figure></p>
<p>至此，Kotlin 从入门到放弃的第一篇「开始」就介绍完了，本文介绍了 Kotlin 的安装方式以及使用命令执行 Kotlin 程序的方法。建议其中内容均手动实践几遍，实践出真知。</p>
<p>本文参考及学习地址：<a href="http://kotlinlang.org/docs/tutorials/command-line.html" target="_blank" rel="external">JetBrains/kotlin: Working with the Command Line Compiler</a></p>
<p><br>ikook<br>2017.06.16</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Kotlin 从入门到放弃–开始&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://ikookblog.com/categories/Kotlin/"/>
    
    
      <category term="kotlin" scheme="http://ikookblog.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之「概述」</title>
    <link href="http://ikookblog.com/2017/04/18/design_pattern_summarize/"/>
    <id>http://ikookblog.com/2017/04/18/design_pattern_summarize/</id>
    <published>2017-04-17T16:00:00.000Z</published>
    <updated>2017-06-03T18:08:58.413Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>设计模式学习系列总结笔记之「概述」</p>
</blockquote>
<a id="more"></a>
<p>本文内容均来自「刘伟」前辈 CSDN 博客，只是将内容抽取，作为自己学习总结以及日后复习之用。</p>
<p>原文链接：<a href="http://blog.csdn.net/LoveLion/article/category/738450/13" target="_blank" rel="external">http://blog.csdn.net/LoveLion/article/category/738450/13</a></p>
<h2 id="设计模式从何而来"><a href="#设计模式从何而来" class="headerlink" title="设计模式从何而来"></a>设计模式从何而来</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>Christopher Alexander 在其出版的书中归纳出 253 个模式，对每一个模式（Pattern）都从 Context「前提条件」、Theme 或 Proble「目标问题」、 Solution「解决问题」三个方面进行了描述。</p>
<p>Christopher Alexander 在其另一著作中提出了模式的定义：</p>
<p><strong> 每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无须再重复相同的工作。 </strong></p>
<p>简单来说：</p>
<p><strong> 模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。「A pattern is a successful or efficient solution to a recurring problem within a context」 </strong></p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>最早将模式的思想引入软件工程方法学的是1991-1992年以“四人组(Gang of Four，简称GoF，分别是Erich Gamma, Richard Helm, Ralph Johnson和John Vlissides)”自称的四位著名软件工程学者，在1994年归纳发表了23种在软件开发中使用频率较高的设计模式，旨在用模式来统一沟通面向对象方法在分析、设计和实现间的鸿沟。</p>
<p>软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等</p>
<p>软件模式是在软件开发中某些可重现问题的一些有效解决方法，软件模式的基础结构主要由四部分构成，包括问题描述「待解决的问题是什么」、前提条件「在何种环境或约束条件下使用」解法「如何解决」和效果「有哪些优缺点」</p>
<p>在软件模式中，设计模式是研究最为深入的分支，设计模式用于在特定的条件下为一些重复出现的软件设计问题提供合理的、有效的解决方案。</p>
<h2 id="设计模式是什么"><a href="#设计模式是什么" class="headerlink" title="设计模式是什么"></a>设计模式是什么</h2><p>设计模式的一般定义如下：</p>
<p><strong> 设计模式「Design Pattern」是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码的可靠性。 </strong></p>
<p>设计模式一般包括模式名称、问题、目的、解决方法、效果等组成要素，其中关键要素是模式名称、问题、解决方法和效果。</p>
<ul>
<li><p><strong> 模式名称「Pattren Name」</strong> 通过一两个词来描述模式的问题、解决方案和效果；</p>
</li>
<li><p><strong> 问题「Problem」</strong> 描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因；</p>
</li>
<li><p><strong> 解决方案「Solution」</strong> 描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过 UML 类图和核心代码来进行描述；</p>
</li>
<li><p><strong> 效果「Consequences」</strong> 描述了模式的优缺点以及在使用模式时应权衡的问题。</p>
</li>
</ul>
<p>设计模式可分为创建型「Creational」，结构型「Structural」和行为型「Behavioral」三种：</p>
<p><strong> 创建型模式主要用于描述如何创建对象；结构型模式主要用于描述如何实现类或对象的组合；行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。 </strong></p>
<p>在 GoF 23 种设计模式中包含 5 中创建型设计模式、7 种结构型设计模式、11 种行为型设计模式。</p>
<p>此外，根据某个模式主要是用于处理类之间的关系还是对象之间的关系，设计模式还可以分为类模式和对象模式。我们经常将两种分类方式结合使用，如单例模式是对象创建型模式，模板方法模式是类行为型模式。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">模式名称</th>
<th style="text-align:center">学习难度</th>
<th>使用频率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建型模式 Creational Pattern</td>
<td style="text-align:center">单例模式 Singleton Pattern</td>
<td style="text-align:center">★☆☆☆☆</td>
<td>★★★★☆</td>
</tr>
<tr>
<td style="text-align:center">创建型模式 Creational Pattern</td>
<td style="text-align:center">简单工厂模式 Simple Factory Pattern</td>
<td style="text-align:center">★★☆☆☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td style="text-align:center">创建型模式 Creational Pattern</td>
<td style="text-align:center">工厂方法模式 Factory Method Pattern</td>
<td style="text-align:center">★★☆☆☆</td>
<td>★★★★★</td>
</tr>
<tr>
<td style="text-align:center">创建型模式 Creational Pattern</td>
<td style="text-align:center">抽象工厂模式 Abstract Factory Pattern</td>
<td style="text-align:center">★★★★☆</td>
<td>★★★★★</td>
</tr>
<tr>
<td style="text-align:center">创建型模式 Creational Pattern</td>
<td style="text-align:center">原型模式 Prototype Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td style="text-align:center">创建型模式 Creational Pattern</td>
<td style="text-align:center">建造者模式 Builder Pattern</td>
<td style="text-align:center">★★★★☆</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">适配器模式 Adapter Pattern</td>
<td style="text-align:center">★★☆☆☆</td>
<td>★★★★☆</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">桥接模式 Bridge Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">组合模式 Composite Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★★☆</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">装饰模式 Decorator Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">外观模式 Façade Pattern</td>
<td style="text-align:center">★☆☆☆☆</td>
<td>★★★★★</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">享元模式 Flyweight Pattern</td>
<td style="text-align:center">★★★★☆</td>
<td>★☆☆☆☆</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">代理模式 Proxy Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★★☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">职责链模式 Chain of Responsibility Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">命令模式 Command Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★★☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">解释器模式 Interpreter Pattern</td>
<td style="text-align:center">★★★★★</td>
<td>★☆☆☆☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">迭代器模式 Iterator Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★★★</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">中介者模式 Mediator Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">备忘录模式 Memento Pattern</td>
<td style="text-align:center">★★☆☆☆</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">观察者模式 Observer Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★★★</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">状态模式 State Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">策略模式 Strategy Pattern</td>
<td style="text-align:center">★☆☆☆☆</td>
<td>★★★★☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">模板方法模式 Template Method Pattern</td>
<td style="text-align:center">★★☆☆☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">访问者模式 Visitor Pattern</td>
<td style="text-align:center">★★★★☆</td>
<td>★☆☆☆☆</td>
</tr>
</tbody>
</table>
<h2 id="设计模式有什么用"><a href="#设计模式有什么用" class="headerlink" title="设计模式有什么用"></a>设计模式有什么用</h2><p>设计模式来自众多专家的经验和智慧，它们是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作。</p>
<p>设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。当面对同一个设计模式时，你和别人的理解并无而已（编程语不同，跨国界的团队等），因为设计模式是跨语言、跨平台、跨应用、跨国界的。</p>
<p>大部分设计模式都兼顾了系统的可重用性和可拓展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码。许多设计模式将有助于提高系统的灵活性和可拓展性。</p>
<p>合理的使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统。可以让别人能都很快的理解我们的设计思路和实现方案。</p>
<p>学习设计模式将有助于初学者更加深入地理解面向对象思想。「让你知道：如何将代码分散在几个不同的类中？为什么要有“接口”？何谓针对抽象编程？何时不应该使用继承？如何不修改源代码增加新功能？同时还让你能够更好地阅读和理解现有类库（如JDK）与其他系统中的源代码」</p>
<h2 id="刘伟前辈的个人观点"><a href="#刘伟前辈的个人观点" class="headerlink" title="刘伟前辈的个人观点"></a>刘伟前辈的个人观点</h2><p>掌握设计模式并不是一件很难的事情，关键在于多思考、多实践</p>
<p>在学习每一个设计模式时至少应该掌握如下几点：这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；它是如何解决的，掌握它的结构图，记住它的关键代码；能够想到至少两个它的应用实例，一个生活中的，一个软件中的；这个模式的优缺点是什么，在使用时要注意什么。</p>
<p>懂得运用设计模式，「少说多做」</p>
<p>千万不要滥用模式。每个模式都有自己的适用场景，不能为了使用模式而使用模式，滥用模式不如不用模式。</p>
<p>「每一个模式都是一种计策」，它为解决某一类问题而诞生，不管这个设计模式的难度如何，使用频率高不高，都应该好好学学。</p>
<p>设计模式的“上乘”境界：“手中无模式，心中有模式”。模式使用的最高境界是你已经不知道具体某个设计模式的定义和结构了，但你会灵活自如地选择一种设计方案「其实就是某个设计模式」来解决某个问题。所以，对模式的学习不要急于求成。</p>
<p>最后一点来自 GoF 已故成员 John Vlissides 的著作《设计模式沉思录》：模式从不保证任何东西，它不能保证你一定能够做出可复用的软件，提高你的生产率，更不能保证世界和平。模式并不能替代人来完成软件系统的创造，它们只不过会给那些缺乏经验但却具备才能和创造力的人带来希望。</p>
<p><br>ikook<br>2017.04.18</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;设计模式学习系列总结笔记之「概述」&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术栈" scheme="http://ikookblog.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="java" scheme="http://ikookblog.com/tags/java/"/>
    
      <category term="设计模式" scheme="http://ikookblog.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>学习是个啥？</title>
    <link href="http://ikookblog.com/2017/03/23/what_is_learn/"/>
    <id>http://ikookblog.com/2017/03/23/what_is_learn/</id>
    <published>2017-03-22T16:00:00.000Z</published>
    <updated>2017-06-03T17:54:17.150Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>聊聊「学习」和我为什么「爱上了」学习。</p>
</blockquote>
<a id="more"></a>
<h2 id="我为什么「爱上了」学习"><a href="#我为什么「爱上了」学习" class="headerlink" title="我为什么「爱上了」学习"></a>我为什么「爱上了」学习</h2><p>首先，先来聊聊我为什么「爱上」学习了。</p>
<p>我在上大学之前是非常讨厌学习的，对学任何东西都不来感。记得在高中和同学们口口声声说自己非常喜欢数学和物理。是，是挺喜欢的，可这种喜欢是建立在不得不学之上，是在数 10 门课程中，相对而言的，如果没人逼我学，我会「喜欢」？ 未必。</p>
<p>在大一上学期，也许是因为高中留下的后遗症，还和高中一样本本分分上课，课下老老实实做留下的丁点作业。唯一不同的就是把课余时间都用在了到处浪上。</p>
<p>大一上学期末，我突然头脑发热想要学点东西，然后就找了个编程语言学。现在想想当初想学东西的主要原因是：闲的。开始抱着玩玩的心态，却玩上了瘾。当我用代码在电脑屏幕上输出一些东西的时候，那种自豪感和成就感无比强烈，我喜欢这种感觉。</p>
<p>也许就是这样我找到了自己的兴趣所在，慢慢我接触到 IT 领域的东西越来越多，我能用电脑做的东西越来越多，我学的东西就多了起来。这就是兴趣，当你对某个事物产生兴趣之后，你就会不由自主的去了解它，学习它。</p>
<p>今天重点不是我为什么「爱上了」学习，重点是「学习」本身，所以就不再「扯淡」</p>
<h2 id="学习这件破事"><a href="#学习这件破事" class="headerlink" title="学习这件破事"></a>学习这件破事</h2><p>高考前，也许老师们都会说 , 要上了大学，你们就轻松了，就不用这么辛苦的学习了。然而，事实是 ，人生的任何阶段都需要学习，别想偷懒。</p>
<p>一旦你在某一时刻停止了学习，那你的人生就会就此止步，不会再有什么好的发展。想想看哪个你能够想起来的牛B的人是不学习的。</p>
<p>学习有什么方法？学习没有捷径可取，那些你以为已经过时的方法，看书、记笔记、背诵、总结… 其实可以拿来用一辈子，最原始的方法才是最管用的。</p>
<p>其实所有通往成功的方法都不会很新奇，因为没有捷径，关键是看你是否能坚持下去。</p>
<p>当你特别热爱一件事的时候，你从来不会觉得勉强，也从不会觉得苦逼。就像我特别热爱软件编程，即使敲代码到深夜也毫无困意，而自得其乐。</p>
<p>总会听到有人会说「光是在起跑线上就比别人差远了，还谈什么努力，学个毛！」其实我想说，没有谁和你在同一起跑线上的，姑且不谈家庭背景，光谈天赋、身体这些方面，大家就都不一样。要想成功，努力和机遇都不可少，机遇这种东西只能靠运气，而努力，是由你自己去控制的。当然如果机遇来了，你却没有能力去迎接机遇，那岂不可惜。唯一让你有能力去迎接机遇的道路只有一条，就是学习。所以从现在开始，学习！！！</p>
<p>努力？我该往哪方面努力？我连自己想干什么都不知道。所以，你要学习，最艰难的其实就是起步，就是一个选择。你应该想清楚自己想要干什么。哪怕一件很卑微的事，你也应该花一定的时间去学习了解它现有知识，然后通过不断学习，不断创新和发展。</p>
<p>在上面说的我为什么「爱上了」学习中你们也看到了，我为什么爱上了学习。因为我找到了自己兴趣，因为我特别的热爱。能在自己热爱的领域中成长并不断学习还有什么比这更爽的事情了吗？</p>
<p>柴静就说了「什么是幸福？进步就是幸福」，那怎么才能进步，学习才能进步。</p>
<p>就像海尔集团董事长张瑞敏退休以后，还继续保持每周看两本书的速度，一年读100本书的速度。这种不断学习的精神值得任何一个人去学习。</p>
<p>希望我们都能保持阅读和学习，直到老去。</p>
<p><br>ikook<br>2017.03.23</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;聊聊「学习」和我为什么「爱上了」学习。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔集" scheme="http://ikookblog.com/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
      <category term="生活" scheme="http://ikookblog.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="感悟" scheme="http://ikookblog.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Android 官方 Training 文档学习总结系列之「支持不同的设备」</title>
    <link href="http://ikookblog.com/2017/03/16/android_training_study2/"/>
    <id>http://ikookblog.com/2017/03/16/android_training_study2/</id>
    <published>2017-03-15T16:00:00.000Z</published>
    <updated>2017-06-16T07:03:41.883Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Android 官方 Training 文档学习总结系列</p>
</blockquote>
<a id="more"></a>
<p>官方 Training 总结系列第二篇：支持不同的设备。</p>
<h2 id="支持不同的语言"><a href="#支持不同的语言" class="headerlink" title="支持不同的语言"></a>支持不同的语言</h2><p>在任何情况下，从应用代码中提取 UI 字符串并将其存放在外部文件中都是个好办法。Android 可以通过工程中的资源目录轻松实现这一功能。</p>
<h3 id="创建语言区域目录和字符串文件"><a href="#创建语言区域目录和字符串文件" class="headerlink" title="创建语言区域目录和字符串文件"></a>创建语言区域目录和字符串文件</h3><p>如需添加对更多语言的支持，在res/中创建一个额外的values目录，并以连字符和ISO国家代码结尾命名。例如，values-es/ 目录包含的简单资源用于语言代码为“es”的语言区域。Android 根据运行时设备的语言区域设置加载相应的资源。</p>
<p>一旦确定了为哪些语言提供支持，便可创建资源子目录和字符串资源文件。例如：</p>
<p>MyProject/<br>    res/<br>    values/<br>      strings.xml<br>    values-es/<br>      strings.xml<br>    values-fr/<br>      strings.xml</p>
<p>将各个语言区域的字符串值添加到相应文件中。</p>
<p>在运行时，Android 系统会根据当前为用户设备设置的语言区域使用相应的字符串资源集。</p>
<p>例如：英文，/values/strings.xml：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span>My Application<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"hello_world"</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>西班牙文，/values-es/strings.xml：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span>Mi Aplicación<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"hello_world"</span>&gt;</span>Hola Mundo!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>注：可以在任何资源类型上使用语言区域限定符（或任何配置限定符），例如，可以提供本地化版本的可绘制位图。</p>
</blockquote>
<h3 id="使用字符串资源"><a href="#使用字符串资源" class="headerlink" title="使用字符串资源"></a>使用字符串资源</h3><p>可以在源代码和其他 XML 文件中通过 &lt; string >元素的 name 属性来引用自己的字符串资源。</p>
<p>在源代码中，可以使用语法 R.string.&lt; string_name > 引用字符串资源。有许多方法都接受以这种方式引用的字符串资源。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Get a string resource from your app's Resources</span></div><div class="line">String hello = getResources().getString(R.string.hello_world);</div><div class="line"></div><div class="line"><span class="comment">// Or supply a string resource to a method that requires a string</span></div><div class="line">TextView textView = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</div><div class="line">textView.setText(R.string.hello_world);</div></pre></td></tr></table></figure>
<p>在其他 XML 文件中，只要 XML 属性接受字符串值，可以使用语法 @string/<string_name> 引用字符串资源。</string_name></p>
<p>例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:text</span>=<span class="string">"@string/hello_world"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h2 id="适配不同的屏幕"><a href="#适配不同的屏幕" class="headerlink" title="适配不同的屏幕"></a>适配不同的屏幕</h2><p>Android 使用两种常规属性对不同的设备屏幕进行分类：尺寸和密度。我们应该在 APP 中包含一些替代资源，来适应不同的屏幕尺寸和密度，以优化 APP 的外观。</p>
<ul>
<li>4 种普遍尺寸：小(small)，普通(normal)，大(large)，超大(xlarge)</li>
<li>4 种普遍密度：低精度(ldpi), 中精度(mdpi), 高精度(hdpi), 超高精度(xhdpi)</li>
</ul>
<p>要为不同的屏幕声明不同的 layout 和 bitmap，必须将这些替代资源放在不同的目录中，类似于对不同语言字符串的做法</p>
<p>另请注意，屏幕方向（横向或纵向）被认为是屏幕尺寸的变化，因此许多应用程序应修改 layout，以优化每个方向的用户体验。</p>
<h3 id="创建不同的-layout"><a href="#创建不同的-layout" class="headerlink" title="创建不同的 layout"></a>创建不同的 layout</h3><p>要在不同的屏幕尺寸上优化用户体验，应该为要支持的每个屏幕尺寸创建一个唯一的布局 XML 文件。每个 layout 都应该保存到相应的资源目录中，并以 -&lt; screen_size &gt; 为后缀命名。例如，大尺寸屏幕(large screens)的唯一的 layout 文件应该保存在 res/layout-large/ 中。</p>
<blockquote>
<p>注意: 为了匹配合适的屏幕尺寸Android会自动地测量我们的layout文件。所以不需要因不同的屏幕尺寸去担心UI元素的大小，而应该专注于layout结构对用户体验的影响。(比如关键视图相对于同级视图的尺寸或位置)</p>
</blockquote>
<p>例如，此项目包括默认 layout 和大尺寸屏幕的替代布局：</p>
<p>MyProject/<br>    res/<br>    layout/<br>      main.xml<br>    layout-large/<br>      main.xml</p>
<p>layout 文件的名字必须完全一样，为了对相应的屏幕尺寸提供最优的 UI，文件的内容不同。</p>
<p>如平常一样在 app 中简单引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.main);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>系统会根据 app 所运行的设备屏幕尺寸，在与之对应的 layout 目录中加载 layout。</p>
<blockquote>
<p>注意：Android 3.2及以上版本支持定义屏幕尺寸的高级方法，它允许我们根据屏幕最小长度和宽度，为各种屏幕尺寸指定与密度无关的layout资源。</p>
</blockquote>
<h3 id="创建不同的位图"><a href="#创建不同的位图" class="headerlink" title="创建不同的位图"></a>创建不同的位图</h3><p>应该为 4 种普遍密度(分辨率):低，中，高，超高精度，都提供相适配的 bitmap 资源。这能使 app 在所有屏幕分辨率中都能有良好的画质和效果。</p>
<p>要生成这些图像，应该从原始的矢量图像资源着手，然后根据下列尺寸比例，生成各种密度下的图像。</p>
<ul>
<li>xhdpi: 2.0</li>
<li>hdpi: 1.5</li>
<li>mdpi: 1.0 (基准)</li>
<li>ldpi: 0.75</li>
</ul>
<p>这意味着，如果针对 xhdpi 的设备生成了一张 200x200 的图像，那么应该为 hdpi 生成 150x150,为 mdpi 生成 100x100, 和为 ldpi 生成 75x75 的图片资源。</p>
<p>然后，将文件放在相应的 drawable 资源目录中：</p>
<p>MyProject/<br>    res/<br>     drawable-xhdpi/<br>      awesomeimage.png<br>    drawable-hdpi/<br>      awesomeimage.png<br>    drawable-mdpi/<br>      awesomeimage.png<br>    drawable-ldpi/<br>      awesomeimage.png</p>
<p>任何时候引用@ drawable / awesomeimage，系统都会根据屏幕的密度选择适当的 bitmap。</p>
<blockquote>
<p>注意：低密度(ldpi)资源是非必要的，当提供了hdpi的图像，系统会把hdpi的图像按比例缩小一半，去适配ldpi的屏幕。</p>
</blockquote>
<h2 id="支持不同的平台版本"><a href="#支持不同的平台版本" class="headerlink" title="支持不同的平台版本"></a>支持不同的平台版本</h2><p>一般情况下，在更新 app 至最新 Android 版本时，最好先保证新版的 app 可以支持 90% 的设备使用。</p>
<blockquote>
<p>注：为了能在几个 Android 版本中都能提供最好的特性和功能，应该在我们的 app 中使用 Android Support Library，它能使我们的app能在旧平台上使用最近的几个平台的APIs。</p>
</blockquote>
<h3 id="指定最小和目标API级别"><a href="#指定最小和目标API级别" class="headerlink" title="指定最小和目标API级别"></a>指定最小和目标API级别</h3><p>AndroidManifest.xml 文件中描述了 app 的细节及 app 支持哪些 Android 版本。具体来说，&lt; uses-sdk &gt; 元素中的 minSdkVersion 和 targetSdkVersion 属性，标明在设计和测试 app 时，最低兼容 API 的级别和最高适用的 API 级别(这个最高的级别是需要通过测试的)。例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> <span class="attr">...</span> &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:minSdkVersion</span>=<span class="string">"4"</span> <span class="attr">android:targetSdkVersion</span>=<span class="string">"15"</span> /&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>随着新版本 Android 的发布，一些风格和行为可能会改变，为了能使app能利用这些变化，而且能适配不同风格的用户的设备，应该将 targetSdkVersion 的值尽量的设置与最新可用的 Android 版本匹配。</p>
<h3 id="运行时检查系统版本"><a href="#运行时检查系统版本" class="headerlink" title="运行时检查系统版本"></a>运行时检查系统版本</h3><p>Android 在 Build 常量类中提供了对每一个版本的唯一代号，在 app 中使用这些代号可以建立条件，保证依赖于高级别的 API 的代码，只会在这些 API 在当前系统中可用时，才会执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpActionBar</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Make sure we're running on Honeycomb or higher to use ActionBar APIs</span></div><div class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">        ActionBar actionBar = getActionBar();</div><div class="line">        actionBar.setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：当解析 XML 资源时，Android 会忽略当前设备不支持的 XML 属性。所以可以安全地使用较新版本的 XML 属性，而不需要担心旧版本 Android 遇到这些代码时会崩溃。例如如果设置 targetSdkVersion=”11”，app 会在 Android 3.0 或更高时默认包含 ActionBar。然后添加 menu items到 action bar 时，需要在自己的 menu XML 资源中设置 android:showAsAction=”ifRoom”。在跨版本的 XML 文件中这么做是安全的，因为旧版本的 Android 会简单地忽略 showAsAction 属性(就是这样，你并不需要用到 res/menu-v11/ 中单独版本的文件)。</p>
</blockquote>
<h3 id="使用平台样式和主题"><a href="#使用平台样式和主题" class="headerlink" title="使用平台样式和主题"></a>使用平台样式和主题</h3><p>Android 提供了用户体验主题，为 app 提供基础操作系统的外观和体验。这些主题可以在 manifest 文件中被应用于 app 中。通过使用内置的风格和主题，app 自然地随着 Android 新版本的发布，自动适配最新的外观和体验。</p>
<p>使 activity 看起来像对话框：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.Dialog"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>使 activity 有一个透明背景：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.Translucent"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>应用在 /res/values/styles.xml 中定义的自定义主题：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:theme</span>=<span class="string">"@style/CustomTheme"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>使整个app应用一个主题(全部 activities )在元素中添加 android:theme 属性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">"@style/CustomTheme"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><br>ikook<br>2017.03.16</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android 官方 Training 文档学习总结系列&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ikookblog.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://ikookblog.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 官方 Training 文档学习总结系列之「My First App涉及知识总结」</title>
    <link href="http://ikookblog.com/2017/03/13/android_training_study1/"/>
    <id>http://ikookblog.com/2017/03/13/android_training_study1/</id>
    <published>2017-03-12T16:00:00.000Z</published>
    <updated>2017-06-16T07:03:46.739Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Android 官方 Training 文档学习总结系列</p>
</blockquote>
<a id="more"></a>
<p>由于自己学习 Android 到现在，都是通过视频和书籍。感觉到现在还是什么都不会的状态，比如实现一个小功能，也许有思路，但是去实现却实现不出来。回头想想自己都学会了 Android 的哪些知识点，一头雾水，回忆不起什么来，不知道学习了什么。</p>
<p>于是决定系统学习官方 Training 文档，学习不总结是不会提高的。也许之前学的一塌糊涂，甚至导致学过之后都不知道学了什么，可能就是不总结不思考造成的。然后，就有了这个系列的总结。</p>
<p>总结系列第一篇：My First App涉及知识点总结。代码仓库: <a href="https://github.com/china-kook/Android-Official_Training_Study/tree/master/MyFirstApp" target="_blank" rel="external">Training First App</a></p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>Android 应用的图形界面使用 View 对象以及 ViewGroup对象层次结构而构建。View 对象通常为按钮或文本字段之类的 UI 小部件。而 ViewGroup 对象则为不可见的视图容器，它们定义子视图的布局。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2012773-b1a9438498f9b2de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewGroup 对象如何在布局中形成分支并容纳其他 View 对象的图解"></p>
<h2 id="替代布局"><a href="#替代布局" class="headerlink" title="替代布局"></a>替代布局</h2><p>以 XML 格式（而不是运行时代码的方式）声明 UI 布局有若干用处，但其中最重要的用处便是，可以创建不同的布局来适应不同的屏幕尺寸。 例如，可以创建两个版本的布局，并指示系统在“小”屏幕上使用哪个版本，在“大”屏幕上使用哪个版本。</p>
<h2 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h2><p>LinearLayout 是一个视图组(ViewGroup的子类)，它会按照 android:orientation 属性的指定，将子视图设置为垂直或水平方向布局。LinearLayout 的每个子视图都会按照它们各自在 XML 中的出现顺序显示在屏幕上。</p>
<p>如果 LinearLayout 是布局中的根视图，则应将宽度和高度设置为 “match_parent”，从而填满可供应用使用的整个屏幕区域。 该值表示视图应扩大其宽度或高度，以匹配父视图的宽度或高度。</p>
<h2 id="布局相关属性"><a href="#布局相关属性" class="headerlink" title="布局相关属性"></a>布局相关属性</h2><ul>
<li><h4 id="android-id"><a href="#android-id" class="headerlink" title="android:id"></a>android:id</h4><p>这会为视图赋予唯一的标识符，可以使用该标识符从应用代码中引用对象，例如读取和操作对象。<br>从 XML 引用任何资源对象时，都需要使用 @ 符号。 请在该符号后依次输入资源类型、斜杠和资源名称：android:id=”@+id/edit_message(例子)。</p>
<p>只有在第一次定义资源 ID 时，才需要在资源类型之前加一个加号 (+)。 当编译应用时，SDK 工具会使用 ID 名称在项目的 R.java 文件中新建一个引用 EditText(例子) 元素的资源 ID。一旦以此方式声明资源 ID，其他对该 ID 的引用皆无需使用加号。 只有在指定新资源 ID 时才必须使用加号，对于字符串或布局等具体资源则不必如此。</p>
</li>
<li><h4 id="android-layout-width-和-android-layout-height"><a href="#android-layout-width-和-android-layout-height" class="headerlink" title="android:layout_width 和 android:layout_height"></a>android:layout_width 和 android:layout_height</h4><p>“wrap_content” 值并不规定宽度和高度的具体大小，而是指定根据需要缩放视图，使其适合视图的内容。 如果要改用 “match_parent”，则 EditText 元素将填满屏幕，因为它会匹配父 LinearLayout(例子) 的大小。</p>
</li>
<li><h4 id="android-hint"><a href="#android-hint" class="headerlink" title="android:hint"></a>android:hint</h4><p>这是文本字段为空时显示的默认字符串。@string/edit_message(例子) 并非使用硬编码字符串作为其值，而是引用另一个文件中定义的一个字符串资源。 由于它引用的是一个具体资源（而不仅仅是标识符），因此不需要加号。</p>
</li>
<li><h4 id="android-layout-weight"><a href="#android-layout-weight" class="headerlink" title="android:layout_weight"></a>android:layout_weight</h4><p>weight 值是一个数字，用于指定每个视图与其他同级视图在剩余空间中的占比。 这有点像饮料配方中各种成分的比例： “2 份苏打、1 份糖浆”是指饮料中三分之二是苏打。例如，如果将一个视图的 weight 值指定为 2，将另一个视图的 weight 值指定为 1，总和是 3，那么第一个视图将填满剩余空间的 2/3，而第二个视图则填满其余部分。 如果添加了第三个视图，将其 weight 值指定为 1，那么现在第一个视图（weight 值为 2）将获得 1/2 的剩余空间，其余两个视图则各占 1/4。</p>
<p>所有视图的默认 weight 值都为 0，所以如果仅将一个视图的 weight 值指定为大于 0，那么等到其他所有视图都获得所需空间后，该视图便会填满所有剩余空间。</p>
<p>优化: 如需使其一个部件的宽度或者高度占满剩余屏幕空间时，例如在宽度方向占满屏幕剩余空间。设置 android:layout_weight=”1” 属性后，将宽度设置为零 (0dp) 可提高布局性能，这是因为如果将宽度设置为”wrap_content”或其他值，则会要求系统计算宽度，而该计算最终毫无意义，因为 weight 值还需要计算另一个宽度，才能填满剩余空间。</p>
</li>
</ul>
<blockquote>
<p>注：对资源的引用始终都按资源类型（如 id 或 string）确定其作用域，因此使用相同的名称不会引起冲突</p>
</blockquote>
<h2 id="资源对象"><a href="#资源对象" class="headerlink" title="资源对象"></a>资源对象</h2><p>资源对象是一个唯一的整型名称，它与应用资源（如位图、布局文件或字符串）相关联。</p>
<p>每个资源在项目的 R.java 文件中都定义有相应的资源对象。可以使用 R 类中的对象名称来引用资源，例如当需要为 android:hint 属性指定字符串值时，就可以这样做。也可以使用 android:id 属性创建任意与视图相关联的资源 ID，从而可以从其他代码中引用该视图。</p>
<p>SDK 工具会在您每次编译应用时生成 R.java 文件。切勿手动修改该文件。</p>
<h2 id="字符串资源"><a href="#字符串资源" class="headerlink" title="字符串资源"></a>字符串资源</h2><p>对于用户界面中的文本，务必将每个字符串都指定为资源。 字符串资源允许在单一位置管理所有 UI 文本，从而简化文本的查找和更新。 此外，将字符串外部化还可为每个字符串资源提供替代定义，从而将应用本地化为不同的语言。</p>
<h2 id="响应按钮"><a href="#响应按钮" class="headerlink" title="响应按钮"></a>响应按钮</h2><p>可在布局文件的 Button 元素中添加 android:onClick 属性，如 android:onClick=”sendMessage”。每次用户点击按钮时，此属性均会提示系统调用 Activity 中的 sendMessage() 方法。</p>
<p>还需在布局文件对应的 Activity 类中添加与 onClick 属性对应的方法。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**Called when the user clicks the Send button */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    <span class="comment">// Do something in response to button</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要让系统将此方法与为 android:onClick 指定的方法名称匹配，签名必须与所示内容完全相同。具体而言，该方法必须：</p>
<ul>
<li>是公共方法</li>
<li>具有空返回值</li>
<li>以 View 作为唯一参数（这将是之前点击的 View）</li>
</ul>
<h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>Intent 是指在相互独立的组件（如两个 Activity）之间提供运行时绑定功能的对象。Intent 表示一个应用“执行某项操作的 Intent”。 可以将 Intent 用于各种任务。例如：Intent 用于启动另一个 Activity。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Called when the user clicks the Send button */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, DisplayMessageActivity.class);</div><div class="line">    EditText editText = (EditText) findViewById(R.id.edit_message);</div><div class="line">    String message = editText.getText().toString();</div><div class="line">    intent.putExtra(EXTRA_MESSAGE, message);</div><div class="line">    startActivity(intent);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Intent 构造函数采用两个参数：</p>
<ul>
<li>Context 是第一个参数（之所以使用 this ，是因为 Activity 类是 Context 的子类）</li>
<li>应用组件的 Class，系统应将 Intent（在本例中，为应启动的 Activity）传递至该类。</li>
</ul>
<p>putExtra() 方法将 EditText 的值添加到 Intent。Intent 能够以名为 extra 的键值对形式携带数据类型。键是一个公共常量 EXTRA_MESSAGE，因为下一个 Activity 将使用该键来检索文本值。为 Intent extra 定义键时最好使用应用的软件包名称作为前缀。这可以确保在应用与其他应用交互过程中这些键始终保持唯一。</p>
<p>startActivity() 方法将启动 Intent 指定的 DisplayMessageActivity 实例。</p>
<p>编写 DisplayMessageActivity.java 类，用于显示第一个 Activity 传递的消息。代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">   <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">   setContentView(R.layout.activity_display_message);</div><div class="line"></div><div class="line">   Intent intent = getIntent();</div><div class="line">   String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE);</div><div class="line">   TextView textView = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</div><div class="line">   textView.setTextSize(<span class="number">40</span>);</div><div class="line">   textView.setText(message);</div><div class="line"></div><div class="line">   ViewGroup layout = (ViewGroup) findViewById(R.id.activity_display_message);</div><div class="line">   layout.addView(textView);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此处会执行大量操作，因此我们接着解释：</p>
<ul>
<li>调用 getIntent() 采集启动 Activity 的 intent。无论用户如何导航到目的地，每个 Activity 都由一个 Intent 调用。 调用 getStringExtra() 将检索第一个 Activity 中的数据。</li>
<li>可以使用编程方式创建 TextView 并设置其大小和消息。</li>
<li>可将 TextView 添加到 R.id.activity_display_message 标识的布局。可将布局投射到 ViewGroup，因为它是所有布局的超类且包含 addView() 方法。</li>
</ul>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局定义用户界面的视觉结构，如Activity或应用小部件的 UI。可以通过两种方式声明布局：</p>
<ul>
<li>在 XML 中声明 UI 元素。Android 提供了对应于 View 类及其子类的简明 XML 词汇，如用于小部件和布局的词汇；</li>
<li>运行时实例化布局元素。应用可以通过编程创建 View 对象和 ViewGroup 对象（并操纵其属性）。</li>
</ul>
<p>Android 框架可以灵活地使用以下一种或两种方法来声明和管理应用的 UI。例如，可以在 XML 中声明应用的默认布局，包括将出现在布局中的屏幕元素及其属性。然后，可以在应用中添加可在运行时修改屏幕对象（包括那些已在 XML 中声明的对象）状态的代码。</p>
<p>在 XML 中声明 UI 的优点在于，可以更好地将应用的外观与控制应用行为的代码隔离。UI 描述位于应用代码外部，这意味着在修改或调整描述时无需修改源代码并重新编译。例如，可以创建适用于不同屏幕方向、不同设备屏幕尺寸和不同语言的 XML 布局。此外，在 XML 中声明布局还能更轻松地显示 UI 的结构，从而简化问题调试过程。</p>
<p>一般而言，用于声明 UI 元素的 XML 词汇严格遵循类和方法的结构和命名方式，其中元素名称对应于类名称，属性名称对应于方法。实际上，这种对应关系往往非常直接，可以猜到对应于类方法的 XML 属性，或对应于给定 XML 元素的类。但请注意，并非所有词汇都完全相同。在某些情况下，在命名上略有差异。例如，EditText 元素具有的 text 属性对应的类方法是 EditText.setText()。</p>
<h3 id="编写-XML"><a href="#编写-XML" class="headerlink" title="编写 XML"></a>编写 XML</h3><p>可以利用 Android 的 XML 词汇，按照在 HTML 中创建包含一系列嵌套元素的网页的相同方式快速设计 UI 布局及其包含的屏幕元素。</p>
<p>每个布局文件都必须只包含一个根元素，并且该元素必须是视图对象或 ViewGroup 对象。定义根元素之后，即可再以子元素的形式添加其他布局对象或小部件，从而逐步构建定义布局的视图层次结构。例如，以下这个 XML 布局使用垂直 LinearLayout 来储存一个 TextView 和一个 Button：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">              <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@+id/text"</span></span></div><div class="line">              <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">              <span class="attr">android:text</span>=<span class="string">"Hello, I am a TextView"</span> /&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/button"</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:text</span>=<span class="string">"Hello, I am a Button"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在 XML 中声明布局后，请在 Android 项目 res/layout/ 目录中以 .xml 扩展名保存文件，以便其能够正确编译。</p>
<h3 id="加载-XML-资源"><a href="#加载-XML-资源" class="headerlink" title="加载 XML 资源"></a>加载 XML 资源</h3><p>当编译应用时，每个 XML 布局文件都会编译到一个 View 资源中。 应该在 Activity.onCreate() 回调实现中从应用代码加载布局资源。通过调用 setContentView()，以 R.layout.layout_file_name 形式向其传递对布局资源的引用来执行此操作。例如，如果 XML 布局保存为 main_layout.xml，则需要像下面这样为 Activity 加载该布局：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.main_layout);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动 Activity 时，Android 框架会调用 Activity 中的 onCreate() 回调方法</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>每个视图对象和 ViewGroup 对象都支持各自的各类 XML 属性。某些属性是视图对象的专用属性（例如，TextView 支持 textSize 属性），但这些属性也会被任何可以扩展此类的视图对象继承。某些属性通用于所有 View 对象，因为它们继承自根 View 类（如 id 属性）。此外，其他属性被视为“布局参数”，即描述 View 对象特定布局方向的属性，如该对象的父 ViewGroup 对象所定义的属性。</p>
<ul>
<li><h4 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h4><p>任何视图对象都可能具有关联的整型 ID，此 ID 用于在结构树中对 View 对象进行唯一标识。编译应用后，此 ID 将作为整型数引用，但在布局 XML 文件中，通常会在 id 属性中为该 ID 赋予字符串值。这是所有 View 对象共用的 XML 属性（由 View 类定义），经常会用到它。XML 标记内部的 ID 语法是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:id="@+id/my_button"</div></pre></td></tr></table></figure>
<p>字符串开头处的 @ 符号指示 XML 解析程序应该解析并展开 ID 字符串的其余部分，并将其标识为 ID 资源。加号 (+) 表示这是一个新的资源名称，必须创建该名称并将其添加到我们的资源（在 R.java 文件中）内。Android 框架还提供了许多其他 ID 资源。 引用 Android 资源 ID 时，不需要加号，但必须添加 android 软件包命名空间，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:id="@android:id/empty"</div></pre></td></tr></table></figure>
<p>添加 android 软件包命名空间之后，现在，将从 android.R 资源类而非本地资源类引用 ID。</p>
<p>要想创建视图并从应用中引用它们，常见的模式是：</p>
<ul>
<li><p>在布局文件中定义一个视图/小部件，并为其分配一个唯一的 ID：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/my_button"</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"@string/my_button_text"</span>/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>然后创建一个 view 对象实例，并从布局中捕获它（通常使用 onCreate() 方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Button myButton = (Button)findViewById(R.id.my_button);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>创建 RelativeLayout 时，为 view 对象定义 ID 非常重要。在相对布局中，同级视图可以定义其相对于其他同级视图的布局，同级视图通过唯一的 ID 进行引用。</p>
<p>ID 不需要在整个结构树中具有唯一性，但在要搜索的结构树部分应具有唯一性（要搜索的部分往往是整个结构树，因此最好尽可能具有全局唯一性）。</p>
</li>
<li><h4 id="布局参数"><a href="#布局参数" class="headerlink" title="布局参数"></a>布局参数</h4><p>名为 layout_something 的 XML 布局属性可为视图定义与其所在的 ViewGroup 相适的布局参数。</p>
<p>每个 ViewGroup 类都会实现一个扩展 ViewGroup.LayoutParams 的嵌套类。此子类包含的属性类型会根据需要为视图组的每个子视图定义尺寸和位置。 正如在下图中所见，父视图组为每个子视图（包括子视图组）定义布局参数。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2012773-665b837668ca7fb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以可视化方式表示的视图层次结构，其中包含与每个视图关联的布局参数"></p>
<p>请注意，每个 LayoutParams 子类都有自己的值设置语法。 每个子元素都必须定义适合其父元素的 LayoutParams，但父元素也可为其子元素定义不同的 LayoutParams。</p>
<p>所有视图组都包括宽度和高度（layout_width 和 layout_height），并且每个视图都必须定义它们。许多 LayoutParams 还包括可选的外边距和边框。</p>
<p>可以指定具有确切尺寸的宽度和高度，但多半不想经常这样做。 在更多的情况下，会使用以下常量之一来设置宽度或高度：</p>
<ul>
<li>wrap_content 指示您的视图将其大小调整为内容所需的尺寸。</li>
<li>match_parent 指示您的视图尽可能采用其父视图组所允许的最大尺寸。<br></li>
</ul>
<p>一般而言，建议不要使用绝对单位（如像素）来指定布局宽度和高度， 而是使用相对测量单位，如密度无关像素单位 (dp)、wrap_content 或 match_parent，这种方法更好，因为它有助于确保应用在各类尺寸的设备屏幕上正确显示。</p>
</li>
</ul>
<h3 id="布局位置"><a href="#布局位置" class="headerlink" title="布局位置"></a>布局位置</h3><p>视图的几何形状就是矩形的几何形状。视图具有一个位置（以一对水平向左和垂直向上坐标表示）和两个尺寸（以宽度和高度表示）。 位置和尺寸的单位是像素。</p>
<p> 可以通过调用方法 getLeft() 和方法 getTop() 来检索视图的位置。前者会返回表示视图的矩形的水平向左（或称 X 轴） 坐标。后者会返回表示视图的矩形的垂直向上（或称 Y 轴）坐标。 这些方法都会返回视图相对于其父项的位置。 例如，如果 getLeft() 返回 20，则意味着视图位于其直接父项左边缘向右 20 个像素处。</p>
<p> 此外，系统还提供了几种便捷方法来避免不必要的计算，即 getRight() 和 getBottom()。 这些方法会返回表示视图的矩形的右边缘和下边缘的坐标。 例如，调用 getRight() 类似于进行以下计算：getLeft() + getWidth()。</p>
<h3 id="尺寸、内边距和外边距"><a href="#尺寸、内边距和外边距" class="headerlink" title="尺寸、内边距和外边距"></a>尺寸、内边距和外边距</h3><p>视图的尺寸通过宽度和高度表示。视图实际上具有两对宽度和高度值。</p>
<p> 第一对称为测量宽度和测量高度。 这些尺寸定义视图想要在其父项内具有的大小。 这些测量尺寸可以通过调用 getMeasuredWidth() 和 getMeasuredHeight() 来获得。</p>
<p> 第二对简称为宽度和高度，有时称为绘制宽度和绘制高度。 这些尺寸定义视图在绘制时和布局后在屏幕上的实际尺寸。 这些值可以（但不必）与测量宽度和测量高度不同。 宽度和高度可以通过调用 getWidth() 和 getHeight() 来获得。</p>
<p> 要想测量其尺寸，视图需要将其内边距考虑在内。内边距以视图左侧、顶部、右侧和底部各部分的像素数表示。 内边距可用于以特定数量的像素弥补视图的内容。 例如，左侧内边距为 2，会将视图的内容从左边缘向右推 2 个像素。 可以使用 setPadding(int, int, int, int) 方法设置内边距，并通过调用 getPaddingLeft()、getPaddingTop()、getPaddingRight() 和 getPaddingBottom() 进行查询。</p>
<p> 尽管视图可以定义内边距，但它并不支持外边距。 不过，视图组可以提供此类支持。</p>
<h3 id="常见布局"><a href="#常见布局" class="headerlink" title="常见布局"></a>常见布局</h3><p>ViewGroup 类的每个子类都提供了一种独特的方式来显示在其中嵌套的视图。以下是 Android 平台中内置的一些较为常见的布局类型。</p>
<blockquote>
<p>注：尽管可以通过将一个或多个布局嵌套在另一个布局内来实现您的 UI 设计，但应该使您的布局层次结构尽可能简略。布局的嵌套布局越少，绘制速度越快（扁平的视图层次结构优于深层的视图层次结构）。</p>
</blockquote>
<p> <strong>线性布局：</strong> 一种使用单个水平行或垂直行来组织子项的布局。它会在窗口长度超出屏幕长度时创建一个滚动条。</p>
<p>   <img src="http://upload-images.jianshu.io/upload_images/2012773-aca120b19beb318d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> <strong>相对布局：</strong> 能够指定子对象彼此之间的相对位置（子对象 A 在子对象 B 左侧）或子对象与父对象的相对位置（与父对象顶部对齐）。</p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/2012773-fef7943700710fda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> <strong>网页视图：</strong> 显示网页。</p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/2012773-fb76e8f7ba6eee92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="使用适配器构建布局"><a href="#使用适配器构建布局" class="headerlink" title="使用适配器构建布局"></a>使用适配器构建布局</h3><p>如果布局的内容是属于动态或未预先确定的内容，您可以使用这样一种布局：在运行时通过子类 AdapterView 用视图填充布局。 AdapterView 类的子类使用 Adapter 将数据与其布局绑定。Adapter 充当数据源与 AdapterView 布局之间的中间人—Adapter（从数组或数据库查询等来源）检索数据，并将每个条目转换为可以添加到 AdapterView 布局中的视图。</p>
<p> 适配器支持的常见布局包括：</p>
<p> <strong>列表视图：</strong> 显示滚动的单列列表。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/2012773-7aa83a3ea429eea8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> <strong>网格视图：</strong> 显示滚动的行列网格。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/2012773-f1643ed1a47e1026.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li><h4 id="使用数据填充适配器视图"><a href="#使用数据填充适配器视图" class="headerlink" title="使用数据填充适配器视图"></a>使用数据填充适配器视图</h4><p>可以通过将 AdapterView 实例与 Adapter 绑定来填充 AdapterView（如 ListView 或 GridView），此操作会从外部来源检索数据，并创建表示每个数据条目的 View。</p>
<p>Android 提供了几个 Adapter 子类，用于检索不同种类的数据和构建 AdapterView 的视图。 两种最常见的适配器是：</p>
<ul>
<li><h5 id="ArrayAdpater"><a href="#ArrayAdpater" class="headerlink" title="ArrayAdpater:"></a>ArrayAdpater:</h5><p>请在数据源为数组时使用此适配器。默认情况下，ArrayAdapter 会通过在每个项目上调用 toString() 并将内容放入 TextView 来为每个数组项创建视图。</p>
<p>例如，如果具有想要在 ListView 中显示的字符串数组，请使用构造函数初始化一个新的 ArrayAdapter，为每个字符串和字符串数组指定布局：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>,</div><div class="line">android.R.layout.simple_list_item_1, myStringArray);</div></pre></td></tr></table></figure>
<p>此构造函数的参数是：</p>
<ul>
<li>应用 Context</li>
<li>包含数组中每个字符串的 TextView 的布局</li>
<li>字符串数组</li>
</ul>
<p>然后，只需在 ListView 上调用 setAdapter()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ListView listView = (ListView) findViewById(R.id.listview);</div><div class="line">listView.setAdapter(adapter);</div></pre></td></tr></table></figure>
<p>要想自定义每个项的外观，您可以重写数组中各个对象的 toString() 方法。或者，要想为 TextView 之外的每个项创建视图（例如，如果想为每个数组项创建一个 ImageView），请扩展 ArrayAdapter 类并重写 getView() 以返回想要为每个项获取的视图类型。</p>
</li>
<li><h5 id="SimpleCursorAdapter"><a href="#SimpleCursorAdapter" class="headerlink" title="SimpleCursorAdapter:"></a>SimpleCursorAdapter:</h5><p>请在数据来自 Cursor 时使用此适配器。使用 SimpleCursorAdapter 时，必须指定要为 Cursor 中的每个行使用的布局，以及应该在哪些布局视图中插入 Cursor 中的哪些列。 例如，如果想创建人员姓名和电话号码列表，则可以执行一个返回 Cursor（包含对应每个人的行，以及对应姓名和号码的列）的查询。 然后，可以创建一个字符串数组，指定想要在每个结果的布局中包含 Cursor 中的哪些列，并创建一个整型数组，指定应该将每个列放入的对应视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String[] fromColumns = &#123;ContactsContract.Data.DISPLAY_NAME,</div><div class="line">                  ContactsContract.CommonDataKinds.Phone.NUMBER&#125;;</div><div class="line"><span class="keyword">int</span>[] toViews = &#123;R.id.display_name, R.id.phone_number&#125;;</div></pre></td></tr></table></figure>
<p>当实例化 SimpleCursorAdapter 时，请传递要用于每个结果的布局、包含结果的 Cursor 以及以下两个数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SimpleCursorAdapter adapter = <span class="keyword">new</span> SimpleCursorAdapter(<span class="keyword">this</span>,</div><div class="line">         R.layout.person_name_and_number, cursor, fromColumns, toViews, <span class="number">0</span>);</div><div class="line">ListView listView = getListView();</div><div class="line">listView.setAdapter(adapter);</div></pre></td></tr></table></figure>
<p>然后，SimpleCursorAdapter 会使用提供的布局，将每个 fromColumns 项插入对应的 toViews 视图，为 Cursor 中的每个行创建一个视图。</p>
</li>
</ul>
<p>如果在应用的生命周期中更改了适配器读取的底层数据，则应调用 notifyDataSetChanged()。此操作会通知附加的视图，数据发生了变化，它应该自行刷新。</p>
</li>
<li><h4 id="处理点击事件"><a href="#处理点击事件" class="headerlink" title="处理点击事件"></a>处理点击事件</h4><p>可以通过实现 AdapterView.OnItemClickListener 界面来响应 AdapterView 中每一项上的点击事件。 例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个匿名类作为消息处理对象。</span></div><div class="line"><span class="keyword">private</span> OnItemClickListener mMessageClickedHandler = <span class="keyword">new</span> OnItemClickListener() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView parent, View v, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">        <span class="comment">// Do something in response to the click</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">listView.setOnItemClickListener(mMessageClickedHandler);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><br>ikook<br>2017.03.13</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android 官方 Training 文档学习总结系列&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ikookblog.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://ikookblog.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>java 实现排序算法之「冒泡排序」</title>
    <link href="http://ikookblog.com/2017/03/09/java_sort_algorithm_series1/"/>
    <id>http://ikookblog.com/2017/03/09/java_sort_algorithm_series1/</id>
    <published>2017-03-08T16:00:00.000Z</published>
    <updated>2017-06-03T17:41:25.913Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>java 实现排序算法系列</p>
</blockquote>
<a id="more"></a>
<p>从今天开始我准备写一系列有关于排序算法的文章，当然不止排序算法，以后还会写其他的算法。自己算法方面薄弱，大一上数据结构课的时候也没有好好听课，更别说学了。所以从这篇文章开始，我会巩固一下算法，并写一系列的算法文章，写文章的好处在于把所学知识梳理成章，并且希望可以帮助其他同学。</p>
<p>由于自己水平有限，开学后各种事情也比较多，文章可能会有纰漏，望各位批评指正。</p>
<p>同时，在各类的排序算法中，我们应把注意力放在算法本身，为简单起见，示例代码均使用 int 数据类型，且均为升序排列。</p>
<h2 id="算法简述"><a href="#算法简述" class="headerlink" title="算法简述"></a>算法简述</h2><p>算法，何为算法？</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>算法(Algorithm)是为了解决某类问题而规定的一个有限长的操作序列。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>输入：一个算法必须有零个或以上的输入量。</li>
<li>输出：一个算法应有一个或以上的输出量，输出量是算法计算的结果。</li>
<li>有限性：一个算法必须总是在执行有限步后结束，且每一步都必须在有限时间内完成。</li>
<li>确定性： 算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望，通常要求实际运行结果是确定的。</li>
<li>可行性：即算法能够实现，算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序(Bubble sort)是一种最简单的交换排序算法。大概是所有程序员都会用的算法吧。</p>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>假如有 n 个元素要进行排序。</p>
<h4 id="n-1"><a href="#n-1" class="headerlink" title="n = 1:"></a>n = 1:</h4><p>无需排序。</p>
<h4 id="n-gt-1"><a href="#n-gt-1" class="headerlink" title="n &gt; 1:"></a>n &gt; 1:</h4><ul>
<li><h5 id="第一轮排序"><a href="#第一轮排序" class="headerlink" title="第一轮排序"></a>第一轮排序</h5><p>比较相邻两个元素，如果第一个比第二个大，则交换两个元素的值。<br><br>进行下两个元素的比较，即比较第二个和第三个元素，如前者大于后者，则交换。<br><br>再进行下两个元素的比较。直到第 n-1 个元素和第 n 元素进行比较，如前者大于后者，则交换。<br><br>可以肯定，最后一个元素 n，肯定是 n 个元素中最大的元素。</p>
</li>
<li><h5 id="第二轮排序"><a href="#第二轮排序" class="headerlink" title="第二轮排序"></a>第二轮排序</h5><p>重复执行第一轮执行的动作，直到第 n-2 个元素和第 n-1 个元素进行比较。如前者大于后者，则交换。<br><br>由于第一轮排序已经将最大元素放置到第 n 个位置，所以本次排序无考虑第 n 个元素。即第 n 个元素不参加本次排序。<br><br>…..<br><br>示例图片:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2012773-c645e3f59131b465.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><h5 id="重复执行"><a href="#重复执行" class="headerlink" title="重复执行"></a>重复执行</h5><p>直到只剩一个元素，那么这个元素一定是最小元素，排序结束。显然，进行了 n-1 次排序。</p>
</li>
</ul>
<p>上述过程，每次排序(即每轮排序)都会有一个元素从某个位置慢慢“浮动”到最终所属的位置,就像气泡总会浮动到水的最顶端。在冒泡排序中，每一轮排序都会有一个元素(气泡)替换到本次排序的最后一个位置(水的最顶端)，注意，是本次排序的最后一个位置(第一轮，则为 n；第二轮，则为 n-1；第三轮，则为 n-2 ~~~ )。</p>
<p>因为，排序的过程像是冒泡一样，则称为“冒泡排序”。如下为冒泡排序示意图(来自维基百科)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2012773-ce2db11388ddf4d1.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>设要给数组 arr[] 排序，它有 n 个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void bubbleSort(int[] arr) &#123;</div><div class="line">    int temp = 0;</div><div class="line">    for (int i = arr.length - 1; i &gt; 0; --i) &#123; // 每次需要排序的长度</div><div class="line">        for (int j = 0; j &lt; i; ++j) &#123; // 从第一个元素到第i个元素</div><div class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</div><div class="line">                temp = arr[j];</div><div class="line">                arr[j] = arr[j + 1];</div><div class="line">                arr[j + 1] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>假如有一组数据为：1,2,3,4,5,6,7,8,9,0。 如果用上面的方法实现排序会有什么情况，当然，实现排序肯定没有问题。但是，这组数据的前面一大部分已经是有序的了，如果还是用上面的代码会使效率降低很多(数据比较大的情况下)。所以，将代码进行优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static void bubbleSort(int[] arr) &#123;</div><div class="line">    int temp = 0;</div><div class="line">    boolean swap;</div><div class="line">    for (int i = arr.length - 1; i &gt; 0; --i) &#123; // 每次需要排序的长度</div><div class="line">        swap=false;</div><div class="line">        for (int j = 0; j &lt; i; ++j) &#123; // 从第一个元素到第i个元素</div><div class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</div><div class="line">                temp = arr[j];</div><div class="line">                arr[j] = arr[j + 1];</div><div class="line">                arr[j + 1] = temp;</div><div class="line">                swap=true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (swap==false)&#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在实际使用过程中，由于在大量数据的情况下几乎不使用冒泡排序，而使用小数据的时候增加的布尔变量反而会造成额外的开销。通常，冒泡排序就使用前一种就行了。</p>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul>
<li><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4>当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是n-1次的比较，没有数据交换，时间复杂度为O(n)。当最坏的情况，即待排序表是逆序的况，此时需要比较<img src="http://upload-images.jianshu.io/upload_images/2012773-7f485f78193e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""> 次，并作等数量级的记录移动。因此，总的时间复杂度为O(n^2)。</li>
<li><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4>由以上算法步骤分析，可轻易得知冒泡排序的空间复杂度为 O(n), 需要辅助空间 O(1)</li>
</ul>
<h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><p>容易看出，在相邻元素相等时，我们并不需要交换它们的位置，所以，冒泡排序是稳定排序。</p>
<h3 id="算法适用场景"><a href="#算法适用场景" class="headerlink" title="算法适用场景"></a>算法适用场景</h3><p>在算法优化中提到过，实际使用过程中，在大量数据的情况下几乎不适用冒泡排序。冒泡排序思路简单，代码简单，特别适合小数据的排序。但是，由于算法复杂度较高，在数据量大的时候不适合使用。</p>
<p><br>ikook<br>2017.03.09</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;java 实现排序算法系列&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="论算法" scheme="http://ikookblog.com/categories/%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机技术" scheme="http://ikookblog.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://ikookblog.com/tags/java/"/>
    
      <category term="排序算法" scheme="http://ikookblog.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ikookblog.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>关于怎样自学 java 和 Android 的回答</title>
    <link href="http://ikookblog.com/2017/03/08/introduction_learn_method/"/>
    <id>http://ikookblog.com/2017/03/08/introduction_learn_method/</id>
    <published>2017-03-07T16:00:00.000Z</published>
    <updated>2017-06-03T17:34:27.602Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在小密圈里发表了自己的博客地址。评论中无意帮助一位同学解答了他疑惑。然后发现同学们还是有不少初学者的。 <a id="more"></a> 所以把问题和回答贴着这里，希望可以帮助更多的同学少走些弯路，回答中主要针对自学者。</p>
<p>需要说明第一点的是，以下回答仅仅是个人学习的经历和总结，不一定适合所有人。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对于还是小白的我，也想自学安卓和java，请学长赐教对于初学者还从哪下手？看那些书？或者去哪个网站？谢谢！</p>
<h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>找一套入门的 java 视频和书籍，了解和掌握 java SE的知识后就可以开始学习 Android 了。java 入门书籍推荐《head first java》，看完这本之后推荐 《java 核心技术》(分为上下卷)，再之后强烈推荐 《java 编程思想》。</p>
<p>入门 java 建议时间在3个月左右，不要着急，多敲代码，我就是吃了入门 java 的时候太着急的亏，我当时就是很随意的看了一套入门的视频就去学 Android 了，导致 java 基础太差，现在又在补基础，所以一定要把 java 基础学好，以看书看文档为主，以视频为辅。</p>
<h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>学 Android ，我当时是直接找了本书看，我看到是郭霖的《第一行代码》，现在有《第二行代码》(第一行代码-第二版)了。在看书过程中不明白不理解的地方找视频看，视频方面我主要看慕课网和极客学院的。</p>
<p>看完《第一行代码》基本可以对 Android 有个大体的了解吧，可能还不能算真正入门。我看完第一行代码之后是做了个小的工具类 app ，也不是我一个人完成的，因为是参加比赛做的。之后我又看了《Android 编程权威指南》，现在也有第二版了。我一开始看的第一版，课本代码是用 eclipse 写的，我看的时候是使用 Android Studio 码的，没多大差别，有个别地方需要变通一下，不过强烈建议使用 AS。3月3号，就前几天，Google 发布了AS 2.3.0 正式版。知道有第二版之后又买了本第二版看了一遍，代码敲了一遍。然后差不多就看到现在的我了。</p>
<p>我学的时候也不是只是一味的学某一门技术，在学习 java 和 Android 期间我也了解和学习过其他东西，比如 git、GitHub、单元测试一类的。也参加过几个比赛。虽然比赛都没取得什么好的成绩，但也还是有好处的。</p>
<p>当然，这也导致我现在对 Android 还只是有个大体的了解，我写东西还是无从下手，还是处在入门阶段，同时现在我还仍在继续努力学习。不过现在我已经不再看视频了，而是看书、文档、博客等，文档也会看官方的。官网现在有中文的，不过只是部分，所以还是要看英文版。我自己在看的时候就是边看边用翻译软件翻译，慢慢来，我相信会改变的。</p>
<h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><p>关于学习资源可以见我 GitHub 的一个仓库，里面收集了我知道的所有资料，当然里面也有我还没有学习的。<br>地址：<a href="https://github.com/china-kook/Skill-learn-collect" target="_blank" rel="external">Skill-learn-collect</a></p>
<p>说到自学 Android，不得不提 stormzhang 的那篇<a href="http://stormzhang.com/android/2016/01/21/learn-android-byself/" target="_blank" rel="external">《如何自学Android 编程》</a>以及<a href="http://stormzhang.com/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="external">《Android 学习之路》</a>。</p>
<p><br>ikook<br>2017.03.08</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天在小密圈里发表了自己的博客地址。评论中无意帮助一位同学解答了他疑惑。然后发现同学们还是有不少初学者的。
    
    </summary>
    
      <category term="随笔集" scheme="http://ikookblog.com/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
      <category term="随笔" scheme="http://ikookblog.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Android" scheme="http://ikookblog.com/tags/Android/"/>
    
      <category term="java" scheme="http://ikookblog.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>「RESTful 架构」总结</title>
    <link href="http://ikookblog.com/2017/03/05/RESTful_summary/"/>
    <id>http://ikookblog.com/2017/03/05/RESTful_summary/</id>
    <published>2017-03-04T16:00:00.000Z</published>
    <updated>2017-06-03T17:19:28.110Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>目前最流行的一种互联网软件架构。结构清晰、符合标准、易于理解、扩展方便。</p>
</blockquote>
<a id="more"></a>
<h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>REST，是<a href="https://en.wikipedia.org/wiki/Roy_Fielding" target="_blank" rel="external">Roy Thomas Fielding</a>在他博士论文中提出的。</p>
<h3 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h3><p>REST，即Representational State Transfer的缩写。可翻译为”表现层状态转化”。</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>名称”表现层状态转化”中，省略了主语。”表现层”是指”资源”的”表现层”。</p>
<p>所谓的”资源”，就是网络上的一个实体，或者说网络上的一个具体信息。可以是一段文本、一张图片、一首歌曲、一种服务等。总之是一个具体的存在。可以用一个URI(统一资源定位符)指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以。</p>
<p>“上网”，就是与互联网上一系列的”资源互动”，调用它的URI。</p>
<h3 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h3><p>“资源”是一种信息实体，可以有多种外在的表现形式。把”资源”具体呈现出来的形式，叫做它的”表现层”。</p>
<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴”，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>
<h3 id="状态转化"><a href="#状态转化" class="headerlink" title="状态转化"></a>状态转化</h3><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源</strong></p>
<h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>综合上面的解释，我们总结一下什么是RESTful架构：</p>
<ul>
<li>每一个URI代表一种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现层；</li>
<li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li>
</ul>
<h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><p>RESTful架构有一些典型的设计误区。</p>
<p><strong>最常见的一种设计错误，就是URI包含动词。</strong> 因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p>
<p><br>ikook<br>2017.03.05</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;目前最流行的一种互联网软件架构。结构清晰、符合标准、易于理解、扩展方便。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="网络屋" scheme="http://ikookblog.com/categories/%E7%BD%91%E7%BB%9C%E5%B1%8B/"/>
    
    
      <category term="RESTful" scheme="http://ikookblog.com/tags/RESTful/"/>
    
      <category term="网络" scheme="http://ikookblog.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CPU、内存、硬盘、指令以及它们之间的关系</title>
    <link href="http://ikookblog.com/2017/02/25/cpu_ram_detailed/"/>
    <id>http://ikookblog.com/2017/02/25/cpu_ram_detailed/</id>
    <published>2017-02-24T16:00:00.000Z</published>
    <updated>2017-06-03T17:14:52.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本人对于CPU、内存、硬盘以及指令等一系列计算机核心组件理解甚浅。<a id="more"></a> 并且对其也不是很来感，不过身为一名软件专业学生以及未来的程序猿，还是硬着头皮研究研究。以下是对其学习的一个总结吧算是，有什么不正确的地方还请指出，不喜勿喷。</p>
</blockquote>
<p>相信大家都知道计算机是由控制器、运算器、存储器、输入设备、输出设备五大部分组成。控制器 + 运算器组成了CPU，存储器即内存，当然硬盘也属于存储器，不过硬盘和内存存储形式有所不同，详细见下。</p>
<p>说明：点击以下标题查看维基百科详解</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8" target="_blank" rel="external">CPU</a></h3><p>CPU即中央处理器(Central Processing Unit)。</p>
<p>它是计算机的主要设备之一，可以是说是计算机最重要的组成部分。常听到有人说CPU是”计算机的大脑”，但我觉得这句话是不完全正确的。为什么这么说呢，CPU没有存储能力，只有为数不多的寄存器能临时存储一点东西，人可是有存储能力的，像最强大脑上有些人更拥有超强的记忆力。所以在存储能力这方面来讲，我觉得把CPU比作”大脑“的说法不太正确。就像刘欣前辈在其公号上讲解<a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513017&amp;idx=1&amp;sn=5550ee714abd36d0b580713f673e670b&amp;scene=21#wechat_redirect" target="_blank" rel="external">CPU</a>说的那样，”上帝为你关闭了一扇门，就一定会为你打开一扇窗”，CPU虽然“脑容量”很小，但是它拥有超强的运算力。拿内存和硬盘来说，CPU比内存要快100倍，比硬盘快1000多万倍。这种运算速度可是人望尘莫及的了。所以在运算力这方面讲，又可以把CPU比作“超强的大脑”。</p>
<p>它负责处理、运算计算机内部的所有数据。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a><a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8" target="_blank" rel="external">内存</a></h3><p>内存即RAM，随机存取存储器(Random Access Memory)。</p>
<p>内存是计算机的主存，主存(Main memory)即电脑内部最重要的存储器，是与CPU直接交换数据的内部存储器。它用来加载各种各样的数据和程序以供CPU直接运行与运用。它是可以随时读写的，并且速度也很快，仅仅比CPU慢100倍。它通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。通俗点说，内存就是用来临时存储数据，用来给CPU提供CPU要处理的东西。但是内存不会长期保存数据，只是临时存储，程序和数据处理完后就释放空间。</p>
<h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a><a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98" target="_blank" rel="external">硬盘</a></h3><p>硬盘即HDD(Hard Disk Drive)。</p>
<p>硬盘是计算机上使用坚硬的旋转盘片为基础的非挥发性存储设备，它在平整的磁性表面存储和检索数字数据，信息通过离磁性表面很近的磁头，由电磁流来改变极性方式被电磁流写到磁盘上，信息可以通过相反的方式读取，例如读头经过纪录数据的上方时磁场导致线圈中电气信号的改变。硬盘的读写是采用随机存取的方式，因此可以以任意顺序读取硬盘中的数据。以上来自维基百科。各种专业名词，我相信你已经看厌倦了快。说白了，硬盘就是存东西的，长期存，也就是具有记忆力。不像CPU和内存，“一觉醒来就忘了以前的事情”，所有的数据全都清空。硬盘会长期存储数据，只要是不人为删除，不出现硬件故障，东西就不会丢。</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a><a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4" target="_blank" rel="external">指令</a></h3><p>指令，怎么说呢，指令就是任何可执行程序的元素的表述。指令一般会包含一个操作码和零到多个操作数。操作码指定了要进行什么样的操作。操作数可能指定了参与操作的寄存器、内存地址或立即数，它可能还会包含寻址方式，寻址方式确定操作数的含义。说白了，指令就是CPU的命令，CPU通过寄存器中的指令来进行数据的操作。</p>
<p>另外，指令一般有四种：加载、存储、操作和跳转。</p>
<h3 id="它们之间的关系"><a href="#它们之间的关系" class="headerlink" title="它们之间的关系"></a>它们之间的关系</h3><p>CPU从内存或缓存中取出指令，放入指令寄存器，并对指令译码进行分解，进而对数据进行处理。这么说吧，计算机中所有的程序运行都是在内存中进行的，因此内存对计算机性能的影响非常大。数据由传输速度较慢的硬盘通过内存传送到CPU进行处理。不过内存是带电存储的(断电数据就会消失)，而且容量十分有限，所以要长时间储存程序或数据就需要使用硬盘。</p>
<p>所以计算机处理数据大概就通过以上几个部分：数据(硬盘)——&gt;内存——&gt;CPU——&gt;CPU通过指令处理数据</p>
<p><br>ikook<br>2017.02.25</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本人对于CPU、内存、硬盘以及指令等一系列计算机核心组件理解甚浅。
    
    </summary>
    
      <category term="技术栈" scheme="http://ikookblog.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="计算机技术" scheme="http://ikookblog.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Skill-learn-collect</title>
    <link href="http://ikookblog.com/2017/02/21/skill_learn_collect/"/>
    <id>http://ikookblog.com/2017/02/21/skill_learn_collect/</id>
    <published>2017-02-20T16:00:00.000Z</published>
    <updated>2017-06-03T17:10:46.014Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>收集在学习和提高技术过程中遇到的比较有价值的网站、文档、Blog 等，方便自己查阅。</p>
</blockquote>
<a id="more"></a>
<p>由于自己在学习过程中积累了一些博客、文档等学习资料，以前一直在自己电脑本地拉个快捷方式存在本地，以便日后翻阅复习。由于偶然，自己在整理资料过程中，看到有前辈在 GitHub 上做过资料的整理，所以我自己也产生了这个想法。然后就有了这个 GitHub 仓库。希望可以给大家带来方便，并且希望能有帮助到大家的资料，这个仓库以后会一直维护下去，并会经常更新。当然希望大家可以参与进来一起维护，欢迎 pull ，欢迎 pull  request 。同时，希望大家多多 star ，哈哈。</p>
<p>问题：不知道是什么原因，在简书上点击Tag会跳转到新页面，不会跳转到当前页面指定的Tag。不过在我的<a href="http://ikookblog.com/2017/02/21/Skill-learn-collect/">个人博客</a>和 GitHub 上没有任何问题。给大家带来不便，还请谅解。不会既然是 GitHub 仓库，当然是在 GitHub最好，所以建议大家转步 GitHub。</p>
<p>GitHub 仓库地址：<a href="https://github.com/china-kook/Skill-learn-collect" target="_blank" rel="external">Skill-learn-collect</a><br>欢迎提 issues，欢迎 Star。</p>
<h2 id="tags">Tags</h2>

<p><a href="#android">Android</a>      <a href="#java">Java</a>       <a href="#kotlin">Kotlin</a>       <a href="#shejimoshi">设计模式</a>        <a href="#android-studio">Android/Android Studio 相关</a>           <a href="#sql">数据库</a>             <a href="#git">Git</a>          <a href="#github">GitHub</a>               <a href="#view-ui">Android/View&amp;UI 相关</a>            <a href="#mvp">MVP</a>               <a href="#kaiyuanxiangmu">开源项目</a>           <a href="#linux">Linux</a>            <a href="#xiaolv">效率工具</a>                 <a href="#kuangjia">框架</a>                <a href="#material-design">Android/Material Design 相关</a>             <a href="#mantan">技术漫谈</a>                <a href="#appium">Appium</a>               <a href="#qita">其他收集类GitHub地址</a>  </p>
<p></p><h3 id="android">Android</h3><a href="#tags">点击此处回到Tags</a><p></p>
<ul>
<li><h4 id="Blogs"><a href="#Blogs" class="headerlink" title="Blogs"></a>Blogs</h4><p></p><h5 id="view-ui">View&amp;UI 相关</h5><p></p>
<h6 id="Android-RecyclerView-顶部悬浮实现"><a href="#Android-RecyclerView-顶部悬浮实现" class="headerlink" title="Android RecyclerView 顶部悬浮实现"></a><a href="http://www.jianshu.com/p/c596f2e6f587" target="_blank" rel="external">Android RecyclerView 顶部悬浮实现</a></h6><h6 id="那些酷炫的RecyclerView开源库整理"><a href="#那些酷炫的RecyclerView开源库整理" class="headerlink" title="那些酷炫的RecyclerView开源库整理"></a><a href="http://www.jianshu.com/p/154891851fe2" target="_blank" rel="external">那些酷炫的RecyclerView开源库整理</a></h6><h6 id="RecyclerView使用详解（一）"><a href="#RecyclerView使用详解（一）" class="headerlink" title="RecyclerView使用详解（一）"></a><a href="http://frank-zhu.github.io/android/2015/01/16/android-recyclerview-part-1/" target="_blank" rel="external">RecyclerView使用详解（一）</a></h6><h6 id="Android-RecyclerView-使用完全解析-体验艺术般的控件"><a href="#Android-RecyclerView-使用完全解析-体验艺术般的控件" class="headerlink" title="Android RecyclerView 使用完全解析 体验艺术般的控件"></a><a href="http://blog.csdn.net/lmj623565791/article/details/45059587" target="_blank" rel="external">Android RecyclerView 使用完全解析 体验艺术般的控件</a></h6><h6 id="RecyclerView使用介绍-泡在网上的日子"><a href="#RecyclerView使用介绍-泡在网上的日子" class="headerlink" title="RecyclerView使用介绍-泡在网上的日子"></a><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2004.html" target="_blank" rel="external">RecyclerView使用介绍-泡在网上的日子</a></h6><h6 id="这是一篇Android-RecyclerView使用介绍哦"><a href="#这是一篇Android-RecyclerView使用介绍哦" class="headerlink" title="这是一篇Android RecyclerView使用介绍哦"></a><a href="http://www.jianshu.com/p/12ec590f6c76#" target="_blank" rel="external">这是一篇Android RecyclerView使用介绍哦</a></h6><h6 id="RecyclerView-入门教程（超详细）"><a href="#RecyclerView-入门教程（超详细）" class="headerlink" title=" RecyclerView 入门教程（超详细）"></a><a href="http://blog.csdn.net/u013647382/article/details/51901103" target="_blank" rel="external"> RecyclerView 入门教程（超详细）</a></h6><p></p><h5 id="material-design">Material Design 相关</h5><p></p>
<h6 id="Awesome-MaterialDesign"><a href="#Awesome-MaterialDesign" class="headerlink" title="Awesome-MaterialDesign"></a><a href="https://github.com/lightSky/Awesome-MaterialDesign" target="_blank" rel="external">Awesome-MaterialDesign</a></h6><h6 id="Android-Material-Design系列之主题样式介绍说明等"><a href="#Android-Material-Design系列之主题样式介绍说明等" class="headerlink" title="Android Material Design系列之主题样式介绍说明等"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5NDkxMTgyNw==&amp;mid=2653057851&amp;idx=1&amp;sn=fa8351fa06005314635e79abc45ec171#rd" target="_blank" rel="external">Android Material Design系列之主题样式介绍说明等</a></h6><h6 id="Android-Material-Design-兼容库的使用详解"><a href="#Android-Material-Design-兼容库的使用详解" class="headerlink" title="Android Material Design 兼容库的使用详解"></a><a href="http://www.jianshu.com/p/1e6eed09d48b" target="_blank" rel="external">Android Material Design 兼容库的使用详解</a></h6><h6 id="Material-Design技术分享"><a href="#Material-Design技术分享" class="headerlink" title="Material Design技术分享"></a><a href="https://mp.weixin.qq.com/s?__biz=MzI1NjEwMTM4OA==&amp;mid=2651231829&amp;idx=1&amp;sn=2418c741e7f0e41f6ac4fff4dc2de6f0&amp;scene=1&amp;srcid=0526kJT3uB1vIPjVXTVrSKjW&amp;pass_ticket=muxDwCVjxMK%2Fz1ncol%2B4QyK94pZsvdn%2FSA4JigA6HWU1Hf%2Fr6BUURvZ002TBW6Oq#rd" target="_blank" rel="external">Material Design技术分享</a></h6><h6 id="Android-Material-Design系列之Toolbar"><a href="#Android-Material-Design系列之Toolbar" class="headerlink" title="Android Material Design系列之Toolbar"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5NDkxMTgyNw==&amp;mid=2653057635&amp;idx=1&amp;sn=bc8ea475db4f215226367eed71105f35&amp;scene=0#wechat_redirect" target="_blank" rel="external">Android Material Design系列之Toolbar</a></h6><h6 id="最能解决你的痛点问题，也是你最需要的，尽在Material-Design-系列这篇"><a href="#最能解决你的痛点问题，也是你最需要的，尽在Material-Design-系列这篇" class="headerlink" title="最能解决你的痛点问题，也是你最需要的，尽在Material Design 系列这篇"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5NDkxMTgyNw==&amp;mid=2653057738&amp;idx=1&amp;sn=f0b212bfe3343b8f707f32bfefbbda0b#wechat_redirect" target="_blank" rel="external">最能解决你的痛点问题，也是你最需要的，尽在Material Design 系列这篇</a></h6><h6 id="Material-designed-password"><a href="#Material-designed-password" class="headerlink" title="Material designed password"></a><a href="https://github.com/SubhrajyotiSen/PasswordView" target="_blank" rel="external">Material designed password</a></h6><p></p><h5 id="android-studio">Android Studio 相关</h5><p></p>
<h6 id="Android-Studio系列教程一-—-下载与安装"><a href="#Android-Studio系列教程一-—-下载与安装" class="headerlink" title="Android Studio系列教程一 —- 下载与安装"></a><a href="http://stormzhang.com/devtools/2014/11/25/android-studio-tutorial1/" target="_blank" rel="external">Android Studio系列教程一 —- 下载与安装</a></h6><h6 id="Android-Studio系列教程二-—-基本设置与运行"><a href="#Android-Studio系列教程二-—-基本设置与运行" class="headerlink" title="Android Studio系列教程二 —- 基本设置与运行"></a><a href="http://stormzhang.com/devtools/2014/11/28/android-studio-tutorial2/" target="_blank" rel="external">Android Studio系列教程二 —- 基本设置与运行</a></h6><h6 id="Android-Studio系列教程四-—-Gradle基础"><a href="#Android-Studio系列教程四-—-Gradle基础" class="headerlink" title="Android Studio系列教程四 —- Gradle基础"></a><a href="http://stormzhang.com/devtools/2014/12/18/android-studio-tutorial4/" target="_blank" rel="external">Android Studio系列教程四 —- Gradle基础</a></h6><h6 id="AS技巧合集「常用技巧篇」"><a href="#AS技巧合集「常用技巧篇」" class="headerlink" title="AS技巧合集「常用技巧篇」"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=402416974&amp;idx=1&amp;sn=a8fd70a65ff3973758e4a7975c361139&amp;scene=21#wechat_redirect" target="_blank" rel="external">AS技巧合集「常用技巧篇」</a></h6><h6 id="AS技巧合集「编码技巧篇」"><a href="#AS技巧合集「编码技巧篇」" class="headerlink" title="AS技巧合集「编码技巧篇」"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=402416974&amp;idx=2&amp;sn=136e2a77c9bdd2cf971143d7f35e57d2&amp;scene=21#wechat_redirect" target="_blank" rel="external">AS技巧合集「编码技巧篇」</a></h6><h6 id="AS技巧合集「调试技巧篇」"><a href="#AS技巧合集「调试技巧篇」" class="headerlink" title="AS技巧合集「调试技巧篇」"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=402416974&amp;idx=3&amp;sn=3a0f99a753e7e8372cb98b696542d2cb&amp;scene=21#wechat_redirect" target="_blank" rel="external">AS技巧合集「调试技巧篇」</a></h6><h6 id="Android-Studio-掌握这些调试技巧，Debug能力不能再高啦"><a href="#Android-Studio-掌握这些调试技巧，Debug能力不能再高啦" class="headerlink" title="Android Studio 掌握这些调试技巧，Debug能力不能再高啦"></a><a href="http://www.jianshu.com/p/985f788fae2c" target="_blank" rel="external">Android Studio 掌握这些调试技巧，Debug能力不能再高啦</a></h6><h6 id="Android-Studio五分钟带你从菜鸟到高级调试"><a href="#Android-Studio五分钟带你从菜鸟到高级调试" class="headerlink" title="Android Studio五分钟带你从菜鸟到高级调试"></a><a href="http://blog.csdn.net/u013132758/article/details/51915575" target="_blank" rel="external">Android Studio五分钟带你从菜鸟到高级调试</a></h6><h6 id="Android-Studio最全快捷键以及演示"><a href="#Android-Studio最全快捷键以及演示" class="headerlink" title="Android Studio最全快捷键以及演示"></a><a href="http://fvaryu.github.io/2016/07/22/as-keymap/" target="_blank" rel="external">Android Studio最全快捷键以及演示</a></h6><h6 id="精品推荐-Android-Studio插件整理"><a href="#精品推荐-Android-Studio插件整理" class="headerlink" title="[精品推荐]Android Studio插件整理"></a><a href="https://mp.weixin.qq.com/s?__biz=MzI3MDE0NzYwNA==&amp;mid=2651433634&amp;idx=1&amp;sn=e5f65d8a0a2b85f7c22d8ccd4cf96a39&amp;scene=1&amp;srcid=0721vQcDls3Ak34dZY1y3h7o&amp;key=77421cf58af4a653e4f55f04cf114492e73a17a2a7d56a0e523c62f16c003b19cdab0cf3a902023d7cbe2af60a58c71d&amp;ascene=0&amp;uin=MjAyNzY1NTU%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.11.3+build(15D21" target="_blank" rel="external">[精品推荐]Android Studio插件整理</a></h6><h6 id="多module合成单一module技巧"><a href="#多module合成单一module技巧" class="headerlink" title="多module合成单一module技巧"></a><a href="http://www.jianshu.com/p/9b022951571c" target="_blank" rel="external">多module合成单一module技巧</a></h6><h6 id="Android-Studio相见恨晚的操作锦集"><a href="#Android-Studio相见恨晚的操作锦集" class="headerlink" title="Android Studio相见恨晚的操作锦集"></a><a href="http://www.jianshu.com/p/bc8f6bfe12c6?" target="_blank" rel="external">Android Studio相见恨晚的操作锦集</a></h6><h6 id="Android-Studio-Plugin-is-too-old、Gradle-version-2-10-is-required问题解决方法"><a href="#Android-Studio-Plugin-is-too-old、Gradle-version-2-10-is-required问题解决方法" class="headerlink" title="Android Studio Plugin is too old、Gradle version 2.10 is required问题解决方法"></a><a href="http://yanziyu.top/2016/03/21/as-issue/" target="_blank" rel="external">Android Studio Plugin is too old、Gradle version 2.10 is required问题解决方法</a></h6><h6 id="Android-Studio-2-0-稳定版-新特性简介（中文）"><a href="#Android-Studio-2-0-稳定版-新特性简介（中文）" class="headerlink" title="Android Studio 2.0 稳定版 新特性简介（中文）"></a><a href="http://chinagdg.org/2016/04/android-studio-2-0/" target="_blank" rel="external">Android Studio 2.0 稳定版 新特性简介（中文）</a></h6><h6 id="配置你的-Android-Studio"><a href="#配置你的-Android-Studio" class="headerlink" title="配置你的 Android Studio"></a><a href="http://gold.xitu.io/entry/570b79f071cfe4005fa5cda5" target="_blank" rel="external">配置你的 Android Studio</a></h6><h6 id="10个你可能不知道的-Android-Studio技巧"><a href="#10个你可能不知道的-Android-Studio技巧" class="headerlink" title="10个你可能不知道的 Android Studio技巧"></a><a href="http://www.jcodecraeer.com/a/anzhuokaifa/Android_Studio/2016/0424/4172.html" target="_blank" rel="external">10个你可能不知道的 Android Studio技巧</a></h6><h6 id="使用新版Android-Studio检测内存泄露和性能"><a href="#使用新版Android-Studio检测内存泄露和性能" class="headerlink" title="使用新版Android Studio检测内存泄露和性能"></a><a href="http://www.jianshu.com/p/216b03c22bb8" target="_blank" rel="external">使用新版Android Studio检测内存泄露和性能</a></h6><h6 id="AndroidStudio上面最好用的插件"><a href="#AndroidStudio上面最好用的插件" class="headerlink" title="AndroidStudio上面最好用的插件"></a><a href="http://www.jianshu.com/p/d76b60a3883d" target="_blank" rel="external">AndroidStudio上面最好用的插件</a></h6><h6 id="Android必知必会-Android-Studio修改包名"><a href="#Android必知必会-Android-Studio修改包名" class="headerlink" title="Android必知必会-Android Studio修改包名"></a><a href="http://blog.csdn.net/ys743276112/article/details/51684294" target="_blank" rel="external">Android必知必会-Android Studio修改包名</a></h6><h6 id="Android-Studio必备插件"><a href="#Android-Studio必备插件" class="headerlink" title="Android Studio必备插件"></a><a href="http://hjxandhmr.github.io/2016/06/21/AndroidStudio-Plug/" target="_blank" rel="external">Android Studio必备插件</a></h6><h6 id="在Android-Studio中进行单元测试和UI测试"><a href="#在Android-Studio中进行单元测试和UI测试" class="headerlink" title="在Android Studio中进行单元测试和UI测试"></a><a href="http://www.jianshu.com/p/03118c11c199" target="_blank" rel="external">在Android Studio中进行单元测试和UI测试</a></h6><h6 id="Android-Studio插件整理"><a href="#Android-Studio插件整理" class="headerlink" title="Android Studio插件整理"></a><a href="https://ydmmocoo.github.io/2016/06/28/Android-Studio%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/" target="_blank" rel="external">Android Studio插件整理</a></h6><h6 id="你所不知道的Android-Studio调试技巧"><a href="#你所不知道的Android-Studio调试技巧" class="headerlink" title="你所不知道的Android Studio调试技巧"></a><a href="http://www.jianshu.com/p/011eb88f4e0d" target="_blank" rel="external">你所不知道的Android Studio调试技巧</a></h6><h6 id="Android模版化编程系列（二）"><a href="#Android模版化编程系列（二）" class="headerlink" title="Android模版化编程系列（二）"></a><a href="http://blog.csdn.net/qq_15028795/article/details/51939047" target="_blank" rel="external">Android模版化编程系列（二）</a></h6><h6 id="Android-Studio-2-2-中几个实用的新功能"><a href="#Android-Studio-2-2-中几个实用的新功能" class="headerlink" title="Android Studio 2.2 中几个实用的新功能"></a><a href="http://www.jianshu.com/p/bc9bbac5a170" target="_blank" rel="external">Android Studio 2.2 中几个实用的新功能</a></h6></li>
</ul>
<ul>
<li><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><h6 id="Android开发知识体系图-极客学院"><a href="#Android开发知识体系图-极客学院" class="headerlink" title="Android开发知识体系图-[极客学院]"></a><a href="http://www.jikexueyuan.com/path/android" target="_blank" rel="external">Android开发知识体系图-[极客学院]</a></h6><h6 id="Android-慕课网学习路径"><a href="#Android-慕课网学习路径" class="headerlink" title="Android-慕课网学习路径"></a><a href="http://www.imooc.com/course/programdetail/pid/33" target="_blank" rel="external">Android-慕课网学习路径</a></h6><h6 id="Android-开发工程师-优达学城"><a href="#Android-开发工程师-优达学城" class="headerlink" title="Android 开发工程师-优达学城"></a><a href="https://cn.udacity.com/android/" target="_blank" rel="external">Android 开发工程师-优达学城</a></h6></li>
<li><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><h6 id="Android-Developer官方文档"><a href="#Android-Developer官方文档" class="headerlink" title="Android Developer官方文档"></a><a href="https://developer.android.com/index.html" target="_blank" rel="external">Android Developer官方文档</a></h6><h6 id="Android官方培训课程中文版-v0-9-7"><a href="#Android官方培训课程中文版-v0-9-7" class="headerlink" title="Android官方培训课程中文版(v0.9.7)"></a><a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="external">Android官方培训课程中文版(v0.9.7)</a></h6><h6 id="Android-官方中文-部分-培训文档"><a href="#Android-官方中文-部分-培训文档" class="headerlink" title="Android 官方中文(部分)培训文档"></a><a href="https://developer.android.google.cn/training/index.html" target="_blank" rel="external">Android 官方中文(部分)培训文档</a></h6><h6 id="wan-android-知识体系"><a href="#wan-android-知识体系" class="headerlink" title="wan android 知识体系"></a><a href="http://www.xueandroid.com/hierarchy?courseId=13" target="_blank" rel="external">wan android 知识体系</a></h6><h6 id="Material-Design-官方文档"><a href="#Material-Design-官方文档" class="headerlink" title="Material Design 官方文档"></a><a href="https://material.io/guidelines/" target="_blank" rel="external">Material Design 官方文档</a></h6><h6 id="Material-Design-中文版"><a href="#Material-Design-中文版" class="headerlink" title="Material Design 中文版"></a><a href="http://wiki.jikexueyuan.com/project/material-design/" target="_blank" rel="external">Material Design 中文版</a></h6><h6 id="Android-中文API"><a href="#Android-中文API" class="headerlink" title="Android 中文API"></a><a href="http://www.android-doc.com/index.html" target="_blank" rel="external">Android 中文API</a></h6></li>
</ul>
<p></p><h3 id="java">Java</h3><a href="#tags">点击此处回到Tags</a><p></p>
<ul>
<li><h4 id="Blogs-1"><a href="#Blogs-1" class="headerlink" title="Blogs"></a>Blogs</h4><h6 id="一分钟秒懂注解"><a href="#一分钟秒懂注解" class="headerlink" title="一分钟秒懂注解"></a><a href="https://dreamerhome.github.io/2016/08/02/annotaion/" target="_blank" rel="external">一分钟秒懂注解</a></h6><h6 id="浅谈依赖注入与控制反转"><a href="#浅谈依赖注入与控制反转" class="headerlink" title="浅谈依赖注入与控制反转"></a><a href="http://hersface.com/page/DI_IoC.html" target="_blank" rel="external">浅谈依赖注入与控制反转</a></h6><h6 id="公共技术点之-Java-反射-Reflection"><a href="#公共技术点之-Java-反射-Reflection" class="headerlink" title="公共技术点之 Java 反射 Reflection"></a><a href="http://p.codekk.com/blogs/detail/5596953ed6459ae7934997c5" target="_blank" rel="external">公共技术点之 Java 反射 Reflection</a></h6><h6 id="浅谈Java回调机制"><a href="#浅谈Java回调机制" class="headerlink" title="浅谈Java回调机制"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;mid=403109183&amp;idx=1&amp;sn=2909a7702c12c4ada2c908263626b642#rd" target="_blank" rel="external">浅谈Java回调机制</a></h6><h6 id="知道这20个正则表达式，能让你少写1000行代码"><a href="#知道这20个正则表达式，能让你少写1000行代码" class="headerlink" title="知道这20个正则表达式，能让你少写1000行代码"></a><a href="http://www.jianshu.com/p/e7bb97218946" target="_blank" rel="external">知道这20个正则表达式，能让你少写1000行代码</a></h6><h6 id="公共技术点之-Java-注解-Annotation"><a href="#公共技术点之-Java-注解-Annotation" class="headerlink" title="公共技术点之 Java 注解 Annotation"></a><a href="http://p.codekk.com/blogs/detail/54cfab086c4761e5001b253b" target="_blank" rel="external">公共技术点之 Java 注解 Annotation</a></h6><h6 id="反射、注解与依赖注入总结"><a href="#反射、注解与依赖注入总结" class="headerlink" title="反射、注解与依赖注入总结"></a><a href="http://www.jianshu.com/p/24820bf3df5c" target="_blank" rel="external">反射、注解与依赖注入总结</a></h6><h6 id="JAVA-decompiler-collections"><a href="#JAVA-decompiler-collections" class="headerlink" title="JAVA decompiler collections"></a><a href="http://www.figotan.org/2015/11/24/java-decompiler-collections/" target="_blank" rel="external">JAVA decompiler collections</a></h6><h6 id="Android-中的-Enum-到底占多少内存？该如何用？"><a href="#Android-中的-Enum-到底占多少内存？该如何用？" class="headerlink" title="Android 中的 Enum 到底占多少内存？该如何用？"></a><a href="http://www.jianshu.com/p/6052cd4ea9ae" target="_blank" rel="external">Android 中的 Enum 到底占多少内存？该如何用？</a></h6><h6 id="infoQ——java系列blog（成富）"><a href="#infoQ——java系列blog（成富）" class="headerlink" title="infoQ——java系列blog（成富）"></a><a href="http://www.infoq.com/cn/author/%E6%88%90%E5%AF%8C#文章" target="_blank" rel="external">infoQ——java系列blog（成富）</a></h6><h6 id="Java中的多线程你只要看这一篇就够了"><a href="#Java中的多线程你只要看这一篇就够了" class="headerlink" title="Java中的多线程你只要看这一篇就够了"></a><a href="http://www.jianshu.com/p/40d4c7aebd66" target="_blank" rel="external">Java中的多线程你只要看这一篇就够了</a></h6><h6 id="为什么说DOM操作很慢"><a href="#为什么说DOM操作很慢" class="headerlink" title="为什么说DOM操作很慢"></a><a href="https://leozdgao.me/why-dom-slow/" target="_blank" rel="external">为什么说DOM操作很慢</a></h6><h6 id="Android-多线程编程的总结"><a href="#Android-多线程编程的总结" class="headerlink" title="Android 多线程编程的总结"></a><a href="http://www.diycode.cc/topics/213" target="_blank" rel="external">Android 多线程编程的总结</a></h6><h6 id="第4章-类和接口"><a href="#第4章-类和接口" class="headerlink" title="第4章 类和接口"></a><a href="http://mp.weixin.qq.com/s?__biz=MzIxNDE1NjQ2Mw==&amp;mid=2649872269&amp;idx=1&amp;sn=3e96d3e374e3c958041383f653d8b2ab#rd" target="_blank" rel="external">第4章 类和接口</a></h6><h6 id="【深入理解Java虚拟机】垃圾回收机制"><a href="#【深入理解Java虚拟机】垃圾回收机制" class="headerlink" title="【深入理解Java虚拟机】垃圾回收机制"></a><a href="http://blog.csdn.net/shakespeare001/article/details/51749788" target="_blank" rel="external">【深入理解Java虚拟机】垃圾回收机制</a></h6><h6 id="Java对象锁和类锁全面解析（多线程synchronized关键字）"><a href="#Java对象锁和类锁全面解析（多线程synchronized关键字）" class="headerlink" title="Java对象锁和类锁全面解析（多线程synchronized关键字）"></a><a href="http://www.importnew.com/20444.html" target="_blank" rel="external">Java对象锁和类锁全面解析（多线程synchronized关键字）</a></h6><h6 id="探究Java中的克隆"><a href="#探究Java中的克隆" class="headerlink" title="探究Java中的克隆"></a><a href="http://droidyue.com/blog/2016/05/15/dive-into-java-clone/" target="_blank" rel="external">探究Java中的克隆</a></h6><h6 id="理解Java中的ThreadLocal"><a href="#理解Java中的ThreadLocal" class="headerlink" title="理解Java中的ThreadLocal"></a><a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/" target="_blank" rel="external">理解Java中的ThreadLocal</a></h6><h6 id="Java-帝国之Java-bean-上）"><a href="#Java-帝国之Java-bean-上）" class="headerlink" title="Java 帝国之Java bean (上）"></a><a href="http://mp.weixin.qq.com/s/w_U7MGwDign59BJ5XJvNVQ" target="_blank" rel="external">Java 帝国之Java bean (上）</a></h6><h6 id="Java-帝国之Java-bean（下）"><a href="#Java-帝国之Java-bean（下）" class="headerlink" title="Java 帝国之Java bean（下）"></a><a href="http://mp.weixin.qq.com/s/PtmrlDvzPVl76hjfscFihw" target="_blank" rel="external">Java 帝国之Java bean（下）</a></h6></li>
<li><h4 id="视频-1"><a href="#视频-1" class="headerlink" title="视频"></a>视频</h4><h6 id="Servlet-JSP（JavaEE开发进阶Ⅰ）"><a href="#Servlet-JSP（JavaEE开发进阶Ⅰ）" class="headerlink" title="Servlet+JSP（JavaEE开发进阶Ⅰ）"></a><a href="http://study.163.com/course/introduction.htm?courseId=1002907014#/courseDetail" target="_blank" rel="external">Servlet+JSP（JavaEE开发进阶Ⅰ）</a></h6><h6 id="Java课程-Java300集大型视频教程"><a href="#Java课程-Java300集大型视频教程" class="headerlink" title="Java课程 Java300集大型视频教程"></a><a href="http://study.163.com/course/introduction.htm?courseId=343001#/courseDetail" target="_blank" rel="external">Java课程 Java300集大型视频教程</a></h6><h6 id="JavaWeb工程师-极客学院"><a href="#JavaWeb工程师-极客学院" class="headerlink" title="JavaWeb工程师-[极客学院]"></a><a href="http://ke.jikexueyuan.com/zhiye/javaweb/" target="_blank" rel="external">JavaWeb工程师-[极客学院]</a></h6><h6 id="JavaEE视频教程"><a href="#JavaEE视频教程" class="headerlink" title="JavaEE视频教程"></a><a href="http://study.163.com/course/introduction/320027.htm#/courseDetail" target="_blank" rel="external">JavaEE视频教程</a></h6></li>
<li><h4 id="文档-1"><a href="#文档-1" class="headerlink" title="文档"></a>文档</h4><h6 id="Java-官方Tutorial"><a href="#Java-官方Tutorial" class="headerlink" title="Java 官方Tutorial"></a><a href="http://docs.oracle.com/javase/tutorial/" target="_blank" rel="external">Java 官方Tutorial</a></h6><h6 id="The-Java®-Language-Specification"><a href="#The-Java®-Language-Specification" class="headerlink" title="The Java® Language Specification"></a><a href="http://docs.oracle.com/javase/specs/jls/se8/html/index.html" target="_blank" rel="external">The Java® Language Specification</a></h6><h6 id="Java1-8-API在线文档"><a href="#Java1-8-API在线文档" class="headerlink" title="Java1.8 API在线文档"></a><a href="http://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="external">Java1.8 API在线文档</a></h6><h6 id="Java相关Wiki-极客学院"><a href="#Java相关Wiki-极客学院" class="headerlink" title="Java相关Wiki-[极客学院]"></a><a href="http://wiki.jikexueyuan.com/list/java/" target="_blank" rel="external">Java相关Wiki-[极客学院]</a></h6></li>
</ul>
<p></p><h3 id="kotlin">Kotlin</h3><a href="#tags">点击此处回到Tags</a><p></p>
<h6 id="Kotlin-官方参考文档-中文版"><a href="#Kotlin-官方参考文档-中文版" class="headerlink" title="Kotlin 官方参考文档 中文版"></a><a href="https://www.gitbook.com/book/hltj/kotlin-reference-chinese/details" target="_blank" rel="external">Kotlin 官方参考文档 中文版</a></h6><h6 id="Kotlin-官方教程"><a href="#Kotlin-官方教程" class="headerlink" title="Kotlin 官方教程"></a><a href="http://kotlinlang.org/docs/tutorials/" target="_blank" rel="external">Kotlin 官方教程</a></h6><h6 id="Kotlin-中文教程"><a href="#Kotlin-中文教程" class="headerlink" title="Kotlin 中文教程"></a><a href="https://github.com/mcxiaoke/kotlin-notes" target="_blank" rel="external">Kotlin 中文教程</a></h6><h6 id="Kotlin从入门到『放弃』系列-视频教程"><a href="#Kotlin从入门到『放弃』系列-视频教程" class="headerlink" title="Kotlin从入门到『放弃』系列 视频教程"></a><a href="https://github.com/enbandari/Kotlin-Tutorials" target="_blank" rel="external">Kotlin从入门到『放弃』系列 视频教程</a></h6><h6 id="Kotlin-Primer·第一章·启程"><a href="#Kotlin-Primer·第一章·启程" class="headerlink" title="Kotlin Primer·第一章·启程"></a><a href="https://www.kymjs.com/code/2017/02/03/01/" target="_blank" rel="external">Kotlin Primer·第一章·启程</a></h6><p></p><h3 id="shejimoshi">设计模式</h3><a href="#tags">点击此处回到Tags</a><p></p>
<h6 id="设计模式Java版"><a href="#设计模式Java版" class="headerlink" title="设计模式Java版"></a><a href="https://www.gitbook.com/book/quanke/design-pattern-java/details" target="_blank" rel="external">设计模式Java版</a></h6><h6 id="Android-源码中的设计模式"><a href="#Android-源码中的设计模式" class="headerlink" title="Android 源码中的设计模式"></a><a href="http://blog.csdn.net/amazing7/article/details/51719404" target="_blank" rel="external">Android 源码中的设计模式</a></h6><h6 id="从Android代码中来记忆23种设计模式"><a href="#从Android代码中来记忆23种设计模式" class="headerlink" title="从Android代码中来记忆23种设计模式"></a><a href="http://blog.csdn.net/huachao1001/article/details/51536074" target="_blank" rel="external">从Android代码中来记忆23种设计模式</a></h6><h6 id="【女朋友系列之找女朋友篇】简单工厂模式，工厂模式，抽象工厂模式"><a href="#【女朋友系列之找女朋友篇】简单工厂模式，工厂模式，抽象工厂模式" class="headerlink" title="【女朋友系列之找女朋友篇】简单工厂模式，工厂模式，抽象工厂模式"></a><a href="http://www.jianshu.com/p/3f824a91d73b" target="_blank" rel="external">【女朋友系列之找女朋友篇】简单工厂模式，工厂模式，抽象工厂模式</a></h6><h6 id="设计模式速谈：二、简单工厂模式"><a href="#设计模式速谈：二、简单工厂模式" class="headerlink" title="设计模式速谈：二、简单工厂模式"></a><a href="https://www.yhspy.com/blog/182/" target="_blank" rel="external">设计模式速谈：二、简单工厂模式</a></h6><h6 id="Android-设计模式"><a href="#Android-设计模式" class="headerlink" title="Android 设计模式"></a><a href="http://m.blog.csdn.net/article/details?plg_nld=1&amp;id=24985607&amp;plg_auth=1&amp;plg_uin=1&amp;plg_usr=1&amp;plg_vkey=1&amp;plg_nld=1&amp;plg_dev=1" target="_blank" rel="external">Android 设计模式</a></h6><p></p><h3 id="sql">数据库</h3><a href="#tags">点击此处回到Tags</a><p></p>
<h6 id="SQLite-官方文档"><a href="#SQLite-官方文档" class="headerlink" title="SQLite 官方文档"></a><a href="http://www.sqlite.org/docs.html" target="_blank" rel="external">SQLite 官方文档</a></h6><h6 id="SQL基础语句汇总"><a href="#SQL基础语句汇总" class="headerlink" title="SQL基础语句汇总"></a><a href="http://www.jcodecraeer.com/a/shujuku/2015/1024/3619.html" target="_blank" rel="external">SQL基础语句汇总</a></h6><h6 id="Android-中-SQLite-性能优化"><a href="#Android-中-SQLite-性能优化" class="headerlink" title="Android 中 SQLite 性能优化"></a><a href="http://droidyue.com/blog/2015/12/13/android-sqlite-tuning/" target="_blank" rel="external">Android 中 SQLite 性能优化</a></h6><p></p><h3 id="git">Git</h3><a href="#tags">点击此处回到Tags</a><p></p>
<h6 id="Git学习总结"><a href="#Git学习总结" class="headerlink" title="Git学习总结"></a><a href="http://ikookblog.com/2016/10/15/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">Git学习总结</a></h6><h6 id="ProGit中文版"><a href="#ProGit中文版" class="headerlink" title="ProGit中文版"></a><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">ProGit中文版</a></h6><h6 id="廖雪峰的Git教程"><a href="#廖雪峰的Git教程" class="headerlink" title="廖雪峰的Git教程"></a><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的Git教程</a></h6><h6 id="Git简明指南"><a href="#Git简明指南" class="headerlink" title="Git简明指南"></a><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">Git简明指南</a></h6><h6 id="从0开始学习-GitHub-系列之「Git-速成」"><a href="#从0开始学习-GitHub-系列之「Git-速成」" class="headerlink" title="从0开始学习 GitHub 系列之「Git 速成」"></a><a href="http://stormzhang.com/github/2016/05/30/learn-github-from-zero3/" target="_blank" rel="external">从0开始学习 GitHub 系列之「Git 速成」</a></h6><h6 id="从0开始学习-GitHub-系列之「Git-进阶」"><a href="#从0开始学习-GitHub-系列之「Git-进阶」" class="headerlink" title="从0开始学习 GitHub 系列之「Git 进阶」"></a><a href="http://stormzhang.com/github/2016/06/16/learn-github-from-zero5/" target="_blank" rel="external">从0开始学习 GitHub 系列之「Git 进阶」</a></h6><h6 id="常用的12个Git基本命令"><a href="#常用的12个Git基本命令" class="headerlink" title="常用的12个Git基本命令"></a><a href="https://www.sdk.cn/news/2957" target="_blank" rel="external">常用的12个Git基本命令</a></h6><h6 id="闯过这-54-关，点亮你的-Git-技能树"><a href="#闯过这-54-关，点亮你的-Git-技能树" class="headerlink" title="闯过这 54 关，点亮你的 Git 技能树"></a><a href="https://codingstyle.cn/topics/51" target="_blank" rel="external">闯过这 54 关，点亮你的 Git 技能树</a></h6><h6 id="闯过这-54-关，点亮你的-Git-技能树-一"><a href="#闯过这-54-关，点亮你的-Git-技能树-一" class="headerlink" title="闯过这 54 关，点亮你的 Git 技能树 (一)"></a><a href="https://codingstyle.cn/topics/57" target="_blank" rel="external">闯过这 54 关，点亮你的 Git 技能树 (一)</a></h6><h6 id="闯过这-54-关，点亮你的-Git-技能树-二"><a href="#闯过这-54-关，点亮你的-Git-技能树-二" class="headerlink" title="闯过这 54 关，点亮你的 Git 技能树 (二)"></a><a href="https://segmentfault.com/a/1190000005123830" target="_blank" rel="external">闯过这 54 关，点亮你的 Git 技能树 (二)</a></h6><h6 id="常用的几十个Git小技巧分类与总结"><a href="#常用的几十个Git小技巧分类与总结" class="headerlink" title="常用的几十个Git小技巧分类与总结"></a><a href="https://segmentfault.com/a/1190000005706707" target="_blank" rel="external">常用的几十个Git小技巧分类与总结</a></h6><p></p><h3 id="github">GitHub</h3><a href="#tags">点击此处回到Tags</a><p></p>
<h6 id="Github装逼指南——Travis-CI-和-Codecov"><a href="#Github装逼指南——Travis-CI-和-Codecov" class="headerlink" title="Github装逼指南——Travis CI 和 Codecov"></a><a href="https://segmentfault.com/a/1190000004415437" target="_blank" rel="external">Github装逼指南——Travis CI 和 Codecov</a></h6><h6 id="Starred-——-GitHub-增强使用工具"><a href="#Starred-——-GitHub-增强使用工具" class="headerlink" title="Starred —— GitHub 增强使用工具"></a><a href="http://www.oschina.net/p/starred" target="_blank" rel="external">Starred —— GitHub 增强使用工具</a></h6><h6 id="你与优秀源码之间只差一个Star"><a href="#你与优秀源码之间只差一个Star" class="headerlink" title="你与优秀源码之间只差一个Star"></a><a href="http://blog.fir.im/fir_im_weekly160729/?hmsr=gold.xitu.io/&amp;utm_medium=gold.xitu.io&amp;utm_source=gold.xitu.io" target="_blank" rel="external">你与优秀源码之间只差一个Star</a></h6><h6 id="awesome-github-：为了更好地使用-GitHub"><a href="#awesome-github-：为了更好地使用-GitHub" class="headerlink" title="awesome-github ：为了更好地使用 GitHub"></a><a href="https://gold.xitu.io/entry/56d7a0f31532bc0050741afc" target="_blank" rel="external">awesome-github ：为了更好地使用 GitHub</a></h6><h6 id="Android-Studio导入github项目详解"><a href="#Android-Studio导入github项目详解" class="headerlink" title="Android Studio导入github项目详解"></a><a href="http://blog.csdn.net/lyhhj/article/details/48789705" target="_blank" rel="external">Android Studio导入github项目详解</a></h6><h6 id="如何选择开源项目？"><a href="#如何选择开源项目？" class="headerlink" title="如何选择开源项目？"></a><a href="https://zhuanlan.zhihu.com/p/20840610" target="_blank" rel="external">如何选择开源项目？</a></h6><h6 id="我的开源项目从0到1024的过程"><a href="#我的开源项目从0到1024的过程" class="headerlink" title="我的开源项目从0到1024的过程"></a><a href="http://www.jianshu.com/p/f2483bd8da43" target="_blank" rel="external">我的开源项目从0到1024的过程</a></h6><h6 id="从0开始学习-GitHub-系列之「初识-GitHub」"><a href="#从0开始学习-GitHub-系列之「初识-GitHub」" class="headerlink" title="从0开始学习 GitHub 系列之「初识 GitHub」"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661735&amp;idx=1&amp;sn=9aceac07d272e9202d1b5294f857a5ff&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「初识 GitHub」</a></h6><h6 id="从0开始学习-GitHub-系列之「加入-GitHub」"><a href="#从0开始学习-GitHub-系列之「加入-GitHub」" class="headerlink" title="从0开始学习 GitHub 系列之「加入 GitHub」"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661762&amp;idx=1&amp;sn=8282241cf7414030f4e1d315a173beb1&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「加入 GitHub」</a></h6><h6 id="从0开始学习-GitHub-系列之「Git速成」"><a href="#从0开始学习-GitHub-系列之「Git速成」" class="headerlink" title="从0开始学习 GitHub 系列之「Git速成」"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661788&amp;idx=1&amp;sn=b7c54f9b13f4e30fe151905f11c02800&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「Git速成」</a></h6><h6 id="从0开始学习-GitHub-系列之「向GitHub-提交代码」"><a href="#从0开始学习-GitHub-系列之「向GitHub-提交代码」" class="headerlink" title="从0开始学习 GitHub 系列之「向GitHub 提交代码」"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661821&amp;idx=1&amp;sn=c6116ed82bff2d083bb152fbd8cbc38d&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「向GitHub 提交代码」</a></h6><h6 id="从0开始学习-GitHub-系列之「Git-进阶」-1"><a href="#从0开始学习-GitHub-系列之「Git-进阶」-1" class="headerlink" title="从0开始学习 GitHub 系列之「Git 进阶」"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661929&amp;idx=1&amp;sn=69e00516a30723c5a20af3c7a84173a4&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「Git 进阶」</a></h6><h6 id="从0开始学习-GitHub-系列之「团队合作利器-Branch」"><a href="#从0开始学习-GitHub-系列之「团队合作利器-Branch」" class="headerlink" title="从0开始学习 GitHub 系列之「团队合作利器 Branch」"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661978&amp;idx=1&amp;sn=2f5329f5b2bfda7050822cc5e3a4f03f&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「团队合作利器 Branch」</a></h6><h6 id="从0开始学习-GitHub-系列之「如何发现优秀的开源项目」"><a href="#从0开始学习-GitHub-系列之「如何发现优秀的开源项目」" class="headerlink" title="从0开始学习 GitHub 系列之「如何发现优秀的开源项目」"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650662079&amp;idx=1&amp;sn=65605f0d9bd741d38f0b179980dc09f1&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「如何发现优秀的开源项目」</a></h6><h6 id="从0开始学习-GitHub-系列之「GitHub-常见的几种操作」"><a href="#从0开始学习-GitHub-系列之「GitHub-常见的几种操作」" class="headerlink" title="从0开始学习 GitHub 系列之「GitHub 常见的几种操作」"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650662303&amp;idx=1&amp;sn=3df7cba7cd85b33a82b4c05bb12cfff5&amp;chksm=87d138c0b0a6b1d6140da9bab6e58c6e2b258de6118175d31c1ac467b3c58bc1a7c0b1a7db9b&amp;scene=0#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「GitHub 常见的几种操作」</a></h6><h6 id="如何选择开源许可证？"><a href="#如何选择开源许可证？" class="headerlink" title="如何选择开源许可证？"></a><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="external">如何选择开源许可证？</a></h6><p></p><h3 id="mvp">MVP</h3><a href="#tags">点击此处回到Tags</a><p></p>
<h6 id="从零开始的Android新项目3-MVPVM-in-Action-谁告诉你MVP和MVVM是互斥的"><a href="#从零开始的Android新项目3-MVPVM-in-Action-谁告诉你MVP和MVVM是互斥的" class="headerlink" title="从零开始的Android新项目3 - MVPVM in Action, 谁告诉你MVP和MVVM是互斥的"></a><a href="http://blog.zhaiyifan.cn/2016/03/16/android-new-project-from-0-p3/" target="_blank" rel="external">从零开始的Android新项目3 - MVPVM in Action, 谁告诉你MVP和MVVM是互斥的</a></h6><h6 id="todo-mvp–Google官方MVP推荐写法"><a href="#todo-mvp–Google官方MVP推荐写法" class="headerlink" title="todo-mvp–Google官方MVP推荐写法"></a><a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp–Google官方MVP推荐写法</a></h6><h6 id="一步一步实现Android的MVP框架"><a href="#一步一步实现Android的MVP框架" class="headerlink" title="一步一步实现Android的MVP框架"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653577546&amp;idx=1&amp;sn=e10be159645a3aa8f6d6f209420fb412&amp;scene=0#wechat_redirect" target="_blank" rel="external">一步一步实现Android的MVP框架</a></h6><h6 id="Android官方MVP架构示例项目解析"><a href="#Android官方MVP架构示例项目解析" class="headerlink" title="Android官方MVP架构示例项目解析"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=403539764&amp;idx=1&amp;sn=d30d89e6848a8e13d4da0f5639100e5f#rd" target="_blank" rel="external">Android官方MVP架构示例项目解析</a></h6><h6 id="MVP-实现的-Android-基础项目架构"><a href="#MVP-实现的-Android-基础项目架构" class="headerlink" title="MVP 实现的 Android 基础项目架构"></a><a href="https://github.com/xitu/gold-miner/blob/master/TODO/android-basic-project-architecture-for-mvp.md" target="_blank" rel="external">MVP 实现的 Android 基础项目架构</a></h6><h6 id="如何设计MVP中的Presentation层"><a href="#如何设计MVP中的Presentation层" class="headerlink" title="如何设计MVP中的Presentation层"></a><a href="http://blog.chengdazhi.com/index.php/115" target="_blank" rel="external">如何设计MVP中的Presentation层</a></h6><h6 id="解读Android官方MVP项目单元测试"><a href="#解读Android官方MVP项目单元测试" class="headerlink" title="解读Android官方MVP项目单元测试"></a><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0425/4178.html" target="_blank" rel="external">解读Android官方MVP项目单元测试</a></h6><h6 id="google官方架构MVP解析与实战-（从零开始搭建android框架系列（3））"><a href="#google官方架构MVP解析与实战-（从零开始搭建android框架系列（3））" class="headerlink" title="google官方架构MVP解析与实战-（从零开始搭建android框架系列（3））"></a><a href="http://www.jianshu.com/p/569ab68da482" target="_blank" rel="external">google官方架构MVP解析与实战-（从零开始搭建android框架系列（3））</a></h6><h6 id="T-MVP：泛型深度解耦下的MVP大瘦身"><a href="#T-MVP：泛型深度解耦下的MVP大瘦身" class="headerlink" title="T-MVP：泛型深度解耦下的MVP大瘦身"></a><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0513/4260.html" target="_blank" rel="external">T-MVP：泛型深度解耦下的MVP大瘦身</a></h6><h6 id="Android-MVP-Retrofit-RxJava实践小结"><a href="#Android-MVP-Retrofit-RxJava实践小结" class="headerlink" title="Android MVP+Retrofit+RxJava实践小结"></a><a href="http://wuxiaolong.me/2016/06/12/mvpRetrofitRxjava/" target="_blank" rel="external">Android MVP+Retrofit+RxJava实践小结</a></h6><h6 id="android-MVP模式介绍与实战"><a href="#android-MVP模式介绍与实战" class="headerlink" title="android MVP模式介绍与实战"></a><a href="http://dahei.me/2016/06/22/mvp/android%20MVP%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E6%88%98/" target="_blank" rel="external">android MVP模式介绍与实战</a></h6><h6 id="（Basic框架）Android中实现mvp模式的新思路"><a href="#（Basic框架）Android中实现mvp模式的新思路" class="headerlink" title="（Basic框架）Android中实现mvp模式的新思路"></a><a href="http://www.jianshu.com/p/31a202c0c264" target="_blank" rel="external">（Basic框架）Android中实现mvp模式的新思路</a></h6><h6 id="android-MVP-架构思路"><a href="#android-MVP-架构思路" class="headerlink" title="android MVP 架构思路"></a><a href="http://mp.weixin.qq.com/s?__biz=MzI1MjMyOTU2Ng==&amp;mid=2247483865&amp;idx=1&amp;sn=28d3c2f12138e5db0b0245efb1825d4f#rd" target="_blank" rel="external">android MVP 架构思路</a></h6><p></p><h3 id="kaiyuanxiangmu">开源项目</h3><a href="#tags">点击此处回到Tags</a><p></p>
<h6 id="GitHub-Top-100的Android开源库"><a href="#GitHub-Top-100的Android开源库" class="headerlink" title="GitHub Top 100的Android开源库"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=402675429&amp;idx=1&amp;sn=ba3afd2069004b220eaa8a77fdecbaf7#rd" target="_blank" rel="external">GitHub Top 100的Android开源库</a></h6><h6 id="GitHub-排名前-100-的安卓、iOS项目简介"><a href="#GitHub-排名前-100-的安卓、iOS项目简介" class="headerlink" title="GitHub 排名前 100 的安卓、iOS项目简介"></a><a href="http://www.devstore.cn/essay/essayInfo/6485.html" target="_blank" rel="external">GitHub 排名前 100 的安卓、iOS项目简介</a></h6><h6 id="Facebook开源软件列表"><a href="#Facebook开源软件列表" class="headerlink" title="Facebook开源软件列表"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;mid=2659597383&amp;idx=1&amp;sn=a867ee13f294d38d02313a4c58d3da48&amp;scene=1&amp;srcid=06056GdF0vD6Jp3k7AfdizSn&amp;from=groupmessage&amp;isappinstalled=0#wechat_redirect" target="_blank" rel="external">Facebook开源软件列表</a></h6><h6 id="那些酷炫的RecyclerView开源库整理-1"><a href="#那些酷炫的RecyclerView开源库整理-1" class="headerlink" title="那些酷炫的RecyclerView开源库整理"></a><a href="http://www.jianshu.com/p/154891851fe2" target="_blank" rel="external">那些酷炫的RecyclerView开源库整理</a></h6><h6 id="Android-开源项目分类汇总"><a href="#Android-开源项目分类汇总" class="headerlink" title="Android 开源项目分类汇总"></a><a href="https://github.com/Trinea/android-open-project" target="_blank" rel="external">Android 开源项目分类汇总</a></h6><h6 id="Android-开源项目源码解析"><a href="#Android-开源项目源码解析" class="headerlink" title="Android 开源项目源码解析"></a><a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">Android 开源项目源码解析</a></h6><h6 id="Android开源项目大全之工具库"><a href="#Android开源项目大全之工具库" class="headerlink" title="Android开源项目大全之工具库 "></a><a href="http://www.neast.cn/forum.php?mod=viewthread&amp;tid=5487" target="_blank" rel="external">Android开源项目大全之工具库 </a></h6><h6 id="GitHub开源项目总结"><a href="#GitHub开源项目总结" class="headerlink" title="GitHub开源项目总结"></a><a href="http://neast.cn/forum.php?mod=viewthread&amp;tid=5377" target="_blank" rel="external">GitHub开源项目总结</a></h6><h6 id="Android开发人员不得不收集的代码"><a href="#Android开发人员不得不收集的代码" class="headerlink" title="Android开发人员不得不收集的代码"></a><a href="https://github.com/Blankj/AndroidUtilCode/blob/master/README-CN.md" target="_blank" rel="external">Android开发人员不得不收集的代码</a></h6><p></p><h3 id="linux">Linux</h3><a href="#tags">点击此处回到Tags</a><p></p>
<ul>
<li><h4 id="Blogs-2"><a href="#Blogs-2" class="headerlink" title="Blogs"></a>Blogs</h4><h6 id="非常全面的Linux知识点总结"><a href="#非常全面的Linux知识点总结" class="headerlink" title="非常全面的Linux知识点总结"></a><a href="http://www.codeceo.com/article/linux-tips.html" target="_blank" rel="external">非常全面的Linux知识点总结</a></h6><h6 id="我是如何学习Linux的"><a href="#我是如何学习Linux的" class="headerlink" title="我是如何学习Linux的"></a><a href="https://www.sdk.cn/news/3230" target="_blank" rel="external">我是如何学习Linux的</a></h6><h6 id="Linux中查找命令总结"><a href="#Linux中查找命令总结" class="headerlink" title="Linux中查找命令总结"></a><a href="http://www.36nu.com/post/124.html" target="_blank" rel="external">Linux中查找命令总结</a></h6><h6 id="ubuntu-工具-–-5分钟入手Terminator"><a href="#ubuntu-工具-–-5分钟入手Terminator" class="headerlink" title="ubuntu 工具 – 5分钟入手Terminator"></a><a href="http://www.jianshu.com/p/cee2de32ca28" target="_blank" rel="external">ubuntu 工具 – 5分钟入手Terminator</a></h6></li>
<li><h4 id="视频-2"><a href="#视频-2" class="headerlink" title="视频"></a>视频</h4><h6 id="Linux服务器基础"><a href="#Linux服务器基础" class="headerlink" title="Linux服务器基础"></a><a href="http://study.163.com/course/introduction.htm?courseId=788001#/courseDetail" target="_blank" rel="external">Linux服务器基础</a></h6></li>
</ul>
<p></p><h3 id="xiaolv">效率工具</h3><a href="#tags">点击此处回到Tags</a><p></p>
<h6 id="Android-Pixel计算器"><a href="#Android-Pixel计算器" class="headerlink" title="Android Pixel计算器"></a><a href="http://angrytools.com/android/pixelcalc/?winzoom=1" target="_blank" rel="external">Android Pixel计算器</a></h6><h6 id="有了这10款逆天级效率工具，每天提前下班2小时-DEMO8年度产品盘点"><a href="#有了这10款逆天级效率工具，每天提前下班2小时-DEMO8年度产品盘点" class="headerlink" title="有了这10款逆天级效率工具，每天提前下班2小时!#DEMO8年度产品盘点#"></a><a href="http://www.jianshu.com/p/a3312f1c7068" target="_blank" rel="external">有了这10款逆天级效率工具，每天提前下班2小时!#DEMO8年度产品盘点#</a></h6><h6 id="ClassyShark——apk分析利器"><a href="#ClassyShark——apk分析利器" class="headerlink" title="ClassyShark——apk分析利器"></a><a href="https://mp.weixin.qq.com/s/zieCldmExPYr_-9V6zKC3A" target="_blank" rel="external">ClassyShark——apk分析利器</a></h6><h6 id="Au开发者工具"><a href="#Au开发者工具" class="headerlink" title="Au开发者工具"></a><a href="http://eiyou.us/" target="_blank" rel="external">Au开发者工具</a></h6><p></p><h3 id="appium">Appium</h3><a href="#tags">点击此处回到Tags</a><p></p>
<h6 id="Appium-简明教程-持续更新"><a href="#Appium-简明教程-持续更新" class="headerlink" title=" Appium 简明教程 (持续更新)"></a><a href="https://testerhome.com/topics/1045" target="_blank" rel="external"> Appium 简明教程 (持续更新)</a></h6><h6 id="阿里云测Appium文档"><a href="#阿里云测Appium文档" class="headerlink" title="阿里云测Appium文档"></a><a href="https://mqc.aliyun.com/doc.htm?id=15" target="_blank" rel="external">阿里云测Appium文档</a></h6><h6 id="Appium官方Tutorial"><a href="#Appium官方Tutorial" class="headerlink" title="Appium官方Tutorial"></a><a href="http://appium.io/slate/en/tutorial/android.html?java#" target="_blank" rel="external">Appium官方Tutorial</a></h6><h6 id="Windows下部署Appium教程（Android-App自动化测试框架搭建）"><a href="#Windows下部署Appium教程（Android-App自动化测试框架搭建）" class="headerlink" title="Windows下部署Appium教程（Android App自动化测试框架搭建）"></a><a href="https://my.oschina.net/outcat/blog/491529" target="_blank" rel="external">Windows下部署Appium教程（Android App自动化测试框架搭建）</a></h6><h6 id="Appium常用方法介绍"><a href="#Appium常用方法介绍" class="headerlink" title="Appium常用方法介绍"></a><a href="http://blog.csdn.net/birdlee0524/article/details/52461347" target="_blank" rel="external">Appium常用方法介绍</a></h6><p></p><h3 id="kuangjia">框架</h3><a href="#tags">点击此处回到Tags</a><p></p>
<h6 id="Android通用流行框架大全"><a href="#Android通用流行框架大全" class="headerlink" title="Android通用流行框架大全"></a><a href="https://segmentfault.com/a/1190000005073746" target="_blank" rel="external">Android通用流行框架大全</a></h6><h6 id="Android开发常用开源框架推荐"><a href="#Android开发常用开源框架推荐" class="headerlink" title="Android开发常用开源框架推荐"></a><a href="http://www.jianshu.com/p/deb55cf2f0c1" target="_blank" rel="external">Android开发常用开源框架推荐</a></h6><h6 id="android-architecture-Google-官方推荐架构写法"><a href="#android-architecture-Google-官方推荐架构写法" class="headerlink" title="android-architecture(Google 官方推荐架构写法)"></a><a href="https://github.com/googlesamples/android-architecture/tree/master" target="_blank" rel="external">android-architecture(Google 官方推荐架构写法)</a></h6><h6 id="ButterKnife-view注入框架"><a href="#ButterKnife-view注入框架" class="headerlink" title="ButterKnife-view注入框架"></a><a href="http://stormzhang.com/openandroid/android/2014/01/12/android-butterknife/" target="_blank" rel="external">ButterKnife-view注入框架</a></h6><h6 id="LeakCanary-中文使用说明"><a href="#LeakCanary-中文使用说明" class="headerlink" title="LeakCanary 中文使用说明"></a><a href="https://www.liaohuqiu.net/cn/posts/leak-canary-read-me/" target="_blank" rel="external">LeakCanary 中文使用说明</a></h6><p></p><h3 id="mantan">技术漫谈</h3><a href="#tags">点击此处回到Tags</a><p></p>
<h6 id="Android学习之路-stormzhang"><a href="#Android学习之路-stormzhang" class="headerlink" title="Android学习之路 - stormzhang"></a><a href="http://stormzhang.com/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="external">Android学习之路 - stormzhang</a></h6><h6 id="假如时光能够倒流，-我会这么学习Java"><a href="#假如时光能够倒流，-我会这么学习Java" class="headerlink" title="假如时光能够倒流， 我会这么学习Java"></a><a href="http://mp.weixin.qq.com/s/3Yu-A_k-NznTGv-JTlDjRA" target="_blank" rel="external">假如时光能够倒流， 我会这么学习Java</a></h6><h6 id="如何自学Android编程？"><a href="#如何自学Android编程？" class="headerlink" title="如何自学Android编程？"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=402135493&amp;idx=1&amp;sn=c2e040f95551082cbe2bdf7182dc3e9f&amp;scene=21#wechat_redirect" target="_blank" rel="external">如何自学Android编程？</a></h6><h6 id="如何自学Android"><a href="#如何自学Android" class="headerlink" title="如何自学Android"></a><a href="https://segmentfault.com/a/1190000005059402" target="_blank" rel="external">如何自学Android</a></h6><h6 id="一个2年安卓开发者的一些忠告"><a href="#一个2年安卓开发者的一些忠告" class="headerlink" title="一个2年安卓开发者的一些忠告"></a><a href="http://jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/1006/6659.html" target="_blank" rel="external">一个2年安卓开发者的一些忠告</a></h6><h6 id="如何自学Android-技术文摘-LUPA开源社区"><a href="#如何自学Android-技术文摘-LUPA开源社区" class="headerlink" title="如何自学Android - 技术文摘 - LUPA开源社区"></a><a href="http://www.lupaworld.com/article-258258-1.html" target="_blank" rel="external">如何自学Android - 技术文摘 - LUPA开源社区</a></h6><h6 id="程序员之路-学习经验总结分享"><a href="#程序员之路-学习经验总结分享" class="headerlink" title="程序员之路-学习经验总结分享"></a><a href="http://blog.csdn.net/cjpx00008/article/details/55252916" target="_blank" rel="external">程序员之路-学习经验总结分享</a></h6><h6 id="关于Java-初学者需要知道的10件事"><a href="#关于Java-初学者需要知道的10件事" class="headerlink" title="关于Java 初学者需要知道的10件事"></a><a href="https://mp.weixin.qq.com/s/3nuEQP8Wz6MO7QSp2Xbp2A" target="_blank" rel="external">关于Java 初学者需要知道的10件事</a></h6><p></p><h3 id="qita">其他收集类GitHub地址</h3><a href="#tags">点击此处回到Tags</a><p></p>
<h6 id="Andriod-collect-blogs"><a href="#Andriod-collect-blogs" class="headerlink" title="Andriod-collect-blogs"></a><a href="https://github.com/ZQiang94/Andriod-collect-blogs" target="_blank" rel="external">Andriod-collect-blogs</a></h6><h6 id="Android开发资源汇总整理"><a href="#Android开发资源汇总整理" class="headerlink" title="Android开发资源汇总整理"></a><a href="https://github.com/MobDevGroup/AndroidDevelopmentTutorial" target="_blank" rel="external">Android开发资源汇总整理</a></h6><h6 id="Android-学习资料收集"><a href="#Android-学习资料收集" class="headerlink" title="Android 学习资料收集"></a><a href="https://github.com/Freelander/Android_Data" target="_blank" rel="external">Android 学习资料收集</a></h6><p><br>ikook<br>2017.02.21</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;收集在学习和提高技术过程中遇到的比较有价值的网站、文档、Blog 等，方便自己查阅。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术栈" scheme="http://ikookblog.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Android" scheme="http://ikookblog.com/tags/Android/"/>
    
      <category term="Git" scheme="http://ikookblog.com/tags/Git/"/>
    
      <category term="常用技术" scheme="http://ikookblog.com/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://ikookblog.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>我的 2016， 展望 2017</title>
    <link href="http://ikookblog.com/2017/01/07/old2016_new2017/"/>
    <id>http://ikookblog.com/2017/01/07/old2016_new2017/</id>
    <published>2017-01-06T16:00:00.000Z</published>
    <updated>2017-07-26T14:13:00.304Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016匆匆过去，2017仍在路上。</p>
</blockquote>
<a id="more"></a>
<h2 id="我的-2016"><a href="#我的-2016" class="headerlink" title="我的 2016"></a>我的 2016</h2><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>今年最大的收获莫过于此了，是 Android 让我真正走上技术这条路。虽说以后不一定绝对会走 Android，但它可以说是我技术路上的指明灯，让我真正爱上编程。我相信我会在 Android 路上越走越远，希望自己也可以为 Android 贡献一份力。开源的项目一个大特点就是所有程序员都可以参与到创作上，为这个项目献出一份力。</p>
<p>这一年可以说学习 Android 的时间最多，虽说这期间有很长一段时间有过间断。2015 年年末，基本上玩了一学期的我，突然兴致来袭，想要学习一下 java。所以就在网上找了套视频教程，一直到 2016 年年初，java 算是入门。2016 年上半年，也就是大一下学期，因为参加了学校的移动互联网大赛，要做一个 App，所以就接触到了 Android。由于自己学了 java， Android 入门起来还算顺利，我的入门书籍是郭神的《第一行代码》，可以说是这本书让我入了 Android 的门，期间关注了 stormzhang 的公号，也可以说是 stormzhang 让我热爱上了 Android。因为比赛，系统学习 Android 差不多有2个月的时间，期间都是靠自学，自己摸索，踩了很多坑，进步很慢。</p>
<p>后面因为其他事情停止了学习，暑假又因为比赛拾起 Android，齐鲁软件大赛。到作品完成差不多用了 20 天左右。之后，觉得自己应该好好的系统学习一下 Android 了，就系统学习了《Android 权威编程指南》一书，花了差不多也得20天左右。大二上学期自己就在网上看一些视频、博客来提高自己觉得薄弱的地方，期间也学了点别的东西。10月中旬左右学校通知有个全国软件测试大赛很有分量，所以就决定先放下 Android，来弄这个比赛，再加上期末考试，就到了现在。</p>
<p>从大一上学期漫无目的的玩，到大一下学期接触到 Android，再到大二上学期彻底被技术所吸引。这个过程可以说是幸运的，这对我未来的发展产生了很大的影响。</p>
<h3 id="我的侄子"><a href="#我的侄子" class="headerlink" title="我的侄子"></a>我的侄子</h3><p>这一年，对我一家来说很重要的事情就是：我的哥哥、嫂子有了儿子，我爸妈有了孙子，我有了侄子。这对我家产生了很大的影响，可以说是翻天覆地的。自从有了小侄子，我家的生活方式彻底变了个样，全家人都围着小侄子转，全家人的目光都投到了小侄子身上，家里多了更多的欢声笑语，在爸妈脸上可以看到更多幸福的目光、看到更多的笑容。</p>
<p>这无疑是很重要的，他的到来，使家庭更加和睦；使家庭有了更多的欢声笑语；使爸妈少了嘴上的争吵、多了一份欢笑和爱，对孙子的爱，也让我看到了他们对我的爱；使哥哥多了一份责任，家庭的重担，他不得不承担起来，孩子未来的发展，孩子生活的好与坏；使我多了一份成熟，让我感受到自己已不是那个陪在妈妈身边的孩子，而是一个大人，我应该成熟起来，为家庭贡献一份力，努力学习、工作。</p>
<p>昨日，农历腊月初九，侄子的生日，家里请了师傅，炖了个鸡，晚上一家人还吃了蛋糕，唯独我没有在家。哥哥发来照片，看到家里这样幸福美满，我倍感高兴，虽说自己不能陪在家人身边，孩子的陪伴能使他们幸福很好，我不在依然会美好。</p>
<p>侄子，他到来使我们的家庭有了质的变化，他到来使生活更加美好，使日子变得丰富，使家庭充斥欢笑。</p>
<p>望，侄子健健康康的成长。</p>
<h3 id="我的她"><a href="#我的她" class="headerlink" title="我的她"></a>我的她</h3><p>我们，这一年基本时刻都陪伴在彼此身边。我想世间最幸福的事莫过于此了吧，一起上课，一起吃饭，一起生活在一块，哈哈。今年，我们在一起已经三年了。这一年不易，我们争吵偏多，不过都从未想多放弃，依然坚守着彼此，这也许就是所谓的不离不弃吧。我为自己能拥有这样的感情、能拥有这样的伴侣感到自豪。</p>
<p>三年一路走来，从异地恋到一起奋战高考再到相守彼此身边。这一路走的真是崎岖，这三年我的生活发生了翻天覆地的变化，我在外打工，为了所谓的感情回到了校园，又为了所谓的感情一起奋斗到高考，我们上了同一所大学，虽说不是什么好大学，不过既然在一起就不要要求太多了，是吧，哈哈。是她，是我们的感情，让我相信了所谓的爱情。真的是很强大呦，哈哈，我在赤裸裸的秀恩爱，好吧，别打我。</p>
<p>这一年，由于自己搞技术较多，参加比赛之类的较多，导致自己没陪她多久，有时候甚至于一天也说不了多少话，这可能就是搞技术的坏处吧，一旦弄起来真的没时间。但她从来都没有半句怨言，很多时候都是陪我到深夜，实在困得不行才去睡。实在很对不起她，没有抽时间好好陪陪她，真是倍感愧疚。虽她嘴上说没事，但是女孩子谁又不想自己的男友多陪陪自己呢，说是无所谓那是假话，如果真的是无所谓，好吧，那就真无所谓了。</p>
<p>谢谢你的一路陪伴，让我陪感欣慰，16 年没能好好陪你，17 年定会规划出一定时间陪你玩耍。</p>
<h3 id="我的改变与感悟"><a href="#我的改变与感悟" class="headerlink" title="我的改变与感悟"></a>我的改变与感悟</h3><p>这一年虽说没什么大事发生，自己的技术也没什么大的发展，然而这一年来我仍有不少的改变与感悟</p>
<ul>
<li><strong>技术</strong><br><br>技术驱动生活质量，让我认识了技术的重要性，一个人有一技在身是多么重要。和自己的发展、生活质量有必然的关联性。<br>我认识了技术的重要性，这一年我最大的改变可以说就是在技术方面。<br><br></li>
<li><strong>认清自己</strong><br><br>没记错的话，stormzhang 在他的年终总结中也有提到过这一条。”人总是会额外的高看自己，取得点小小的成就就觉得自己很了不起，很容易被冲昏头脑，阻碍自己的判断力。” 这是他提到的，是的，人很容易就迷失自己，哪怕是小小的成就也会很容易的冲昏头脑。<br><br>记得我自己在学习 Android 过程中曾做出过点小小的小东西，但就是这点小东西让我觉得自己很牛逼，觉得自己的技术很牛逼之类的，其实并非这样。就是这点成就差点就让我迷失自我，停止在技术上的发展，止于眼前。之后我在网上接触的大牛越来越多，才知道天外有天，比自己厉害的人有的是，别人都还在学习，自己又有何颜面觉得自己牛逼。再加上北京之行，更加让我懂得了认清自己的重要性，世界很大，应该出去看看，找找差距。不要太过自信，太自信，容易变成自负。<br><br>自信是好的品质，但是不能过于自信，自信过火变自负，学会认清自己才能长久的发展。</li>
</ul>
<h2 id="展望2017"><a href="#展望2017" class="headerlink" title="展望2017"></a>展望2017</h2><p>16年，这一年的点点滴滴改变了我，我可以认为 16 年是自己的转折年，从无知到认知自己。来展望一下 17。</p>
<h3 id="学习方面"><a href="#学习方面" class="headerlink" title="学习方面"></a>学习方面</h3><ul>
<li><strong>继续 Android 之行</strong><br><br>自己的水平自己知道，我在 Android 方面欠缺的还太多了。一定要拿出时间来再系统的学习一下基础知识，然后就是进阶的知识，再就是做一些小东西，在实战中提高自己。阅读几本 Android 书籍，将书中程序认真弄明白，敲一遍。<br><br></li>
<li><strong>java</strong><br><br>java web、java ee。都要好好学，对自己的发展很重要，自己对后端还是很感兴趣的，将 java 这门语言学好，再去学习其他的语言也就会相对轻松许多，语言基本都是相通的。所以一定要把 java 学好。<br><br></li>
<li><strong>React Native</strong><br><br>学习一下跨平台移动开发工具 React Native（Android版）。感觉现在掌握一门跨平台技术挺重要的。所以接触接触，入门一下，学习一下。哈哈。<br><br></li>
<li><strong>英语</strong><br><br>我的英语水平真的是难以恭维，可以用一塌糊涂来形容，一点都不为过。上大学之前，我的英语水平是，除去26个字母别的东西啥也不会，真的，没有看错，就是这样。高考英语 40 多分，山东英语总分是 150。可以，完全是蒙的，当然，也偷看了别人几眼，哈哈。<br><br>由于接触了软件技术，接触了编程，所以自己不得不去接触英语了，也没有太刻意的去学习英语，编程学习过程中遇到不会的单词就去查，到现在也认识了一些单词，基本的差不多可以看懂了，我对象说我开窍了，哈哈。之前的水平太差了，不对，没有水平可言。所以 17 年一定要做的事情就是学习英语。每周至少 5 天都必须拿出 30 分钟以上的时间来学习英语。无论发生什么事，必须坚持下去！！！<br><br></li>
<li><strong>实习</strong><br><br>最好能够找个实习。可是前几天问老师实习情况的时候，得知，大三上学期不能够去企业实习，只能够企业培训或者在校做企业实习项目。真是苦逼，真心想找个实习锻炼下自己。到时候视情况而定，最好找机会去找个实习工作。锻炼下自己还是蛮不错的。<br><br></li>
<li><strong>阅读</strong><br><br>坚持阅读，自己的阅读时间太少，一般就是看看一些公号，17年要把入手的书籍好好看看，以后阅读养成“只字不差的阅读”习惯。对，就是这样。培养阅读习惯，这是很必要的，坚持。<br><br></li>
<li><strong>博客</strong><br><br>定期总结，技术、生活等。总结自己。让更多人认识自己，建立自己的品牌。<br><br>总结。每周都要有一次总结，周六或者周天对一周的生活和学习加以总结，比如一周收藏的技术文章等。每月总结，每年总结。恩，就是这样。入手了一本“趁早”效率手册，合理的规划时间，让时间看得见。<br><br>总结不一定非要博客形式，可以别的方式。但博客不能少，坚持写博客，坚持写作，提高自己的写作能力，一项很必要的技能。</li>
</ul>
<h3 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h3><ul>
<li><strong>多陪女友</strong><br><br>从大一下学期学习 Android 以后到现在基本没有抽时间好好陪陪她，觉得很不好。所以，17 年必须拿出一定时间来陪她耍。<br><br></li>
<li><strong>坚持锻炼</strong><br><br>每周至少 4 天拿出 30 分钟以上的时间锻炼身体。对近两年来自己的身体状况感到担忧，很少运动和出门，手机上的运动记录基本很少超过 1000 步，最少的时候居然只记录了几十步，当然和自己有没有拿手机有关，不过出门不拿手机的情况基本没有，所以这个数据还是可以参考的。so，要为了自己和未来的自己，锻炼身体必须提到日程上来了。<br><br></li>
<li><strong>社交</strong><br><br>多接触一些新的朋友，和朋友们多联系。上大学 1 年半了，感觉自己朋友越来越少，是因为时间都用来学习了吗？想想也没有。总之，和朋友们接触的很少。所以新的一年，一定要多交朋友，多和朋友们联系。人脉很重要，基本上一个人生存靠的就是人脉，不然基本没办法活下去。</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><h3 id="2017，希望以上打算都实现，希望自己在技术上有显著的进步，希望自己-17-年过的顺利。16-再见，17-你好。"><a href="#2017，希望以上打算都实现，希望自己在技术上有显著的进步，希望自己-17-年过的顺利。16-再见，17-你好。" class="headerlink" title="2017，希望以上打算都实现，希望自己在技术上有显著的进步，希望自己 17 年过的顺利。16 再见，17 你好。"></a><strong>2017，希望以上打算都实现，希望自己在技术上有显著的进步，希望自己 17 年过的顺利。16 再见，17 你好。</strong></h3><p><br>ikook<br>2017.01.07</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016匆匆过去，2017仍在路上。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔集" scheme="http://ikookblog.com/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
      <category term="随笔" scheme="http://ikookblog.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="http://ikookblog.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="感悟" scheme="http://ikookblog.com/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="年终总结" scheme="http://ikookblog.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>重建 Blog</title>
    <link href="http://ikookblog.com/2017/01/06/rebuild_blog/"/>
    <id>http://ikookblog.com/2017/01/06/rebuild_blog/</id>
    <published>2017-01-05T16:00:00.000Z</published>
    <updated>2017-06-03T16:58:16.337Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>重新搭建起个人blog：<a href="http://ikookblog.com">http://ikookblog.com</a></p>
</blockquote>
<a id="more"></a>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a><strong>起因</strong></h2><p>由于参加全国软件测试大赛，导致11月份和12月上半月没时间写博客，都在弄测试和被老师拉去辅导同学。比赛之后想要写篇博客记录下的，可是由于期间重装了笔记本系统，导致博客崩塌。只怪自己一时疏忽忘记备份配置文件。。让我哭会吧，只能重新折腾了。又由于要期末考试了，一学期基本没有上课、根本没听课的我，只能临时抱佛脚了。所以打算先放一放blog 的事，一心复习。</p>
<h2 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h2><p>恩，事情都有两面性。虽然由于自己的失误导致不得不重新折腾blog，但是如果没有这件事，好像自己会错过使用这么好的主题的机会，那就是—— Material。这个主题给我的第一印象就是好看，简洁，爽。简洁又不失个性。我自己本身对Google非常来感，对Google推出的设计语言Material Design情有独钟，MD给我的感觉就是比iOS好看的多。交互上的设计，视觉上的设计等，让我相信Android会发展的更好，Android程序员再也不用去想如何去做一个iOS风格的Android App了。</p>
<p>今天的主题不是Android，是Material，所以来说说<a href="https://material.viosey.com/" target="_blank" rel="external">Material</a>。该主题是由一位在校大学生写了，我只能说: 服！16年下半年才上线的吧，具体时间我也不清楚，好像是国庆节后。该主题遵循Material Design设计风格，并且非常简洁大方，又不失可观赏性。喜欢的可以加入到Material阵营了，目测该主题要火。GitHub地址为：<a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="external">hexo-theme-material</a>，作者博客地址: <a href="https://blog.viosey.com/" target="_blank" rel="external">Viosey’s Blog</a>。</p>
<h2 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a><strong>填坑</strong></h2><p>今天顺便把以前遗留的一个坑给填上了。GitHub上博客的仓库主页空荡荡，没有README。并且GitHub建议填写README。如果把README.md放入到 source 文件夹，<code>hexo g</code> 生成时会被解析成 html 文件，放到 public 文件夹，生成时又会自动删除。在GitHub添加时，在本地<code>hexo g -d</code>也会自动删除(删除的原因和以上说的一样)。</p>
<p>试了很多办法，查了好久，终于解决。</p>
<p>解决方法很简单，在 source 目录下新建文件<code>README.mdown</code>，在里面写README即可。<code>hexo g</code> 会把它复制到 public 文件夹，且不会被解析成 html。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h2><p>就写这么多，关于如何搭建blog，网上一搜一大些，教程多的数不过来。hexo官方文档也有说明，每个主题也都有相应说明。这里就不做这些无用功了。再说明一下，本人以前的主题是Next，该主题很好用，并且很简洁。</p>
<p><strong>推荐几篇较为完整的教程:</strong></p>
<ul>
<li><a href="https://note.leodev.me/2016/09/01/Hexo-3-1-1-Staic-Blog-Build-Guide/" target="_blank" rel="external">Hexo 3.1.1 静态博客搭建指南</a></li>
<li><a href="http://lijianchang.xyz/2016/03/16/%E5%B0%8F%E7%99%BD%E7%8B%AC%E7%AB%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-Github-Pages%E5%92%8CHexo%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/" target="_blank" rel="external">小白独立搭建博客-Github-Pages和Hexo简明教程</a></li>
<li><a href="http://dukecuichen.com/2016/04/08/%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6-GitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">基于Hexo框架+GitHub Pages搭建个人博客</a></li>
<li><a href="https://material.viosey.com/" target="_blank" rel="external">Material Theme官方文档</a></li>
</ul>
<p><br>ikook<br>2017.01.06</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;重新搭建起个人blog：&lt;a href=&quot;http://ikookblog.com&quot;&gt;http://ikookblog.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术栈" scheme="http://ikookblog.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="生活" scheme="http://ikookblog.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="常用技术" scheme="http://ikookblog.com/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="hexo" scheme="http://ikookblog.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Database 12c安装教程(Windows版)</title>
    <link href="http://ikookblog.com/2016/12/11/oracle_database12c/"/>
    <id>http://ikookblog.com/2016/12/11/oracle_database12c/</id>
    <published>2016-12-10T16:00:00.000Z</published>
    <updated>2017-07-24T10:54:29.557Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>自己在安装过程中踩了好多坑，记录一下。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p> 首先，要说的是为了安装Oracle Database我花费了大量的时间，在安装过程中出现了各种各样的问题。在此记录一下，以便自己总结并方便查询，同时也为各位广大朋友提供借鉴。</p>
<h1 id="Oracle数据库："><a href="#Oracle数据库：" class="headerlink" title="Oracle数据库："></a>Oracle数据库：</h1><p>Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是目前世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的 适应高吞吐量的数据库解决方案。</p>
<h1 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h1><ul>
<li><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>下载安装包：<br>首先下载Oracle Database 12c的Servers和Client压缩包到本地。这里只贴上win64位的连接地址。其他版本自行访问<a href="http://www.oracle.com/technetwork/cn/database/enterprise-edition/downloads/index.html" target="_blank" rel="external">Oracle Database 软件下载</a>进行下载。<br>Servers(服务器端)：<br><a href="http://120.52.72.22/download.oracle.com/c3pr90ntc0td/otn/nt/oracle12c/121020/winx64_12102_database_1of2.zip" target="_blank" rel="external">winx64_12102_database_1of2.zip</a><br><a href="http://download.oracle.com/otn/nt/oracle12c/121020/winx64_12102_database_2of2.zip?AuthParam=1481383491_65acf9e1231a462986564765ba630da3" target="_blank" rel="external">winx64_12102_database_2of2.zip</a><br>Client(客户端)：<br><a href="http://download.oracle.com/otn/nt/oracle12c/121020/winx64_12102_client.zip?AuthParam=1481383698_446c62928f2c93843bc7e18812ca548b" target="_blank" rel="external">winx64_12102_client.zip</a></li>
<li>解压下载好的两个压缩文件：<br>将两个压缩包解压到同一个目录下，即“database”；</li>
</ul>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2012773-16ca839eadf91a7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="datebase文件夹"></p>
<ul>
<li><h3 id="Servers安装"><a href="#Servers安装" class="headerlink" title="Servers安装"></a>Servers安装</h3><ul>
<li>以管理员的身份运行”setup.exe”进行安装：<br>软件会加载并初步校验系统是否可以达到了数据库安装的最低配置,如果达到要求,就会直接加载程序并进行下一步的安装;<br><img src="http://upload-images.jianshu.io/upload_images/2012773-7c3ba26b0fc19b29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>“配置安全更新”窗口：<br>取消“我希望通过My Oracle Support接受安全更新”，单击“下一步”；<br><img src="http://upload-images.jianshu.io/upload_images/2012773-8783c23dd97dbce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png">此时可能遇到的问题：在[INS-30131] 执行安装程序验证所需的初始设置失败<br><img src="http://upload-images.jianshu.io/upload_images/2012773-2848fabe61dfab99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>问题原因及解决办法：<br>1.问题：用户文件中含有中文（如你的账户名字包含汉字   C:\Users\张三）<br>解决办法：打开计算机管理——本地用户和组——用户——Administrator（右键属性）——账户已禁用（取消勾选）——确定<br><img src="http://upload-images.jianshu.io/upload_images/2012773-651503d9d35b1247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png">到此，就可以切换到Administrator用户，在Administrator用户下安装。<br>2.问题：未共享C盘<br>解决方法：打开计算机管理——共享文件夹——共享（右键“新建共享”）——下一步——（文件路径填）C:\——下一步——是——共享名C$——下一步——选中（“管理员有完全访问权限；其他管理员只有读写权限”）——完成——完成。由于大部分人都不是这个原因，这里就不上图了，并且网上有很多。</li>
<li>“安装选项”窗口<br>选择“创建和配置数据库”，单击“下一步”；<br><img src="http://upload-images.jianshu.io/upload_images/2012773-0a5d7ab1637c4660.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>选择”桌面类”还是”服务器类”<br>选择”服务器类”可以进行高级的配置,我这里选择”桌面类”,单击”下一步“，大多数情况下是选择“桌面类”，原因操作说明很清楚；<br><img src="http://upload-images.jianshu.io/upload_images/2012773-390df2805f16217c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>创建oracle管理用户<br>这步是其他版本没有的,这个的作用就可以更安全的管理orcl,主要是防止登录win系统勿删了oracle文件，这里选择第二个”创建新windows用户“，输入用户名和口令，专门管理oracle文件的，单击”下一步“；<br><img src="http://upload-images.jianshu.io/upload_images/2012773-18a8bd41b730faf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>“典型安装”窗口(安装位置)<br>选择Oracle的基目录，选择“企业版”和“默认值”并输入统一的密码为：Oracle12c，单击“下一步”;<br>注意：Oracle为了安全起见，要求密码强度比较高，你输入的密码Oracle认为不能复制,我试过了，即使简单的数字字母组合Oracle也认为是不符合).Oracle建议的标准密码组合为：小写字母+数字+大写字母，这回就合格了，当然字符长度还必须保持着Oracle 12c数据库要求的范围之内。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-4a0e32cb2db4f70d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>“执行先决条件检查”窗口<br>上一步设置好了后,将进行检查，在“执行先决条件检查”窗口中，单击“下一步”；<br><img src="http://upload-images.jianshu.io/upload_images/2012773-ee2ae5571f0627b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>上一步检查没有问题后<br>会生成安装设置概要信息,可以保持这些设置到本地,方便以后查阅,在这步确认后,单击”安装”,数据库通过这些配置将进行整个的安装过程:注意:在安装过程中,最好将杀毒软件,安全卫士什么的都强行关闭,安装成功后重启电脑就可以了.<br><img src="http://upload-images.jianshu.io/upload_images/2012773-e7178d16c6683d27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>安装过程中<br>这里是一个漫长的等待过程，切勿不小心关闭了程序，或者断电，电脑重启。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-1c081d7a0f3c3395.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>创建数据库实例<br>“Database Configuration Assistant”界面,特别的长时间等待，大约半个钟头，需耐心等待；<br><img src="http://upload-images.jianshu.io/upload_images/2012773-acd9874acd7b1aa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>数据库实例安装成功后，会弹出口令管理,进入口令管理<br>选择“口令管理”，查看并修改以下用户：<br><strong>（1）普通管理员：SYSTEM（密码：”自己填写”）</strong><br><strong>（2）超级管理员：SYS（密码：“自己填写”）</strong><br>修改完成后，单击“确定”。 这里的口令也是需要符合oracle口令规范的，参考前面设置数据库实例口令设置方式。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-cd57bd444b061435.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>安装完成<br>会出现如下界面，单击“关闭”即可。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-58b3b070a999930a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>至此Servers安装完毕。</li>
</ul>
</li>
<li><h3 id="Client安装："><a href="#Client安装：" class="headerlink" title="Client安装："></a>Client安装：</h3><p>Client安装非常简单，有了Servers的安装我相信Client肯定能自己装好，毕竟连我这么笨的人都装好了。因此就不再赘述了。<br>需要说明的是，在Servers安装中说到可能会遇到<strong>“在[INS-30131] 执行安装程序验证所需的初始设置失败”</strong>的问题，如果是第一种情况的话，Client也要使用Servers安装时的方法，在Administrator用户下安装。安装完成后再切换回原来用户模式下，再禁用Administrator即可。</p>
</li>
<li><h3 id="检查是否安装成功："><a href="#检查是否安装成功：" class="headerlink" title="检查是否安装成功："></a>检查是否安装成功：</h3><p>可在安装后软件中找到“SQL Plus”，后以管理员身份运行。<br>输入用户名和口令，在保证用户名和口令正确的情况下，查看是否连接，连接后输入select sysdate from dual;<br>打印出当前系统日期则说明安装完全成功。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-177e407f42a6c535.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
</li>
<li><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3>以上就是Oracle Database 12c windows64位安装教程。其中部分内容来自网络借鉴。</li>
</ul>
<p><br>ikook<br>2016.12.11</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;自己在安装过程中踩了好多坑，记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://ikookblog.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://ikookblog.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Oracle" scheme="http://ikookblog.com/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>感悟，16年12月6日</title>
    <link href="http://ikookblog.com/2016/12/06/16.12.6_gnosis/"/>
    <id>http://ikookblog.com/2016/12/06/16.12.6_gnosis/</id>
    <published>2016-12-05T16:00:00.000Z</published>
    <updated>2017-07-02T10:33:56.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li><h3 id="孤独是成长中不可缺少的调味"><a href="#孤独是成长中不可缺少的调味" class="headerlink" title="孤独是成长中不可缺少的调味"></a>孤独是成长中不可缺少的调味</h3><a id="more"></a></li>
<li><h3 id="再成功的人也会寂寞"><a href="#再成功的人也会寂寞" class="headerlink" title="再成功的人也会寂寞"></a>再成功的人也会寂寞</h3></li>
<li><h3 id="和家人在一起有时也会"><a href="#和家人在一起有时也会" class="headerlink" title="和家人在一起有时也会"></a>和家人在一起有时也会</h3></li>
<li><h3 id="孤独是自己的内心"><a href="#孤独是自己的内心" class="headerlink" title="孤独是自己的内心"></a>孤独是自己的内心</h3></li>
<li><h3 id="你想要什么？需要做什么？做什么的时候你找到自己？"><a href="#你想要什么？需要做什么？做什么的时候你找到自己？" class="headerlink" title="你想要什么？需要做什么？做什么的时候你找到自己？"></a>你想要什么？需要做什么？做什么的时候你找到自己？</h3></li>
<li><h3 id="能够全心全意的快乐，充实自己的内心和精神？"><a href="#能够全心全意的快乐，充实自己的内心和精神？" class="headerlink" title="能够全心全意的快乐，充实自己的内心和精神？"></a>能够全心全意的快乐，充实自己的内心和精神？</h3></li>
<li><h3 id="想清楚，觉得对就去做。"><a href="#想清楚，觉得对就去做。" class="headerlink" title="想清楚，觉得对就去做。"></a>想清楚，觉得对就去做。</h3></li>
<li><h3 id="不要气馁，不要放弃"><a href="#不要气馁，不要放弃" class="headerlink" title="不要气馁，不要放弃"></a>不要气馁，不要放弃</h3></li>
<li><h3 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h3></li>
</ul>
</blockquote>
<p><br></p>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=41653795&auto=1&height=66"></iframe> <br> <center> 间奏很美 </center></p>
<p><br>ikook<br>2016.12.06</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;孤独是成长中不可缺少的调味&quot;&gt;&lt;a href=&quot;#孤独是成长中不可缺少的调味&quot; class=&quot;headerlink&quot; title=&quot;孤独是成长中不可缺少的调味&quot;&gt;&lt;/a&gt;孤独是成长中不可缺少的调味&lt;/h3&gt;
    
    </summary>
    
      <category term="随笔集" scheme="http://ikookblog.com/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
      <category term="随笔" scheme="http://ikookblog.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="http://ikookblog.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="感悟" scheme="http://ikookblog.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Git 学习总结</title>
    <link href="http://ikookblog.com/2016/10/15/git_learn/"/>
    <id>http://ikookblog.com/2016/10/15/git_learn/</id>
    <published>2016-10-14T16:00:00.000Z</published>
    <updated>2017-06-03T16:37:33.522Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Git是什么？ Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p>
</blockquote>
<a id="more"></a>
<p>作为一个开发者，git这样的技能基本上是必备技能了。以前的时候接触了git，但没有系统的学习，只是简单的了解几个基本命令。最近几天系统的学习了这样技能。由于git教程网上很多，我就不重复造轮子了，有的轮子要造，但有的轮子造起来没有多大意义，所以只是总结一下学习的心得和git常用的命令。</p>
<h2 id="git是什么？"><a href="#git是什么？" class="headerlink" title="git是什么？"></a>git是什么？</h2><ul>
<li>Git是目前世界上最先进的分布式版本控制系统，是由Linux 发明者 Linus 开发的一款新时代的版本控制系统。</li>
<li>那什么是版本控制系统呢？<ul>
<li>网络定义：版本控制（Revision control）是维护工程蓝图的标准作法，能追踪工程蓝图从诞生一直到定案的过程。此外，版本控制也是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编辑的同一代码文件案都得到同步。是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</li>
<li>简单来讲，版本控制系统就是在开发过程中对我们的代码进行管理的系统。比如：为了防止代码的丢失，我们会把本地和服务器都放置一份或者多份，这时候版本控制系统就可以使本地和远程同步； 在多人协作完成一个项目时，我们需要对一份代码进行更改和管理，这时候不影响别人工作就可以同步别人的代码；代码出现bug，对代码进行紧急的管理或者还原等等。</li>
</ul>
</li>
</ul>
<h2 id="git的安装"><a href="#git的安装" class="headerlink" title="git的安装"></a>git的安装</h2><p>git是一个版本控制系统，所以我们必须下载安装才能使用。mac系统是自带Git的，为了照顾特殊情况，这里也介绍一下。</p>
<ul>
<li><strong>Linux</strong><br>首先，你可以输入git，查看一下系统有没有安装Git：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git</div><div class="line">The program &apos;git&apos; is currently not installed. You can install it by typing:</div><div class="line">sudo apt-get install git</div></pre></td></tr></table></figure>
</li>
</ul>
<p>很多Linux会友好地告诉你Git没有安装，并且会告诉你如何安装Git。<br>通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install git</div><div class="line">Reading package lists... Done</div><div class="line">Building dependency tree</div><div class="line">Reading state information... Done</div><div class="line">The following extra package will</div><div class="line">be installed:</div><div class="line"> git-man liberror-perl</div><div class="line">Suggested package:</div><div class="line">...</div><div class="line">...</div><div class="line">Setting up liberror-perl (0.17-1) ...</div><div class="line">Setting up git-man (1:1.7.9.5-1) ...</div><div class="line">Setting up git (1:1.7.9.5-1) ...</div></pre></td></tr></table></figure></p>
<p>看到类似上面的命令则说明安装成功。<br>通过命令<code>git --version</code>查看版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git --version</div><div class="line">git version 2.8.1.windows.1</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>Mac OS X</strong><br>两种安装方式。<ul>
<li>安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/" target="_blank" rel="external">http://brew.sh/</a></li>
<li>从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</li>
</ul>
</li>
<li><strong>Windows</strong><br>Windows系统是默认没有安装git，也没有内置git安装包的。需要手动下载安装。访问下载git安装包：<a href="https://git-for-windows.github.io/" target="_blank" rel="external">https://git-for-windows.github.io/</a>。下载完成后默认安装即可（可以修改一下安装路径）。<br>安装完成，在开始菜单里找到“Git”-&gt;“Git Bash”打开，出现一个类似命令行窗口的软件，就说明Git安装成功。</li>
</ul>
<p>安装完成后，还需要最后一步设置，在命令行输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;Your Name&quot;</div><div class="line">$ git config --global user.email &quot;email@example.com&quot;</div></pre></td></tr></table></figure></p>
<h2 id="Git命令总结"><a href="#Git命令总结" class="headerlink" title="Git命令总结"></a>Git命令总结</h2><ul>
<li><p><strong>常用操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">git init：初始化一个仓库。</div><div class="line">git add &lt;file&gt;：把文件添加到仓库。(注意：是添加到仓库，需要执行提交操作才能把文件放到仓库。本操作实际上就是把文件修改添加到暂存区)</div><div class="line">git commit : 把文件提交到仓库。</div><div class="line">git status：查看工作区的状态。</div><div class="line">git diff：查看修改的内容</div><div class="line">git log：查看日志</div><div class="line">git log --pretty=oneline：查看排版的日志</div><div class="line">git reset --hard commit_id：回退到以前的版本。Git中用HEAD表示当前版本，上一版本为HEAD^，上上版本为HEAD^^，假如为往上100版本，则可表示为：HEAD~100。</div><div class="line">git reflog：查看命令历史。可用来确定要回到未来的哪个版本。</div><div class="line">git reset HAED file：把暂存区的修改撤销掉，重新放回工作区。</div><div class="line">git checkout -- file：丢弃工作区的修改。git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</div><div class="line">git rm file：删除一个文件。</div></pre></td></tr></table></figure>
</li>
<li><p><strong>远程操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@github.com:GitHubName/repo-name.git：关联一个GitHub远程库。通用结构：git remote add origin git@server-name：path/repo-name.git。</div><div class="line">git push -u origin master：第一次向远程库推送master分支的所有内容。</div><div class="line">git push origin master：向远程库推送最新修改。</div><div class="line">git pull：抓取远程的新提交，保持本地和远程同步。</div><div class="line">git pull origin master：把master分支的最新状态抓取到本地。</div><div class="line">git remote -v：查看远程库信息。</div><div class="line">git clone git@github.com:GitHubName/repo-name.git：将github项目clone到本地，被clone的项目将作为远程库。</div><div class="line">git checkout -b branch-name origin/branch-name：在本地创建和远程分支对应的分支，名称最好一致。</div><div class="line">git branch --set-upstream branch-name origin/branch-name：建立本地分支和远程分支的关联。</div><div class="line">git push origin &lt;tagname&gt;：推送某个标签到远程。</div><div class="line">git push origin --tags：一次性推送全部尚未推送到远程的本地标签。</div><div class="line">git push origin：refs/tags/&lt;tagname&gt;：删除远程标签。(先删除本地的标签)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>分支操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git branch：查看所有分支</div><div class="line">git branch &lt;name&gt;：创建分支</div><div class="line">git checkout &lt;neme&gt;：切换分支</div><div class="line">git checkout -b &lt;name&gt;：创建+切换分支</div><div class="line">git merge &lt;name&gt;：合并某个分支都当前分支</div><div class="line">git branch -d &lt;name&gt;：删除分支</div><div class="line">git merge --no-ff -m &quot;描述&quot; &lt;name&gt;：记录分支情况的合并分支方法。</div></pre></td></tr></table></figure>
</li>
<li><p><strong>stash操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git stash：储藏当前工作状态</div><div class="line">git stash list：查看储藏的工作列表。</div><div class="line">git stash apply：恢复工作状态，但恢复后stash的内容并不删除。</div><div class="line">git stash drop：删除最近一次stash的内容</div><div class="line">git stash clear：清空所有的stash内容。</div><div class="line">git stash pop：恢复工作状态并删除相关stash内容。</div></pre></td></tr></table></figure>
</li>
<li><p><strong>标签操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git tag &lt;name&gt;：新建一个标签。</div><div class="line">git tag -a &lt;tagname&gt; -m &quot;描述&quot;：新建标签并指定标签信息。</div><div class="line">git tag -s &lt;tagname&gt; -m &quot;描述&quot;：PGP签名标签。4</div><div class="line">git tag：查看所有标签。</div><div class="line">git tag -d &lt;tagname&gt;：删除一个本地标签。</div><div class="line">git push origin &lt;tagname&gt;：推送某个标签到远程。</div><div class="line">git push origin --tags：一次性推送全部尚未推送到远程的本地标签。</div><div class="line">git push origin :refs/tags/&lt;tagname&gt;：删除远程标签。(先删除本地的标签)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这只是Git常用的命令。Git极其强大，命令繁多，我只是总结了一些较为常用的命令。</p>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><ul>
<li><p>我们学习了 Git 之后，怎么才能充分使用这项技能呢？<br>答案是 GitHub。GitHub 是世界上最大的开源社区。我相信程序员没有不知道 GitHub 的了。学习 GitHub 同样是程序员的必备技能。当然，Git 并不只是在 GitHub 上使用。我们在工作以后团队之间的合作、代码的管理基本上都是使用 Git。</p>
</li>
<li><p>那么，Git 与 GitHub 之间有什么联系呢？</p>
<ul>
<li>Git 是一款免费、开源的分布式版本控制系统。不管是学习 GitHub，还是以后想从事编程行业，Git都可以算是必备技能了。</li>
<li>GitHub 主要提供基于Git的版本托管服务。也就是说现在 GitHub 上托管的所有项目代码都是基于 Git 来进行版本控制的，所以 Git 只是 GitHub 上用来管理项目的一个工具而已，GitHub 的功能远不止于此。所以建议去学习一下 GitHub。</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过两天的系统学习，对Git有了初步的了解。Git的功能非常强大，在本文中只是罗列出了一些常用命令。Git绝不是两天就可以掌握的，但是可以学会Git的基本使用。常用的Git命令本文基本涵盖，并且工作中常用的命令就那么十几条，掌握好这十几条命令，就基本可以得心应手的使用Git。</p>
<ul>
<li><p><strong>Git学习资料</strong></p>
<ul>
<li>廖雪峰的Git教程：<br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a><br>本人就是通过廖雪峰前辈的教程学习的Git。</li>
<li>ProGit中文版：<br><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">https://git-scm.com/book/zh/v2</a></li>
<li>Git简易指南：<br><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">http://rogerdudler.github.io/git-guide/index.zh.html</a></li>
</ul>
</li>
<li><p><strong>GitHub学习资料</strong><br>这里只附上 stormzhang 张哥的教程。别的GitHub教程我还真没有学习过，但是网上很多，查一下就ok。<br>GitHub系列教程：<br><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661735&amp;idx=1&amp;sn=9aceac07d272e9202d1b5294f857a5ff&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「初识 GitHub」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661762&amp;idx=1&amp;sn=8282241cf7414030f4e1d315a173beb1&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「加入 GitHub」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661788&amp;idx=1&amp;sn=b7c54f9b13f4e30fe151905f11c02800&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「Git速成」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661821&amp;idx=1&amp;sn=c6116ed82bff2d083bb152fbd8cbc38d&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「向GitHub 提交代码」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661929&amp;idx=1&amp;sn=69e00516a30723c5a20af3c7a84173a4&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「Git 进阶」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661978&amp;idx=1&amp;sn=2f5329f5b2bfda7050822cc5e3a4f03f&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「团队合作利器 Branch」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650662079&amp;idx=1&amp;sn=65605f0d9bd741d38f0b179980dc09f1&amp;scene=21#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「如何发现优秀的开源项目」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650662303&amp;idx=1&amp;sn=3df7cba7cd85b33a82b4c05bb12cfff5&amp;chksm=87d138c0b0a6b1d6140da9bab6e58c6e2b258de6118175d31c1ac467b3c58bc1a7c0b1a7db9b&amp;scene=0#wechat_redirect" target="_blank" rel="external">从0开始学习 GitHub 系列之「GitHub 常见的几种操作」</a></p>
</li>
</ul>
<p><br>ikook<br>2016.10.15</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Git是什么？ Git是目前世界上最先进的分布式版本控制系统（没有之一）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术栈" scheme="http://ikookblog.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Git" scheme="http://ikookblog.com/tags/Git/"/>
    
      <category term="常用技术" scheme="http://ikookblog.com/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2016MDCC移动开发者大会总结</title>
    <link href="http://ikookblog.com/2016/09/27/2016mdcc/"/>
    <id>http://ikookblog.com/2016/09/27/2016mdcc/</id>
    <published>2016-09-26T16:00:00.000Z</published>
    <updated>2017-06-03T16:32:19.558Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>托stormzhang张哥洪福，有幸参加MDCC大会。收获颇多，总结一番。</p>
</blockquote>
<a id="more"></a>
<h4 id="2016-11-11更："><a href="#2016-11-11更：" class="headerlink" title="2016.11.11更："></a>2016.11.11更：</h4><p> 之前参加大会后视频没有马上放出来，所以今天给大家分享一下。本来以为参加会议之后视频很快就会出来的，没有想到出来的有点慢。不过，肯定比我分享出来的要早很多。因为这段时间学习的问题，所有时间不算很充裕，更新的有点迟了，抱歉。这也算是双十一的福利吧，哈哈。<br>说明一下，MDCC大会上分享经验的都是一些大牛，视频没有前后顺序之分，都值得一看。由于不知道的原因，Android开发者峰会的视频并没有全都放出来。我知道的都在这儿了。<br>Android开发者峰会：<a href="http://edu.csdn.net/course/detail/3103" target="_blank" rel="external">微信 Tinker 热补丁实践演进之路</a><br>Android开发者峰会：<a href="http://edu.csdn.net/course/detail/3104" target="_blank" rel="external">Fresco - loading images fast</a><br>Android开发者峰会：<a href="http://edu.csdn.net/course/detail/3108" target="_blank" rel="external">Android应用性能优化经验分享</a><br>Android开发者峰会：<a href="http://edu.csdn.net/course/detail/3094" target="_blank" rel="external">滴滴国际化 Android 端演进</a></p>
<p>   ======================================我是华丽的分割线===================================</p>
<h3 id="9月22日，凌晨。托stormzhang张哥的洪福，有幸去参加2016MDCC移动开发者大会。在此特别感谢张哥，不然怎么可能有这样的机会去参加如此高逼格的会议啊。"><a href="#9月22日，凌晨。托stormzhang张哥的洪福，有幸去参加2016MDCC移动开发者大会。在此特别感谢张哥，不然怎么可能有这样的机会去参加如此高逼格的会议啊。" class="headerlink" title="9月22日，凌晨。托stormzhang张哥的洪福，有幸去参加2016MDCC移动开发者大会。在此特别感谢张哥，不然怎么可能有这样的机会去参加如此高逼格的会议啊。"></a>9月22日，凌晨。托stormzhang张哥的洪福，有幸去参加2016MDCC移动开发者大会。在此特别感谢张哥，不然怎么可能有这样的机会去参加如此高逼格的会议啊。</h3><h3 id="因为路途遥远，要提前一天踏上旅程。"><a href="#因为路途遥远，要提前一天踏上旅程。" class="headerlink" title="因为路途遥远，要提前一天踏上旅程。"></a>因为路途遥远，要提前一天踏上旅程。</h3><h3 id="9月23日，上午全体大会。"><a href="#9月23日，上午全体大会。" class="headerlink" title="9月23日，上午全体大会。"></a>9月23日，上午全体大会。</h3><p>分别由CSDN&amp;极客帮创始人——<em>蒋涛</em>、微软亚洲研究院院长——<em>刘振</em>、京东技术副总裁——<em>赵一鸿</em>、图灵机器人CEO——<em>俞志晨</em>、360智能家居总裁、360车联网CEO——<em>邓邱伟</em>演讲，有幸见到各大科技公司的领军人物甚是激动。下面大体讲解一下他们各自的议题，不做深入讨论，主要还是要讨论Android开发峰会。</p>
<ul>
<li><h4 id="从移动时代走向-AIR-智能时代——蒋涛"><a href="#从移动时代走向-AIR-智能时代——蒋涛" class="headerlink" title="从移动时代走向 AIR 智能时代——蒋涛"></a>从移动时代走向 AIR 智能时代——<em>蒋涛</em></h4>未来十年产业将进入 AIR 时代，即人工智能、IoT、AR时代。A时代的标志是AlphaGo，深度学习已彻底改变了图像识别领域；I时代的标志是软银收购ARM，2015年人均芯片拥有量为2颗，十年后将达到人均100颗；R时代的标志是PokeMon Go，且VR头显的销售会逐年呈指数式增长。</li>
<li><h4 id="智能应用的普及化——刘震"><a href="#智能应用的普及化——刘震" class="headerlink" title="智能应用的普及化——刘震"></a>智能应用的普及化——<em>刘震</em></h4>介绍在大数据的时代，分析已经成为商业成功的一个关键推动点。深厚的数学知识是人工智能的基础，海量的数据是建立良好模型的关键，然而这些构建分析所必需的条件却是大多数开发者所缺乏的。基于机器学习的人工智能和基于语境的人机交互已变为可能，刘震也结合微软认知服务的实际案例，从计算机视觉API、人脸识别API、情绪识别API、语言理解智能服务等方面多方位角度进行解读。<br>详情请访问：<a href="http://geek.csdn.net/news/detail/103401" target="_blank" rel="external">微软亚洲工程院院长刘震：智能应用的普及化</a></li>
<li><h4 id="移动时代的大数据电商技术探索与实践——赵一鸿"><a href="#移动时代的大数据电商技术探索与实践——赵一鸿" class="headerlink" title="移动时代的大数据电商技术探索与实践——赵一鸿"></a>移动时代的大数据电商技术探索与实践——<em>赵一鸿</em></h4>移动端的普及提升了碎片化时间的利用率，在家电、母婴、体育、超市方面京东移动的渗透率已近80%。这一背景下，数据的价值体现在洞察、决策、挖掘、开放，利用大数据去设计买点成为了重点。用户画像如何从静态变为动态，实现变化，是大数据的基本特点。他以“智能卖场”的例子从应用层面展示了动态数据的价值，通过京东大脑对用户行为、商品属性等大数据的挖掘，产生用户及商品画像，完成推荐预测，实现个性化选品和排序，能够有效地提升点击率和订单转化率，同时缩短用户购买路径。演讲主要围绕以下三个方面探讨：移动互联网对电商企业的挑战，移动电商的发展潜力，以及移动时代电商大数据的价值。<br>详情请访问：<a href="http://geek.csdn.net/news/detail/103490" target="_blank" rel="external">京东集团技术副总裁赵一鸿：移动时代的大数据电商技术探索与实践</a></li>
<li><h4 id="智能机器人开发关键技术——俞志晨"><a href="#智能机器人开发关键技术——俞志晨" class="headerlink" title="智能机器人开发关键技术——俞志晨"></a>智能机器人开发关键技术——<em>俞志晨</em></h4>他把智能机器人定义为：外在硬件载体＋人工智能系统和应用。他指出机器人操作层、感知层、认知层分别对应人的四肢、五官和大脑的概念。今天，智能机器人产业硬件所需要的投入要大于软件，只有产生优秀的硬件载体软件才能有意义，这涉及到各位传感器和控制单元，但这一天屏正在慢慢开始平衡。</li>
<li><h4 id="智能硬件设计及关键实现技术——邓邱伟"><a href="#智能硬件设计及关键实现技术——邓邱伟" class="headerlink" title="智能硬件设计及关键实现技术——邓邱伟"></a>智能硬件设计及关键实现技术——<em>邓邱伟</em></h4><p>他认为现在智能硬件行业整体呈高速增长状态，2015年达到300%，巨头从各个链条进入布局；而产品现状仍处于初期，缺乏联通，资本快速进入押宝智能家居；人工智能应用实用性大幅提升；在服务上，线上渠道仍为主要购买途径，而第三方服务尚却未大规模介入产业链。<br>详情请访问：<a href="http://geek.csdn.net/news/detail/103552" target="_blank" rel="external">360智能家居总裁、360车联网CEO邓邱伟：智能硬件设计及关键实现技术</a><br>以上就是全体大会的大体内容了。</p>
<h4 id="下午的技术专场说起来就有点遗憾了。"><a href="#下午的技术专场说起来就有点遗憾了。" class="headerlink" title="下午的技术专场说起来就有点遗憾了。"></a>下午的技术专场说起来就有点遗憾了。</h4><p><strong>本人对新鲜事物比较好奇，尤其是好玩的东西，听起来比较高大上的东西。比如人工智能、深度学习。由于上午各位大佬们的演讲太过于精彩，让我对人工智能提起来很大的兴趣，有一种想要立马研究一下的冲动。所以就决定先放弃预先安排的去跨平台专场，而去人工智能与机器人专场听听。因为之前没有接触过人工智能，所以听起来简直比上高数课还难受，根本不知道说的什么，因为比较感兴趣所以想继续试着听下去。听了很久之后觉悟到还是去跨平台吧，那时候离下午专场的结束还有不到一个小时的时间。真是蛮遗憾的。</strong></p>
<p>  附上跨平台技术专场的PPT及Demo，大家自行研究。<br><a href="https://github.com/MDCC2016/Cross-Platform-Session" target="_blank" rel="external">MDCC 2016跨平台开发专场的演讲 PPT 以及 Demo</a></p>
</li>
</ul>
<h3 id="9月24日，终于到了拭目以待的Android开发峰会了，此次峰会可谓大神云集，往届肯定也是，不过我没有参加也没有关注，毕竟是才走入正途。"><a href="#9月24日，终于到了拭目以待的Android开发峰会了，此次峰会可谓大神云集，往届肯定也是，不过我没有参加也没有关注，毕竟是才走入正途。" class="headerlink" title="9月24日，终于到了拭目以待的Android开发峰会了，此次峰会可谓大神云集，往届肯定也是，不过我没有参加也没有关注，毕竟是才走入正途。"></a>9月24日，终于到了拭目以待的Android开发峰会了，此次峰会可谓大神云集，往届肯定也是，不过我没有参加也没有关注，毕竟是才走入正途。</h3><h4 id="先附上一张议题和演讲嘉宾的表格："><a href="#先附上一张议题和演讲嘉宾的表格：" class="headerlink" title="先附上一张议题和演讲嘉宾的表格："></a><strong>先附上一张议题和演讲嘉宾的表格</strong>：</h4><p><img src="http://oe94sy64u.bkt.clouddn.com/%5DY%603%6008GY%7D3%7B%7D%29240F2T%29CP.png" alt=""><br><br><strong>有必要重点说明的是这次Android会场的主持人是<em>秋百万（廖祜秋）</em>前辈。</strong> 他在主持的同时也讲解了不少东西，实在佩服<em>秋百万</em>前辈</p>
<ul>
<li><h2 id="滴滴国际化Android端演进——吴更新"><a href="#滴滴国际化Android端演进——吴更新" class="headerlink" title="滴滴国际化Android端演进——吴更新"></a>滴滴国际化Android端演进——<em>吴更新</em></h2><h3 id="1-国家化技术上的特殊性"><a href="#1-国家化技术上的特殊性" class="headerlink" title="1.国家化技术上的特殊性"></a>1.国家化技术上的特殊性</h3><ul>
<li><strong>地图</strong><br>  地图选型、地图切换。国内用户使用国外地图服务的限制。</li>
<li><strong>网络</strong><br>   网络的限制。由于大家众所周知的原因，国外的很多服务国内用户是不可用的，墙的原因导致漫游网络不可用， 所以         国际化面临的技术问题还是很多的。</li>
<li><strong>运力来源</strong><br>   运力的来源问题。需要与其他国家合作来提供司机，在国内只需要司机注册就可以使用，而在国外需要和其他国家的合作伙伴做接入。</li>
</ul>
<h3 id="2-地图（地图选型、地图切换）"><a href="#2-地图（地图选型、地图切换）" class="headerlink" title="2.地图（地图选型、地图切换）"></a>2.地图（地图选型、地图切换）</h3><ul>
<li><strong>地图选型</strong><br>考虑的方面很全面。主要在功能与需求，数据源，技术支持力度，性能，用户，包大小，demo和文档等方面。选取了Bing、Tomtom、Here、Nutiteq、Mapbox作为研究对象。综合分析来看Mapbox是最合适的。<br>分析如下图：<br><img src="http://upload-images.jianshu.io/upload_images/2012773-c44a8ed88be3712e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li><strong>地图切换</strong><br>选型可能无法通用，随意切换。对地图切换来说，关键是要有一套自己的抽象，再对应具体的实现搞一个Adapter就行。<br>好处：解耦、通用、学习成本低<br><img src="http://upload-images.jianshu.io/upload_images/2012773-3761c0ebb6ea8894.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-078b38896820811e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>问题：Api规范、适配所有的Api、标尺（如：缩放尺度、经纬度）、未支持API<br>解决方案：<br>1.主要按照Google Map的API为标准来做标准的API、对用到Mapbox的API做完全的适配<br>2.先对初始版本的API做完整的适配，后面再对其他版本做竞争<br>3.要保持地图的缩放级别是保持不变的，以国际的标尺为准。<br>4.debug 版本抛出异常 crash，release 版本打 log。</li>
</ul>
<h3 id="3-漫游网络"><a href="#3-漫游网络" class="headerlink" title="3.漫游网络"></a>3.漫游网络</h3><p>滴滴主要服务的是国内用户去国外的情况。地图服务器是 不在AWS上面的。所以主要有海外运营商、用户依然使用国内版本的app在海外漫游的情况。主要讨论用户在海外漫游的情况。<br>国内用户在国外漫游访问国外服务器慢。<br>漫游网络，运营商，aws……<br>用户在国外访问网络的简单流程：<br>先访问海外运营商，通过海外运营商访问国内运营商，再去访问web。由于墙的存在一般用户是访问不到网络的。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-ab05e9f46b6ba0ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在国外访问网络的简单流程"><br>为了解决这个问题使用了通过国内运营商去访问公网，通过公网访问AWS上的服务器。这种访问方式是比较慢的。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-15b3771ea233eaed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过访问公网来获取数据"><br>为了解决访问慢的缺陷，做了网络优化。在去访问AWS的时候在中间加一个中转服务器来实现专线访问<br><img src="http://upload-images.jianshu.io/upload_images/2012773-53a46ac92f4c5301.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="专线访问"><br>对于客户端来说，访问专线网络时大概会有三步：<br>1.拉取中转服务器域名列表<br>2.对于漫游用户访问中转服务器<br>3.一定时机及推送更新域名列表<br><strong>这样做速度大概会比之前快一倍。</strong></p>
<h3 id="4-项目演进"><a href="#4-项目演进" class="headerlink" title="4.项目演进"></a>4.项目演进</h3><ul>
<li>问题<br>1.按照包名划分，仍会存在大量的耦合。<br>2.由于不同国家业务不同的原因等，添加新业务不便。<ul>
<li>解决方案<br>分SDK和业务模块，但都作为独立的Module，最后再整合成一个apk。</li>
</ul>
</li>
<li>实现技术<br>单项目依赖：按照SDK和业务模块拆分成单独的项目，单项目依赖单独的SDK。之后再整合到成一个SDK，聚合成整个的工程，再实现SDK分层。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-a1ec2a6fd51eed17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单项目依赖"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-086d0db69a9f193d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整个工程"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-7f0ae68ccffd609a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDK分层"><br>使用模块划分的原则：单一、开闭原则，依赖关系，拓展规范，避免重复依赖。<br>好处：解耦，并行开发、测试，组件单独测试。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-ba43909e9fd7686b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-d400d31faa9f08dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><h3 id="5-现场问答"><a href="#5-现场问答" class="headerlink" title="5.现场问答"></a>5.现场问答</h3><strong>问题：Integrated Project怎么个打包法？Lyft、GradTaxi这些合并吗？还是它们会被打包成独立的apk？<br>回答：所有的module都是输出aar，最后一个整合成滴滴app。</strong><br>我讲解的可能是比较乱，同时可能也不怎么清晰，因为我自身理解的也是不怎么深刻。Piasy的视频连接：<a href="https://share.yoloyolo.tv/bcs/1224531?sign=ccab65bdcd9d4f36269aefb249d85666&amp;group_id=272492" target="_blank" rel="external">滴滴国际化 Android 端演进（包括冯老师分享的开头）</a> 有时间可以自行观看。</li>
</ul>
</li>
<li><h2 id="回归初心，从容器化到组件化——冯森林"><a href="#回归初心，从容器化到组件化——冯森林" class="headerlink" title="回归初心，从容器化到组件化——冯森林"></a>回归初心，从容器化到组件化——<em>冯森林</em></h2><p>近年来插件化，module化的原因，已经不再像过去那样，庞大的软件，改一行代码，测试，耗费开发人员较长时间（虽然我没有亲身体验过以前开发的难度，但是可想而知）。组件化作为独立模块，协同开发时，可以提供release版本进行集成。平时，只须在自己的dev分支上进行开发。大大提高开发效率。各模块之间解耦，当然这其中也面临相关的问题，如大量的反射方式。各rom厂商对系统的改动，就很容易产生各种问题。何俊林在会上请教了apk与apk数据之间如何共享的问题。冯老师建议可用contentprovider。建议在项目的早期做拆分，避免后期组件化的抽离困难。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-5eafa557d71c20b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><strong>以我现在的能力是很难听懂冯老师这个分享的，或者说我完全听不懂这个分享。是的，完全没有听懂。<br>还是分享一下别人的理解吧。</strong></p>
<h5 id="Piasy"><a href="#Piasy" class="headerlink" title="Piasy"></a><strong>Piasy</strong></h5><p>原文链接：<a href="http://mp.weixin.qq.com/s?__biz=MzAxMjM0OTA3Nw==&amp;mid=2650203819&amp;idx=1&amp;sn=1e5a7a2ae8195d5e85b0918a96916526&amp;chksm=83b17d51b4c6f447ca4a15dc82c872a1c902c635230aee1455d63086fd435da4ba451684eda4" target="_blank" rel="external">MDCC 参会纪要</a><br>【大公司的方案，不一定符合小公司<br>模块化，从硬件，系统到软件<br>APP 的模块化</p>
<ul>
<li>隔离各个模块</li>
<li>特性：独立，可替换，可互操作</li>
<li>代价：解耦，契约，兼容性</li>
<li>从第一天开始坚持解耦，为中长期打好基础</li>
<li>独立并行开发测试，高效，快速</li>
<li>灵活的集成，发布，升级</li>
<li>64k问题</li>
<li>选择性安装，非常轻量</li>
<li>hybrid友好，web native 可切换</li>
<li>高度可扩展</li>
<li>包隔离，最简单，太宽松</li>
<li>gradle library module 隔离，有很好的工具链，构建效率低</li>
<li>多 apk，构建、安装更高效，用户体验差</li>
<li>multidex，工具链支持，弱</li>
<li>容器 droid plugin，hook 和代理，兼容性问题</li>
<li>半容器，直接合并，但需要类加载支持，轻量，兼容性好</li>
<li>activity 作为入口，提前准备好，后续开发都是 fragment。</li>
<li>activity 用 url 启动</li>
<li>禁止状态共享</li>
<li>……】这是Piasy大神的分享。</li>
</ul>
<p><strong>我自己的理解是把一个项目隔离出各个模块，使分离出的模块成为独立的、可替换的、维护性强的小项目。这样做的带来好处是解耦、兼容性、可维护性。从一开始项目就做好项目的分离工作，使其解耦，为以后打好基础。</strong></p>
<h5 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a><strong>组件化</strong></h5><ul>
<li><strong>特性</strong><br>1.独立性<br>2.可替换性<br>3.互操作性</li>
<li><strong>成本</strong><br>1.解耦<br>2.契约<br>3.兼容性</li>
<li><strong>收益</strong><br>1.强制建立一个解耦<br>2.模块的独立性<br>3.组件粒度的测试<br>4.灵活的测试<br>5.组件粒度的升级<br>6.混合开发性平滑地过渡</li>
<li><strong>基础解决方案</strong><br>1.Java package name<br>2.Gradle Library modules<br>3.multiple App<br><img src="http://upload-images.jianshu.io/upload_images/2012773-2746602090672c8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>进一步解决方案<br>1.multi-Dex<br>2.Container<br>3.semi-Container<br><img src="http://upload-images.jianshu.io/upload_images/2012773-b377b13b4f577e9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>由于我自己能力的限制，不能讲解清楚，所以附上Piasy的视频连接：<a href="https://share.yoloyolo.tv/bcs/1224573?sign=4358a1148993c705e4e896cd5b912c5f&amp;group_id=272492" target="_blank" rel="external">回归初心，从容器化到组件化</a></li>
</ul>
</li>
<li><h2 id="云信-IM-推送保障及网络优化实践——周江华"><a href="#云信-IM-推送保障及网络优化实践——周江华" class="headerlink" title="云信 IM 推送保障及网络优化实践——周江华"></a>云信 IM 推送保障及网络优化实践——<em>周江华</em></h2><p>现在IM应用范围很广泛，人与人要通过网络交流就离不开IM，可以说现在大多数的应用都有IM。<br>比如：社交、电商、教育、医疗等…</p>
<ul>
<li><h5 id="IM是什么"><a href="#IM是什么" class="headerlink" title="IM是什么"></a><strong>IM是什么</strong></h5><strong>Instant：</strong>有新消息能立即收到，消息推送无延迟<br><strong>Messaging：</strong>稳定可靠，安全，消息不丢，不乱，不重复</li>
<li><h5 id="怎么推"><a href="#怎么推" class="headerlink" title="怎么推"></a><strong>怎么推</strong></h5>后台运行。答案就是后台运行。</li>
<li><h5 id="LMK"><a href="#LMK" class="headerlink" title="LMK"></a>LMK</h5>需解决的问题：内存占用、进程优先级<br>方案：<br>1.Sticky Service、Alarm、Receiver、JobSchedule<br>2.建立多进程、双进程。避免使用单进程。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-4c6f75f8c49fc3d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>SDK架构的设计<br><img src="http://upload-images.jianshu.io/upload_images/2012773-74eefa2c727b4d48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li><h5 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h5>云信IM SDK使用的连接类型有：TCP，UDP，HTTP。<br>TCP实现长连接，UDP实现一个需要加密处理的连接，HTTP实现收发文件等。<br>在复杂的Android生态环境下，多种因素都会造成消息推送不能及时达到客户端。另外，不稳定的移动网络也给数据传输的速率和可靠性增加了障碍。演讲从这两个方面出发，讲述了云信IM SDK如何实现不影响用户体验的后台保活，改善的长连接加推送组合方案，以及在弱网环境大数据传输的优化实践。<br>关于进程怎么在后台活，目前较好的解决方案包括：长连接+推送，系统推送（MIUI、华为为代表）。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-cd8414ff29ae9d80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="长连接+推送"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-844fda5ae816e914.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="长连接+推送优化"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-2d9b7564a1fb6096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统优化"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-217c6ed098dcc2a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统推送优化"><br>而关于如何活好（主要问题是慢、断、贵），解决办法包括协议选择；<br>协议选择使用二进制的协议，牺牲了可读性换来的是包非常非常的小，同时拓展性也是比较好的。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-c3fd0163b302beba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="协议选择"><br>登录加速（长连接中经常使用，步骤包括Lbs、Connect、Handshake、Login，Sync；优化思路为：尽量减少交互步骤，尽可能并行步骤）；<br>使用TCP的连接方式。<br>通过减少交互的步骤，尽可能的使用并行步骤来实现登录的加速。连接和LBS并行、捂手和登录并行。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-a4ca94323a854376.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登录加速"><br>UDP优化（常用于音视频服务，对弱网环境更敏感，优化包括：FEC，自适应初始化包频，动态包频和码率调整，数据缓冲Buffer，音频PLC丢包补偿，Temporal Scalability视频编码，以及视频关键帧多重保障）；<br><img src="http://upload-images.jianshu.io/upload_images/2012773-2e939cdb103a1c8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实时音视频优化"><br>HTTP优化（断点续传，图片预加载，pipeline，边录边传）。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-55918f9227a792d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件传输优化"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-4214715e3990cbf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pipeline优化"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-ff80c9e30e044af9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="边录边传"><br>周江华老师讲的还是比较清晰，内容比较丰富的，基本涵盖了IM开发所要主要的问题。由于我自身能力的限制，理解的还是比较浅显的。附上Piasy的视频连接：<a href="https://share.yoloyolo.tv/bcs/1224631?sign=4b126eaf9de530cd39095e676b5933c6&amp;group_id=272492" target="_blank" rel="external">【云信 IM 推送保障及网络优化实践上】</a><a href="https://share.yoloyolo.tv/bcs/1224642?sign=b2cbf4d2bf962aeb8502de27aa8da70b&amp;group_id=272492" target="_blank" rel="external">【云信 IM 推送保障及网络优化实践下】</a></li>
</ul>
</li>
<li><h2 id="微信Tinker热补丁实践演进之路——张绍文"><a href="#微信Tinker热补丁实践演进之路——张绍文" class="headerlink" title="微信Tinker热补丁实践演进之路——张绍文"></a><strong>微信Tinker热补丁实践演进之路</strong>——<em>张绍文</em></h2><h5 id="总体说明："><a href="#总体说明：" class="headerlink" title="总体说明："></a>总体说明：</h5><ul>
<li>这场分享听的还是比较激动的，因为亲眼见证了大腾讯开源的第一个项目。真的是很激动，开源标志着我们可以阅读源码，可以清楚的理解其框架的内部实现，真的太帮了。Tinker的开源标志着腾讯走上了开源之路，各大BAT都在走向开源。真的是拥抱开源拥抱未来啊。</li>
<li>近半年很热的hot fix技术，走过坑是在art平台，dalvik平台的差异，让全量合成技术面临挑战，最后借鉴studio install run的原理及市场实际情况，发展到目前的阶段。</li>
<li>Tinker是微信Android团队推出的开源热补丁框架，在MDCC现场，张绍文点击GitHub上的项目“公开”按钮——Tinker宣布开源！ 它可以帮助应用快速获得动态更新能力。演讲首先介绍Tinker项目的演进历程，重点分析在开发过程中遇到的问题（曾经遇到了启动耗时警报，Dex格式异常复杂）以及解决方案。然后剖析Tinker框架的核心架构设计，讲述Tinker是如何保证一致性、安全性、稳定性、高性能等关键问题。最后结合热补丁在微信的应用与实践，分享如何使用Tinker快速动态部署。目前热补丁有两大流派，Native（AndFix、KKFix）和Java。微信设计的目标是：稳定性于兼容性、性能、易用。1.0版三天成功率达到96.3%，启动耗时下降31%，补丁包大小为500KB。2.0版本（2016年2月）基于全量合并方式，Diff算法（设计目标为Diff结果小，占用内存小，合成速度快），其他技术挑战还包括Android N、Xposed、Classloader、DexDiff等。张绍文说，也许有人觉得Tinker过于臃肿，过于复杂。这是因为热补丁并不是仅仅加载一个dex或so文件，事实上它要关心的细节有很多。进程的一致性，控制可修改类的范围，版本的管理，扩展性等等。微信未来的开源计划，都以高可用为核心，除了Tinker，还有Mars和MMDB。</li>
<li>减小安装大小，对特定有问题的用户推送补丁包，获取调试信息。技术是用来解决问题的，明确需求：稳定兼容，性能，易用。</li>
<li>什么是热补丁：可以让应用无需重新安装下能够自动更新。</li>
</ul>
<h5 id="具体说明："><a href="#具体说明：" class="headerlink" title="具体说明："></a><strong>具体说明：</strong></h5><ul>
<li>热补丁两大流派：<br>1.Native：AndFix、KKFix<br>2.Java： Qzone、nuwa、rocooFix、Tinker、amigo、 robust</li>
<li>微信的设计目标<br>“高可用”的补丁框架：<br>1.稳定性与兼容性：微信数亿用户的设备上稳定运行；<br>2.性能：非补丁版本影响补丁大小；<br>3.易用性：简单易用，完整支持。</li>
<li><h4 id="1-0-小试牛刀"><a href="#1-0-小试牛刀" class="headerlink" title="1.0 小试牛刀"></a>1.0 小试牛刀</h4>基于 classloader 的方案<br>preverify 问题，内存地址错乱，性能差，补丁包大<br><img src="http://upload-images.jianshu.io/upload_images/2012773-849d6c64a126aba7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="classloader方案"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-e447316488cd51c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="V1.0-结果"></li>
<li><h4 id="2-0-自创功法"><a href="#2-0-自创功法" class="headerlink" title="2.0 自创功法"></a>2.0 自创功法</h4><ol>
<li><strong>基于全量合并方式：</strong><br>Gradle Instant run<br>Buck exopackage</li>
<li><strong>Diff算法：</strong><br>BsDiff<br>DexMerge<br>DexDiff</li>
<li><p><strong>Diff设计目标：</strong><br>Diff结果小<br>占用内存小、合成速度快<br>支持新增、删除、修改class</p>
<h5 id="Dex格式：直接上图。"><a href="#Dex格式：直接上图。" class="headerlink" title="Dex格式：直接上图。"></a>Dex格式：直接上图。</h5><p><img src="http://upload-images.jianshu.io/upload_images/2012773-9d06ac95b5b9a43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dex格式"></p>
<h5 id="Diff方案："><a href="#Diff方案：" class="headerlink" title="Diff方案："></a>Diff方案：</h5><p><img src="http://upload-images.jianshu.io/upload_images/2012773-44d2b4fabcf095d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Diff方案"></p>
<ul>
<li>anr，dex 太大，分平台合成 dex，art 上合成小 dex<br><img src="http://upload-images.jianshu.io/upload_images/2012773-e5e1f2db372b1eb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="挑战"></li>
<li>illegal access。</li>
<li>性能好，兼容性和稳定性差<br><img src="http://upload-images.jianshu.io/upload_images/2012773-6147a23d4516f87d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="V2.0-结果"></li>
</ul>
</li>
</ol>
</li>
<li><h4 id="3-0-修炼内功"><a href="#3-0-修炼内功" class="headerlink" title="3.0 修炼内功"></a>3.0 修炼内功</h4><p>主要在异常熔断、监控回调、安全、一致性、合成、加载方面进行优化。比较不容易理解，上图。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-510c6200ff06f9a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="V3.0目标"></p>
<ul>
<li><strong>异常熔断</strong><br><img src="http://upload-images.jianshu.io/upload_images/2012773-144a543d41fae809.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常熔断"></li>
<li><strong>监控回调</strong><br><img src="http://upload-images.jianshu.io/upload_images/2012773-b08c807869752db9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="监控回调"></li>
<li><strong>一致性</strong><br><img src="http://upload-images.jianshu.io/upload_images/2012773-476760b52384ac20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一致性"></li>
<li><strong>加载与合成</strong><br><img src="http://upload-images.jianshu.io/upload_images/2012773-8ff84938d77a850d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加载与合成"><h5 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h5><img src="http://upload-images.jianshu.io/upload_images/2012773-5e782390b02540f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="V3.0-结果"></li>
</ul>
</li>
<li><h4 id="4-0-内外兼修"><a href="#4-0-内外兼修" class="headerlink" title="4.0 内外兼修"></a>4.0 内外兼修</h4><p>提升易用性和稳定性</p>
<ul>
<li><h5 id="Library处理"><a href="#Library处理" class="headerlink" title="Library处理"></a><strong>Library处理</strong></h5>核心问题：<br>1.多API获取不准确，反射出问题<br>2.32位与64位问题<br>尽量少的hook：<br>1.LoadLibraryFromTinker(“assets/86”，“stloprt_shared”)；<br>2.LoadLibrary(“stlport_shared”);</li>
<li><h5 id="资源处理"><a href="#资源处理" class="headerlink" title="资源处理"></a><strong>资源处理</strong></h5>预埋entry count：<br>1.编译强耦合<br>2.影响基础版本<br>3.无法随心所欲<br>全量替换<br>1.Atlas或者携程的插件化框架<br>2.Gradle-instant run</li>
<li><h5 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a><strong>异常情况</strong></h5>Transition动画：ResID无法新增、删除，可能出现Res not found<br>Notification：ResID无法新增、删除，可能出现Res not found<br>ShortcutResID无法新增、删除，可能会变成默认图标<br>Assets：读取 source apk方式无法修改</li>
<li><h5 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a><strong>资源问题</strong></h5>直接上图<br><img src="http://upload-images.jianshu.io/upload_images/2012773-e21993d4ded447c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="资源包生成"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-a744c40f4884db98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="资源处理-资源包生成"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-efa404f2e9e048d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="资源处理-资源包校验"></li>
<li><h5 id="编译目标"><a href="#编译目标" class="headerlink" title="编译目标"></a><strong>编译目标</strong></h5>简单易用：<br>1.只要输入一个旧的基础包，即可生成补丁包<br>2.proguard<br>3.mainDex<br>4.日志与校验<br>灵活控制<br>1.可通过pattern灵活控制需要的内容<br>2.版本控制<br>减少补丁包<br>1.applyMapping<br>2.appyResourceMapping<br>3.force jumbo<br>4.7zip<br>…</li>
<li><h5 id="V4-0结果"><a href="#V4-0结果" class="headerlink" title="V4.0结果"></a><strong>V4.0结果</strong></h5><img src="http://upload-images.jianshu.io/upload_images/2012773-d2c3655a58ad2f8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="V4.0-结果"></li>
</ul>
<p><strong>微信开源计划</strong>：<a href="https://github.com/Tencent/tinker" target="_blank" rel="external">Tinker开源地址</a><br><strong>同样附上Piasy视频网址</strong>：<a href="https://share.yoloyolo.tv/bcs/1224654?sign=8459ca748f9dc1508a920880f2acaaf1&amp;group_id=272492" target="_blank" rel="external">微信Tinker热补丁实践演进之路</a><br><strong>YouTube上Jacks录制的网址</strong>：<a href="https://www.youtube.com/playlist?list=PLmUDvA65lNp28eLBicTEt9oOdpdnGBl9O" target="_blank" rel="external">微信 Tinker 热补丁实践演进之路——张绍文</a><br><strong>微信开发团队公号：</strong><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286384&amp;idx=1&amp;sn=f1aff31d6a567674759be476bcd12549&amp;scene=0#wechat_redirect" target="_blank" rel="external">微信开发团队公号</a> (详细介绍可点击链接，非常详细的介绍，基本是按照演讲的时候介绍思路进行的)</p>
<p><strong>方案选择，最重要的依据还是我们的需求，回到初心。</strong></p>
</li>
</ul>
</li>
<li><h2 id="Fresco-loading-images-fast——王洁（Jie-Wang）"><a href="#Fresco-loading-images-fast——王洁（Jie-Wang）" class="headerlink" title="Fresco - loading images fast——王洁（Jie Wang）"></a><strong>Fresco - loading images fast</strong>——<em>王洁（Jie Wang）</em></h2><ul>
<li>我对这个框架所知甚少，在参加MDCC之前没有听说过，更别说用了。打算近期对这个Fresco图片处理框架研究一番。</li>
<li>Fresco一个目前为止非常好用的或者说是最好用的加载图片、显示图片的框架。Fresco（单词的中文含义是湿壁画）是运用于Android设备的图片加载组件，使用了Fresco就可以不必烦恼图片的加载、显示这种繁琐的问题。Fresco中设计有Image Pipeline模块。它负责从网络、从本地文件系统、本地资源加载图片。为了最大限度节省空间和CPU时间，它含有3级缓存设计（2级内存，1级磁盘）。Fresco中的Drawees模块，会在图片加载完成前显示占位图，加载成功后自动替换为目标图片。当图片不再显示在屏幕上时，会及时释放内存和空间占用。解压后的图片，即Android中的Bitmap，占用大量的内存。大的内存占用势必引发更加频繁的GC。在5.0以下，GC将会显著地引发界面卡顿。在5.0以下系统，Fresco将图片放到一个特别的内存区域。当然，在图片不显示的时候，占用的内存会自动被释放。这会使得APP更加流畅，减少因图片内存占用而引发的OOM。Fresco在低端机器上表现一样出色，再也不用因图片内存占用而思前想后。未来Fresco的目标包括：更小的库和.so，令Image Pipeline插件化等</li>
<li><strong>这里引用一段<em>秋百万</em>前辈的一点简单点评</strong><br>【王洁同学中文已经没有她的英文流利了，:)。作为 Fresco 文档的译者，也反复看了源码，以为对 Fresco 已   经足够了解了。还是补了好多知识。<br>对于不能 wrap_content 的事情，如何做到提前知道图片的宽高，我现在的做法是把宽高信息放到 uri 中。】</li>
<li>这里再次引用别人的点评和理解——<em>何俊林</em>前辈<br>【分想了fresco一些思想及实现，主要用到了匿名共享内存Ashmem ，在native层处理，减少在java层内存的处理问题。现场有人提问，如果都来申请这样一个匿名共享内存，会不会导致机器很卡，等。这个Ashmem实际上是直接站在巨人的肩膀（Linux 共享内存机制）上的，对于Android基于Linux系统，各个app都是一个process，当然一个app也有可能多个process,共享内存的创建（open）、映射（mmap）、读写（read/write）以及锁定和解锁（pin/unpin）四个使用情景.详细了解Ashmem可以参考：<a href="http://blog.chinaunix.net/uid-20321537-id-3482938.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20321537-id-3482938.html</a>。另一个问题是说fresco用Drawee的问题，提问的小伙伴说他们之前都是用ImageView，现在切fresco，发现Drawee不是继承ImageView，王洁告知在起初定用Drawee,就不会把Drawee继承ImageView，我觉得应该有相应的解决方案吧，毕竟那么多人都在用fresco。哈哈】</li>
<li>附上几张图，我本人英文惨不忍睹，基本翻译不出来。所以直接上图。（当然为了更好的理解<em>王洁</em>前辈所分析的干货，我私下会想办法翻译理解的，各位自行解决，有利无害）<br><img src="http://upload-images.jianshu.io/upload_images/2012773-a3758a416a6fb635.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-518a180fc267c3a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-1bcb7dd2d233efb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-ccef804cdacc3560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-8d4accebb4559ce9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-49f3a86acb0efb01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-0ffc24affa3fb034.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li><strong>抱歉，别找了，没视频。官方视频没出来之前别指望找到了，静等官方视频吧，不过官方也不一定会放出来。</strong></li>
<li>我只有PPT，<a href="https://github.com/MDCC2016/Android-Session-Slides/blob/master/05-Fresco-loading-image-faster.pdf" target="_blank" rel="external">05-Fresco-loading-image-faster.pdf</a><br>其余的全部会在文末放上。<br>其中包括：<br>[01-滴滴国际化 Android 端演进.pdf]<br>[02-From.Containerization.To.Modularity.pdf]<br>[03-云信 IM 推送保障及网络优化实践.pptx]<br>[04-微信 Tinker 热补丁实践演进之路.pdf]<br>[05-Fresco-loading-image-faster.pdf]<br>[06-如何开发一款优雅的 SDK.pptx]<br>[09-Android应用性能优化经验分享-张明云.pdf]</li>
</ul>
</li>
<li><h2 id="如何开发一款优雅的-SDK？——吕观祥"><a href="#如何开发一款优雅的-SDK？——吕观祥" class="headerlink" title="如何开发一款优雅的 SDK？——吕观祥"></a><strong>如何开发一款优雅的 SDK？</strong>——<em>吕观祥</em></h2><ul>
<li><em>吕观祥</em>前辈的分享是完全围绕着其公司的SDK产品来讲的。从SDK的设计到内核架构，讲解的比较全面。不过个人觉得，讲的有点高大上了，都是去寻求干货的，讲点技术比较实际。内核就没有必要拿出这么长的时间来讲解了，毕竟内部的东西不是一两句就能讲清楚的。</li>
<li>用当下的MVC,MVP等设计一个SDK。现场提问，是说这么多渠道和客户，如何管理分支问题。SDK打包及升级不同客户，确实都是很实在的问题。这个实际上是可以做一些渠道的标识的。不同的客户和厂商。在发版可以记录。build不同的sdk，脚本也是可以做到的。</li>
<li>个推推送数亿SDK独立设备上稳定运行多年的经验为切口，从SDK的开发、集成、发布等多方面深挖SDK与APP开发的不同之处，从架构、接口设计、兼容性等多维度来阐述如何开发一款优雅的SDK，使其满足易用、稳定、灵活等特点。吕观祥认为SDK的设计要点包括：开发方面需要接入简单，可自解释，可定制，防止误用；接口设计要周全考虑生命周期和异常处理；兼容性则考虑Android API、ROM版本，so版本，SDK版本；安全性要考虑本地和通信数据安全（HTTPS ECDHE-AES-GCM）；性能指标（电量、流量、内存、包大小）。发布方面，则需要实现灰度发布，补货Crash趋势和详情。发布包管理方面，需要包含日志更新，Sample工程代码等。其他还需要关注的有：第三方jar包，低污染（及时清理运行过程中创建的临时文件），以及全平台支持（Cocos2dx、Unity3D等）。</li>
<li><em>秋百万</em>前辈的简单点评：开发，CI，测试三个方面，尤其 CI 方面的介绍，如果目前还没 CI 的团队，可以立刻按照这个配备搭建一个了。</li>
<li>还是说以我目前的能力理解的不怎么样，或者说根本没怎么听懂。所以大家自行学习，我也会继续学习。</li>
<li>附几张图，体会一下。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-edd56a1410e3f0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="架构设计——APP"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-10700761e486b1ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="架构设计——SDK"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-a8e8b95185ef0d08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CI"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-55705f22463eff1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发布"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-a4bca0b1e08220de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="其他"></li>
<li>继续学习才能深入理解</li>
</ul>
</li>
<li><h2 id="打造可信赖的-Android-设备-ID-——杨玉奇"><a href="#打造可信赖的-Android-设备-ID-——杨玉奇" class="headerlink" title="打造可信赖的 Android 设备 ID ——杨玉奇"></a><strong>打造可信赖的 Android 设备 ID</strong> ——<em>杨玉奇</em></h2><ul>
<li>什么都不想说了。</li>
<li>还是说一句吧。不然憋得慌。少一点广告多一点真诚啊。</li>
<li>技术人搞什么推销呢，打起广告来没玩啊，全场刮台风。根本找不到自我。</li>
<li>这里要有<em>秋百万</em>前辈的点评：Slide 做得不错，台风也不错。嗯。我觉得<em>秋百万</em>前辈也是比较无语啊。</li>
<li>还是要来点有用的。</li>
<li>改IEMI、MAC，刷浏览、留存广泛存在，传统Android设备ID标识已经无法应对无孔不入的造假手段，推广效果难以评估。他认为，Android设备需要一个新的、可信赖的ID，而这种ID需要有四种特性：唯一（有统一维护中心），可校验（确保ID可靠），安全防伪造（防伪策略需要多重动态可调整），高可用（处理能力强）。数盟这套系统的平台架构分为五部分：系统应用层，消息枢纽层（Kafka+ZooKeeper），数据统计层，数据存储层，以及监控管理层。</li>
</ul>
</li>
<li><h2 id="Android-中-Native-的内存泄露检测-——德胜（季丹）"><a href="#Android-中-Native-的内存泄露检测-——德胜（季丹）" class="headerlink" title="Android 中 Native 的内存泄露检测 ——德胜（季丹）"></a><strong>Android 中 Native 的内存泄露检测</strong> ——<em>德胜（季丹）</em></h2><ul>
<li>ANMAT是阿里Android团队内部使用的一套检查C++的crash和内存泄露的框架。它可以帮助开发者快速找到Native中Crash和内存泄露的函数栈。演讲首先介绍是关于ANMAT的演进历程，重点分析在开发过程中遇到的问题以及方法的提炼，然后剖析ANMAT架构的核心架构设计，最后结合ANMAT的解决思路，分享项目过程中的最佳实践。</li>
<li>阿里这位前辈的演讲使我听过的最快的演讲了，我感觉还没开始就结束了。:).</li>
<li>内存泄露问题后面的明云前辈也有讲解，所以这里就不赘述了。</li>
<li>其实想要赘述也没得说，根本没听懂，也还没开始听就结束了。</li>
<li>当我没说。</li>
</ul>
</li>
<li><h2 id="Android应用性能优化经验分享——张明云"><a href="#Android应用性能优化经验分享——张明云" class="headerlink" title="Android应用性能优化经验分享——张明云"></a><strong>Android应用性能优化经验分享</strong>——<em>张明云</em></h2><ul>
<li>与普通开发者不同，张明云所在公司的产品优化是针对整个平台，而非单个应用。他从产品经理和开发人员的视角，分别就性能优化的必要性、性能优化的工具和方法以及性能问题的改善方案做详细介绍。张明云举了一个例子：他们团队发现手机在静置的情况下，一晚会掉电20%，研究发现原因包括：60%的应用，启动时间超过2秒，SDK使用不合理，在系统回调或频繁调用代码块中创建新的实例，几乎所有App都存在过度绘制，Activity和Window都设置了背景，json库使用不合理导致Launcher卡顿严重，近10个应用监听开启广播，应用内存占用不合理，系统SDK导致内存泄漏，非静态内部类导致内存泄漏，四大组件的Context和Application Contex使用不合理，I/O操作完成后没有关闭文件。关于性能优化，张明云给出了需要遵循的原则和指标，并推荐了几款强大的工具——ASinpectCode、ASPerfarmance Monitor。</li>
<li>应用性能状况<ol>
<li>约60%应用冷启动时间超过2s<br>对应用的启动速度进行优化，尤其是冷启动。控制应用的冷启动时间在一个合理的时间内</li>
<li>SDK的不合理使用（基础类型和装箱类型、HashMap、SparseArray）<br>SDK的不合理使用是造成应用性能欠佳很重要的原因。要注意合理使用基础类型和装箱类型、HashMap、SparseArray等</li>
<li>在系统回调或频繁调用的代码块中创建新的实例<br>对应用的代码进行合理的解耦，减低应用的耦合性是避免在系统回调或频繁调用的代码块中创建新实例的关  键。频繁的创建新实例导致应用的包过大，同时在运行阶段导致应用大量占用系统内存。导致应用的性能下降</li>
<li>几乎所有APP都存在过度绘制问题，Activity和Window都设置了背景<br>APP的过度绘制问题，同样会导致占用应用性能下降，对用户的体验造成很大的影响。例如Activity和Window都设置了背景。</li>
<li>json库的不合理使用，导致 Launcher严重卡顿<br>json库类的不合理使用，导致应用运行严重卡顿。要用好json库并不容易，要在合理的时机使用json，避免滥用json库</li>
<li>近10个应用监听开机广播，导致开机后一段时间内Launcher严重卡顿<br>关闭不需要的应用开机广播。过多的应用同时监听开机广播，会导致开机后一段时间内的应用运行严重卡顿。尽可能的避免应用开机广播</li>
<li>应用内存占用不合理（适配不规范、缓存不合理、回收不及时）<br>不合理的内存占用。对不用的实例及时回收，避免不合理的缓存，规范的适配api</li>
<li>系统SDK导致的内存泄露（InputMethodManager、WebView，<strong>AndroidExcludedRefs.java</strong>）<br>合理设计SDK架构。避免SDK导致内存泄露</li>
<li>非静态内部类导致的内存泄漏（ Handler、Observer、 AsyncTask）<br>合理使用Handle、AsyncTask等非静态内部类。避免导致内存泄露</li>
<li>四大组件的Context和Application Context的不合理使用<br>四大组件的Context和Application Context的不合理使用。优先使用四大组件的Context。合理使用Application Context</li>
<li>IO操作后没有关闭文件（ Cursor、TypedArray、File等）<br>尤其注意Cursor。Cursor使用不合理导致文件重复读写。</li>
<li>功耗问题明显（循环动画、过度绘制、网络请求不合理、后台服务常驻等）<br>循环动画、过度绘制、网络请求不合理、后台服务常驻问题是造成功耗大的主要原因。要注意。</li>
</ol>
</li>
<li><p>性能优化</p>
<ol>
<li>性能优化流程<br>发现问题（性能检测工具）——&gt;定位问题（性能检测工具）——&gt;改善问题（性能优化方法）——&gt;验证问题（性能检测工具）</li>
<li>性能优化原则<ul>
<li>不能凭感觉，要看数据说话，有足够多的测量</li>
<li>尽量使用低配置设备进行测试</li>
<li>权衡利弊，以保证进度、稳定为主</li>
<li>改善后一定要验证，保证每一次改善都有效，不会导致其他的问题</li>
</ul>
</li>
<li>性能优化指标<br>在指标、现象、原因、检测工具几个方面讨论，上图。<br><img src="http://upload-images.jianshu.io/upload_images/2012773-43c5da319ff4558d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="性能优化指标"></li>
<li>性能优化工具<ul>
<li>AS Inspect Code<br><img src="http://upload-images.jianshu.io/upload_images/2012773-c7764e0ab3f80332.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AS Inspect Code"></li>
<li>AS Performance Monitor<br><img src="http://upload-images.jianshu.io/upload_images/2012773-864f7fa249433163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AS Performance Monitor"></li>
<li>AS Date Analysis<br><img src="http://upload-images.jianshu.io/upload_images/2012773-ba8ee8af305529bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AS Date Analysis"></li>
<li>开发者选项<ul>
<li>过度描绘<br><img src="http://upload-images.jianshu.io/upload_images/2012773-e9f6d8b2048032b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开发者选项——过度描绘"></li>
<li>GPU呈现模式分析<br><img src="http://upload-images.jianshu.io/upload_images/2012773-825c6dff01519725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开发者选项——GPU呈现模式分析"></li>
</ul>
</li>
<li>StrictMode<br><img src="http://upload-images.jianshu.io/upload_images/2012773-4d62fbfecdd52281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="StrictMode"></li>
<li>TraceView<br><img src="http://upload-images.jianshu.io/upload_images/2012773-cbe5b9f8366bbc66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TraceView"></li>
<li>方法耗时打印Hugo<br><img src="http://upload-images.jianshu.io/upload_images/2012773-5fb591d37e69549e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法耗时打印"></li>
<li>布局性能查看 Hierarcher Viewer<br><img src="http://upload-images.jianshu.io/upload_images/2012773-3f95f7c1cb0e4474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="布局性能查看Hierarcher Viewer"></li>
<li>内存泄露检测 Leakcanary<br><img src="http://upload-images.jianshu.io/upload_images/2012773-96aeea69acd68143.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Leakcanary"></li>
</ul>
</li>
<li><p>性能优化实战</p>
<ul>
<li><p>启动速度优化</p>
<ul>
<li><p>三种启动模式</p>
<ol>
<li>首次启动：<br>耗时漫长，fork进程+生成数据+dex编译为本地代码+应用初始化</li>
<li>冷启动：<br>fork进程+应用初始化</li>
<li>热启动：<br>应用恢复</li>
</ol>
<p><strong>应该以冷启动速度为优化指标，首次启动频次低，热启动耗时少，没多大意义。</strong></p>
</li>
<li>冷启动平均耗时统计<br><img src="http://upload-images.jianshu.io/upload_images/2012773-b9267dd0444e9006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="冷启动平均耗时统计"><br>详情扫码<br><strong>Google Play排名前100的非游戏类应用：39个冷启动时间在2秒内，73个冷启动时间在3秒内</strong><br><img src="http://upload-images.jianshu.io/upload_images/2012773-e5df4aa2800d5195.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动速度优化"></li>
<li>Hugo大致定位耗时位置<br><img src="http://upload-images.jianshu.io/upload_images/2012773-3a4b58a04bdcb002.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hugo大致耗时位置"></li>
<li>TraceView精确定位<br><img src="http://upload-images.jianshu.io/upload_images/2012773-548812f9e11746e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TraceView精确定位"></li>
<li>改善后<br><img src="http://upload-images.jianshu.io/upload_images/2012773-8085a0b15f1ee5f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="改善后"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-9827330a71ee0b0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="改善后"><br><img src="http://upload-images.jianshu.io/upload_images/2012773-9fdaa612536fd538.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="改善后"></li>
</ul>
</li>
<li>流畅度优化<br><img src="http://upload-images.jianshu.io/upload_images/2012773-668fd37fd7b4d79e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流畅度优化"></li>
<li>内存优化<br><img src="http://upload-images.jianshu.io/upload_images/2012773-a25f3ccdeccaab9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存优化"></li>
<li>功耗优化<br><img src="http://upload-images.jianshu.io/upload_images/2012773-790aee3586ebebe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="功耗优化"></li>
</ul>
</li>
</ol>
</li>
<li>实际优化效果<ol>
<li>超过80%的应用冷启动时间速度基本都控制在了1.5s以内</li>
<li>解决图文混排控件界面因为图片太多导致滑动卡顿的问题</li>
<li>对大部分模块完成静态代码分析，解决了明显的性能问题（Handler内部类、IO操作导致的内存泄露）</li>
<li>解决两个APP因为适配不合理（图片存放的Drawable文件夹不对）导致耗内存的问题</li>
<li>超过80%的应用基本做到无内存泄露（除系统导致的内存泄露问题外）</li>
<li>解决了两个系统导致的内存泄露问题（WebView、InputMethodManager）</li>
<li>超过80%的应用过度绘制层数控制在3X以内（无红色）</li>
<li>超过95%的应用安装包大小控制在10M以内</li>
</ol>
</li>
</ul>
</li>
<li><p>2016MDCC大会 Android开发峰会讲师PPT<br><a href="https://github.com/MDCC2016/Android-Session-Slides" target="_blank" rel="external">https://github.com/MDCC2016/Android-Session-Slides</a></p>
</li>
</ul>
<p><strong>最后附上Android峰会结束后的合影</strong><br><img src="http://upload-images.jianshu.io/upload_images/2012773-53b54210e9066490.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android峰会合影"></p>
<h4 id="以上是我此次参加MDCC大会总结的全部内容。大多数材料来自于讲师PPT，秋百万前辈、Piasy前辈、何俊林前辈的总结等。欢迎大家提意见，共同进步。有不对的地方还请见谅，请指出我会加以改正。"><a href="#以上是我此次参加MDCC大会总结的全部内容。大多数材料来自于讲师PPT，秋百万前辈、Piasy前辈、何俊林前辈的总结等。欢迎大家提意见，共同进步。有不对的地方还请见谅，请指出我会加以改正。" class="headerlink" title=" 以上是我此次参加MDCC大会总结的全部内容。大多数材料来自于讲师PPT，秋百万前辈、Piasy前辈、何俊林前辈的总结等。欢迎大家提意见，共同进步。有不对的地方还请见谅，请指出我会加以改正。"></a><strong> 以上是我此次参加MDCC大会总结的全部内容。大多数材料来自于讲师PPT，<em>秋百万</em>前辈、<em>Piasy</em>前辈、<em>何俊林</em>前辈的总结等。欢迎大家提意见，共同进步。有不对的地方还请见谅，请指出我会加以改正。</strong></h4><h4 id="再次感谢stormzhang张哥给的机会，非常感谢，我会继续努力。"><a href="#再次感谢stormzhang张哥给的机会，非常感谢，我会继续努力。" class="headerlink" title="再次感谢stormzhang张哥给的机会，非常感谢，我会继续努力。"></a>再次感谢<em>stormzhang</em>张哥给的机会，非常感谢，我会继续努力。</h4><p><br>ikook<br>2016.09.27</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;托stormzhang张哥洪福，有幸参加MDCC大会。收获颇多，总结一番。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ikookblog.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://ikookblog.com/tags/Android/"/>
    
      <category term="MDCC" scheme="http://ikookblog.com/tags/MDCC/"/>
    
      <category term="移动互联网" scheme="http://ikookblog.com/tags/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
</feed>
