<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ikook Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ikookblog.com/"/>
  <updated>2017-11-06T02:34:51.000Z</updated>
  <id>http://ikookblog.com/</id>
  
  <author>
    <name>ikook</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Alfred 每次开机运行提示「访问通讯录」问题</title>
    <link href="http://ikookblog.com/2017/11/06/alfred/"/>
    <id>http://ikookblog.com/2017/11/06/alfred/</id>
    <published>2017-11-05T16:00:00.000Z</published>
    <updated>2017-11-06T02:34:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在忍受了许久「alfred 破解版」开机询问是否访问通讯录问题之后，终于忍不住了。</p>
</blockquote>
<a id="more"></a>
<p>自从用上「MacOS」之后就各种玩软件。用了软件，好用的东西很多，当然被我卸载的也很多。其中，Alfred 是我不会卸载的软件之一。</p>
<p>由于，学生一枚（隐喻，穷屌丝），没办法只能用破解版，就像我「MacOS」一样，是黑的 —— 黑苹果。因为是破解版，随之而来的就有一些烦人的问题，Alfred 也一样，它每次开机的时候，都会提示是否允许访问通讯录。</p>
<p><img src="http://meto.chinakook.com/blog-images/alfred1.png" alt=""></p>
<p>这个问题我忍受了很久，大约有将近一个月吧，我去，我绑不住了，搞他。其实很简单。</p>
<p>在终端输入一下命令，解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo codesign -f -d -s - /Applications/Alfred\ 3.app/Contents/Frameworks/Alfred\ Framework.framework/Versions/A/Alfred\ Framework</div></pre></td></tr></table></figure>
<p>想要下载「Alfred 破解版」扫描下方二维码关注公众号，后台回复：<strong>Alfred</strong> 即可获取。</p>
<p><br>ikook<br>2017.11.06</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在忍受了许久「alfred 破解版」开机询问是否访问通讯录问题之后，终于忍不住了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="软件说" scheme="http://ikookblog.com/categories/%E8%BD%AF%E4%BB%B6%E8%AF%B4/"/>
    
    
      <category term="工具" scheme="http://ikookblog.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Alfred" scheme="http://ikookblog.com/tags/Alfred/"/>
    
  </entry>
  
  <entry>
    <title>无扩展，不 Chrome</title>
    <link href="http://ikookblog.com/2017/09/01/chrome-extended/"/>
    <id>http://ikookblog.com/2017/09/01/chrome-extended/</id>
    <published>2017-08-31T16:00:00.000Z</published>
    <updated>2017-09-01T13:51:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家好啊，最近开学在折腾学校实训的事，比较忙，耽搁了更新，抱歉。为了表达歉意，给大家来点「刺激的」。</p>
<a id="more"></a>
<p>为大家推荐一些我常用的 Chrome 扩展，相信 Chrome 大家并不陌生吧，一款优雅的超好用的浏览器。由于某些东西的存在，下载安装稍微有点限制。关注公众号「ikook」后台回复「Chrome」可获取各个离线版本 Chrome。</p>
<p>好了，正文开始。想要用好 Chrome，非扩展不可，正所谓「无扩展，不 Chrome」。下面给大家介绍几款让 Chrome 变得更加优雅用起来更优雅的扩展。</p>
<h3 id="为什么你们就是不能加个空格呢？"><a href="#为什么你们就是不能加个空格呢？" class="headerlink" title="为什么你们就是不能加个空格呢？"></a>为什么你们就是不能加个空格呢？</h3><p>你没看错，名字就是「为什么你们就是不能加个空格呢？」。有没有因为汉字与英文之间没有空格引起强迫症？其内置的空格之神，可以自动为一切中文字和半形的英文、数字、符号之间插入空白。</p>
<center><br><img src="http://meto.chinakook.com/%E7%A9%BA%E6%A0%BC%E4%B9%8B%E7%A5%9E.jpg" alt=""></center>

<p>下载安装：<a href="http://t.cn/zlnOv4n" target="_blank" rel="external">http://t.cn/zlnOv4n</a></p>
<p>Chrome 应用商店链接，要访问… 你懂得，下同</p>
<h3 id="Imagus"><a href="#Imagus" class="headerlink" title="Imagus"></a>Imagus</h3><p>有没有过「查看原图」但是原图不够大的情况？有了 Imagus 扩展，鼠标指针悬停在链接或缩略图上时直接在当前页面的弹出视图上显示这些图片、HTML5 视频 / 音频和内容专辑。</p>
<center><br><img src="http://meto.chinakook.com/Imagus.jpg" alt=""></center>

<p>下载安装：<a href="http://t.cn/8sDMJm6" target="_blank" rel="external">http://t.cn/8sDMJm6</a></p>
<h3 id="Flatbook"><a href="#Flatbook" class="headerlink" title="Flatbook"></a>Flatbook</h3><p>是否厌倦了 Facebook 亘古不变的页面，来给你的脸书换个脸吧，瞬间清爽到爆啊。</p>
<center><br><img src="http://meto.chinakook.com/flatbook.jpg" alt=""></center>

<p>下载安装：<a href="http://t.cn/RNiRhcj" target="_blank" rel="external">http://t.cn/RNiRhcj</a></p>
<h3 id="Darkness"><a href="#Darkness" class="headerlink" title="Darkness"></a>Darkness</h3><p>Darkness 可以为 Google，Facebook，YouTube，Reddit 等不存在的网站提供完美的夜间模式支持，不会有图片反转，文字颜色奇怪等尴尬问题。当然了，Darkness 适配的网站还很少，如果你需要广泛适用的，可能需要这款神级扩展：Stylish，在下面。</p>
<center><br><img src="http://meto.chinakook.com/Darkness.jpg" alt=""></center>

<p>下载安装：<a href="http://t.cn/RNinpUu" target="_blank" rel="external">http://t.cn/RNinpUu</a></p>
<h3 id="Stylish"><a href="#Stylish" class="headerlink" title="Stylish"></a>Stylish</h3><p>许多网页的视觉风格是用 CSS 文件进行管理的，替换网页本身的 CSS 可以达到美化的目的了。通过安装 CSS，可以把知乎「拍扁」，让微博网页版变得简洁无比，让 Feedly 用上 Material Design 等等等…… Stylish 作为一个 CSS 管理器，可以让替换 CSS 变得简单。</p>
<center><br><img src="http://meto.chinakook.com/1504266030349.jpg" alt=""></center>

<p>关于 Stylish 更详细的介绍见：<a href="https://sspai.com/post/34508" target="_blank" rel="external">https://sspai.com/post/34508</a></p>
<p>下载安装：<a href="http://t.cn/R9hCUIk" target="_blank" rel="external">http://t.cn/R9hCUIk</a></p>
<h3 id="Wikiwand"><a href="#Wikiwand" class="headerlink" title="Wikiwand"></a>Wikiwand</h3><p>多年来，维基百科网页的视觉风格坚定不移地停留在 Web2.0 时代。Wikiwand 让你看到一个属于 21 世纪的维基百科。除了视觉上的提升，Wikiwand 也添加了一些人性化的交互：比如超链接悬浮窗，搜索联想，黑色模式等等…</p>
<center><br><img src="http://meto.chinakook.com/1504266756635.jpg" alt=""></center>


<p>下载安装：<a href="http://t.cn/R4TGWCh" target="_blank" rel="external">http://t.cn/R4TGWCh</a></p>
<h3 id="阅读模式"><a href="#阅读模式" class="headerlink" title="阅读模式"></a>阅读模式</h3><p>「阅读模式」可以为 Chrome 带来了类似 Safari 的阅读体验。点击图标即可进入，再次点击退出，完全的无痛体验啊。有一种 Chrome 原生阅读模式的错觉，爽。</p>
<center><br><img src="http://meto.chinakook.com/1504267091779.jpg" alt=""></center>

<p>下载安装：<a href="http://t.cn/RNiFaDw" target="_blank" rel="external">http://t.cn/RNiFaDw</a></p>
<p>今天主要介绍的是利用 Chrome 扩展改变网页视觉感觉，让浏览网页变得更加优雅，后面有机会再和大家说说其他实用扩展。</p>
<p>完。</p>
<p><br>ikook<br>2017.09.01</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家好啊，最近开学在折腾学校实训的事，比较忙，耽搁了更新，抱歉。为了表达歉意，给大家来点「刺激的」。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔集" scheme="http://ikookblog.com/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
      <category term="工具" scheme="http://ikookblog.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>七夕，过得怎样？</title>
    <link href="http://ikookblog.com/2017/08/28/seven-month-seven/"/>
    <id>http://ikookblog.com/2017/08/28/seven-month-seven/</id>
    <published>2017-08-28T13:04:46.000Z</published>
    <updated>2017-09-01T13:14:34.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p><br><br><br></p>
<center><strong>七夕</strong></center>

<center>这个狗吐血的特殊日子</center>

<center>我是这样度过的</center>

<center><br><img src="http://meto.chinakook.com/1503916978099.jpg" alt=""></center>

<p><br></p>
<center>我的心情是这样的</center>


<center><br><img src="http://meto.chinakook.com/17.08.28.jpg" alt=""></center>

<p><br><br><br></p>
<center>祝</center>

<center>虐狗节快乐</center>



<p><br>ikook<br>2017.08.28</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;七夕&lt;/strong&gt;&lt;/center&gt;

&lt;center&gt;这个狗吐血的特殊日子&lt;/center&gt;

&lt;center&gt;我是这样度过的&lt;/center&gt;

&lt;center&gt;&lt;
    
    </summary>
    
      <category term="随笔集" scheme="http://ikookblog.com/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
      <category term="随笔" scheme="http://ikookblog.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>java 实现排序算法之「插入排序」</title>
    <link href="http://ikookblog.com/2017/08/26/java-sort-series3/"/>
    <id>http://ikookblog.com/2017/08/26/java-sort-series3/</id>
    <published>2017-08-25T16:00:00.000Z</published>
    <updated>2017-09-01T13:03:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>java 实现排序算法系列</p>
</blockquote>
<a id="more"></a>
<p>这是 Java 实现排序算法的第三篇文章——插入排序算法。插入排序可以说成是「一类」简单的排序算法，因为插入排序可以有变种，比如二分查找插入排序算法，本文讲述的是直接插入排序。</p>
<p>如文中出现错误，请在公众号「ikook」聊天窗口留言，十分感谢。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序「Insertion Sort」是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>来看一下插入排序算法的思路：<br></p>
<ul>
<li>将需排序的数据分成已排序和未排序两部分，从第一个元素开始，并将该元素看做已排序。<br><br></li>
<li>取得下一个元素，即第二个元素，在已排序的序列中由后向前扫描，找出合适的位置将该元素插入。<br><br></li>
<li>重复上述步骤，直到最后一个元素被插入到已排序序列中。<br><br></li>
<li>排序完成。<br><br></li>
</ul>
<p>使用插入排序为一列数字进行排序的过程示意图（来自维基百科）：</p>
<center><br><img src="http://meto.chinakook.com/Insertion-sort-example.gif" alt=""></center>

<p>插入排序算法示意图（来自维基百科）：</p>
<center><br><img src="http://meto.chinakook.com/Insertion_sort_animation.gif" alt=""></center>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>从上面可以看到，算法思路非常简单，但是代码就不那么简单易写了。算法本身是没有问题的，之所以不易写我觉得是由于编程语言的问题。这里我们使用 Java 来实现，那就拿 Java 来讲。</p>
<p>在上述思路中我们可以提出几个问题，先来看下。首先，我们该如何判断合适的位置？边界条件该怎么处理？在数组中插入元素，必然会移动数据，如何控制数据的移动？</p>
<p>为了解决这些问题，我们可以在算法思路的第二步做手脚，将第二步细化。我们不在已排序的序列起始位置开始比较，从已排序序列的尾部开始逆序比较，只要比待插入的数据大，那就向后移动，直到不大于该数据，此时空出来的位置就放入待插入数据。</p>
<p>上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</div><div class="line">          <span class="keyword">int</span> value = arr[i];</div><div class="line">          <span class="keyword">int</span> position=i;</div><div class="line">          <span class="keyword">while</span> (position&gt;<span class="number">0</span> &amp;&amp; arr[position-<span class="number">1</span>]&gt;value)&#123;</div><div class="line">              arr[position] = arr[position-<span class="number">1</span>];</div><div class="line">              position--;</div><div class="line">          &#125;</div><div class="line">          arr[position] = value;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在代码的理解上遇到困难，可以利用 IDE 的调试功能来学习。如下图（IntelliJ IDEA）：</p>
<center><br><img src="http://meto.chinakook.com/insert_debug.jpg" alt=""></center>

<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>从上述内容容易看出，无论输入的数据怎样，插入排序算法总会进行 n-1 次排序。</p>
<p>由于每个元素插入点的不确定性，该算法复杂度并不是一定的。假设我们要将 n 个元素的序列升序排序，这时存在最好情况和最坏情况。</p>
<p>最好情况就是，序列已经是升序排列了（即数据本身的顺序和我们需要的顺序相同）。此时，需要进行的比较操作需（n-1）次即可，时间复杂度为 O(n)。</p>
<p>最坏情况很显然，序列为逆序排列时，即降序排序时为最坏。此时，需要进行的比较共有 1/2n(n-1) 次，时间复杂度为 O(n^2)。</p>
<p>平均来说，插入排序算法复杂度为 O(n^2)。插入排序的赋值操作是比较操作的次数加上（n-1）次。</p>
<p>空间复杂度，插入排序所有的数据移动均在内部进行，唯一的开销是我们使用了一个临时变量，则空间复杂度为 O(1)。</p>
<h2 id="插入排序算法分析"><a href="#插入排序算法分析" class="headerlink" title="插入排序算法分析"></a>插入排序算法分析</h2><p><strong>算法稳定性：</strong><br>拿本文中的例子来讲，只需要找到需插入元素的位置即可，并不需要交换，则直接插入排序是稳定排序算法。</p>
<p><strong>适用场景：</strong><br>从算法复杂度可以看出，该排序算法不适合数据较大的情况，数量级小于千时，插入排序是一个不错的选择。在 STL 的 sort 算法和 stdlib 的 qsort 算法中，都将插入排序作为快速排序的补充，用于少量数据的排序。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于插入排序算法的变种大家有兴趣的自己 Google 一下，本文只讲述了基本的直接插入排序。插入排序的变种大概有这几种：二分查找插入排序、2 - 路插入排序、表插入排序。二分查找插入排序有的文献叫做折半插入排序，2 - 路插入排序和表插入排序可以参考《数据结构》（严蔚敏、吴伟民著）一书。</p>
<p>完。</p>
<p>相关阅读：<br><a href="http://ikookblog.com/2017/03/09/java_sort_algorithm_series1/">Java 实现「冒泡排序」</a><br><a href="http://ikookblog.com/2017/08/11/java_sort_algorithm_series2/">Java 实现「选择排序」</a></p>
<p>PS：如果你觉得本文对你有一点帮助，点赞、转发，不胜感激。</p>
<p><br>ikook<br>2017.08.26</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;java 实现排序算法系列&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="论算法" scheme="http://ikookblog.com/categories/%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://ikookblog.com/tags/java/"/>
    
      <category term="计算机技术" scheme="http://ikookblog.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"/>
    
      <category term="排序算法" scheme="http://ikookblog.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ikookblog.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>我是你流浪过的一个地方</title>
    <link href="http://ikookblog.com/2017/08/17/view-text-02/"/>
    <id>http://ikookblog.com/2017/08/17/view-text-02/</id>
    <published>2017-08-17T14:02:27.000Z</published>
    <updated>2017-08-26T05:11:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文来自 App Store 软件「青稞 - 找寻诗和远方」推文，作者：王海桑</p>
</blockquote>
<a id="more"></a>
<p><br></p>
<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>在同一个一百年里，你来了我来了<br>一一不早，也不迟<br>在同一朵云彩下，你看见我我看见你<br>一一不远，也不近<br>你就在那儿，有树有水<br>所以，我爱你。</p>
<p><br></p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>我没有找到你我碰见你了<br>我没有想到你我看见你了<br>我看见你了，你还能往哪儿跑呢<br>你是我今生今世最大的意外<br>这不是在梦里，也不是在画里<br>你和我携手同行<br>走进落日与大地的亲吻<br><br><br>天地如此宁静，我听见了<br>我心如此感恩，你听见了吗<br>你就说吧说吧，今晚我住在哪儿呢<br>瞧你的长发森林你的明眸流水<br>都是我的家  </p>
<p><br></p>
<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>不知道是对是错，不管它是对是错<br>我只想和你在一起，一起等太阳出来<br>没有水，你是我的水<br>没有粮食，我是你的粮食<br>我们自始至终相信同一个神<br>热爱同一个命运<br>因为啊，爱上你<br>我身体中有世上最柔软的部分<br>我无法想象，你起伏的身体<br>是怎样的一个神秘国度<br>我爬遍你的全身，像个孩子<br>你新鲜、温暖而美丽<br>当你的呼吸在我的鼻孔<br>我的手在你的发间<br>你问：你好吗？<br>我说：我想你。  </p>
<p><br></p>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>如果有时候，我会沉溺于欢乐<br>请原谅，我不是故意的<br>你想想看，当春天来了<br>漫山遍野都开满五颜六色的花儿<br>我又能怎么办呢<br>还有干净的石头，清澈的水<br>阳光也是刚刚流出来的<br>你一碰就响<br><br><br>去吧，去一百个地方，走一千里鲜花<br>摘它一万朵！要不就一朵吧<br>我可真想摘下来，拿在手上<br>欢乐真好，我真的是喜欢那些美好的事物<br>这件事请你原谅，如果我可以原谅  </p>
<p><br></p>
<h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>来吧，那些是我的就是我的<br>我不要天上的星星<br>这一生能有些什么，能做些什么<br>——我都已清楚。<br>我不要自己在世界多么重要，从一开始<br>世界和我就是两件不同的事<br>我只要，在窗囗的月下，在你倦时<br>能用手掌托起你寂寞的心<br>看吧，那些我犯过的错都在保证<br>我将用我一生的细节珍爱你细节的一生<br>所以从现在起，从这里起<br>把你的手给我，把你的手放在我心囗<br>相信我的一生就是你的一生<br>便是这世界背我而去，我也心满意足<br>我只请求一件事一一<br>我不要思念你，我要紧挨着你</p>
<p><br></p>
<h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p>那时我正躺在云朵上做梦<br>是你在生活中喊我，喊我尘世的名字<br>于是我踢掉鞋袜，顾不上踩云<br>像两个渴慕已久的音符<br>你我在阳光的五线谱间执手相遇<br><br><br>我不知道如何爱你，我看着你<br>我前后左右都跟着你<br>以自己的才华和智慧我投身于你<br>不够，就以信念，再不够<br>就以身以命一生相许<br>竟如此不易，你和我<br>彼此在不如意的生活中<br>遇上一个如意的人，所以我爱你<br>就连同你的缺点你的道路<br>以及你是非难辨的过去<br>从此我们手拉手<br>向着同一个方向走，直到天黑<br>待生命结束，我们才结束<br>一回头，我们看见的不是一缕轻烟<br>而是我们相知的一生<br>深深浅浅，心心相印</p>
<p><br></p>
<h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><p>不，小心些。请不要相信<br>我现在对你说的话<br>因为它真诚见心，所以易变<br>只是在这世界有一个点上<br>我和你，在一起<br>这感觉如此美妙，像在飞<br>如果是真的，请告诉我<br>如果不是真的，请告诉我<br>你知道的，你知道的<br>我就像一只小虫碰到了阳光<br><br><br>我的幸福也小心翼翼<br>因为啊，过往的岁月教会我<br>人的一生中有一个字<br>是冷，是彻骨的冷<br>所以我会在星稀的冬夜<br>点一堆火，慢慢想你</p>
<p><br></p>
<h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><p>累的时候，有个地方能睡<br>饿的时候，有点东西能吃<br>这多好。我怎敢要求太多<br>当我到了某个年龄，能有个女人挨着<br>当我因劳作而一身冒汗<br>能有一盆水喝，一条河流洗澡<br>天想下雨的时候下雨，然后有阳光<br>如果高兴，如果我可以<br>光着身子和你在树林里奔跑<br>这就够了。我愿意这就是我的一生<br>有阳光、粮食、女人和水<br>这是我所能想起的幸福</p>
<p><br></p>
<h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><p>一生当中，到底有多少事可以很肯定<br>你和我之间，究竟有多少事可以分得清白<br>而我总是很肯定很肯定地告诉你<br>在我们的明天里<br>有阳光和早餐，有河流和音乐<br>你所有的事，我说，都来找我<br>你所有的对错，都归于我<br>因为我要你生活美好，一生安宁<br>有一天当我死了，会有人来<br>说：“这个人，一生寂寞。”<br>你不要哭，我给你说过——<br>我是一个泥做的生灵<br>想娶一个水做的女人为妻<br>于是遇上你。所以，在一百年里<br>如果你的一生需要有人捧在手上<br>那个人，只能是我，必须是我<br>便是当我走了，我也会记着<br>把这手上的温暖，给你留下  </p>
<p><br></p>
<h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><p>那一天，我想吻你<br>因为那天的月亮很明很圆<br>我想吻你，因为世上只有我们两个人<br>吻你，是那一刻我俩唯一能做的事<br>因为我不知道你，因为我想知道你<br><br><br>我真的想吻你<br>我看见你的唇像一颗草莓<br>我猜它一定又红又甜<br>一想到要吻你，我的心在跳<br>我害怕你，你陌生而神奇<br>你也不敢看我的眼<br>你背对我是一挂黑发<br>我的手欲伸又止，像只胆小的小动物<br>从我这里爬到你腰间，这段短短的距离<br>用了我整整一百年<br>一百年后，你转过身<br>这世界一无所有，只有一个月亮<br>很明很圆  </p>
<p><br></p>
<h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><p>我从遥远的时间回来<br>我从孤单的地平线回来<br>回到我原本在的地方，不再远行<br>——这是我的家。<br>我不再追求幸福，我就是幸福<br>我不再想象生活，我着手生活<br>没你在时我想你，有你在时我看着你<br><br><br>哦，原来这就是我吗<br>每一件和你有关的小事情都让我心动<br>当你和我说话，当你没和我说话<br>我都掩饰不住心中莫名的欢乐</p>
<p><br></p>
<h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><p>在这片叶子上开始，我将关心你的一生<br>你没有过去，或者你的过去是一把尘土<br>而你的今天和我的今天必将赶上明天的光明<br><br><br>我不是骑白马的王子，但我也有剑<br>总有一天，这剑上将有血<br>别人的血，或我的血一一与你有关<br>而今天，而正在流逝的今天<br>在向上或向下的路上我与你同在<br>请让我关心你的早餐，你的睡眠<br>关心你身体每一个可爱的小地方<br>是否安好如初，是否一切未变</p>
<p><br></p>
<h4 id="13"><a href="#13" class="headerlink" title="13"></a>13</h4><p>可如果幸福注定与我无缘，我会想念它<br>不管它把我看成什么人，请相信<br>这件事不只是我一个人的错。苍天在上<br>我一直在生活中努力保持纯洁<br><br><br>如果爱情找不到我的一生，那肯定自有原因<br>我不敢质问爱神，只想告诉<br>那个飞来飞去的花翅膀小孩——<br>下一次，如果愿意，请记着我<br><br><br>除此之外，我来到这个世上是<br>要做一些事想念一些人<br>让自己的心还有片干净的地方<br>能容得下一个神龛，和跪得下我的空间</p>
<p><br></p>
<h4 id="14"><a href="#14" class="headerlink" title="14"></a>14</h4><p>当你需要精美的早餐<br>我却只有爱情<br>为了一行关于粮食的诗句<br>你我相拥，失声一哭<br>而我们在月亮下已经走得太远<br><br><br>可你得想想<br>人生如此重大，你不能什么都要<br><br><br>请相信吧——<br>一千次失败必将成全一个生灵<br>你不要哭，到时候，我会说——<br>诸事顺利，一切都好</p>
<p><br></p>
<h4 id="15"><a href="#15" class="headerlink" title="15"></a>15</h4><p>寂寞和美好让我们相遇<br>然后是生存把我们分开<br>当你的背影住在我的泪中<br>你告诉我，说——<br>生活是为了改变生活<br>是啊是啊，在生活中<br>想象出来的路就能走吗<br><br><br>而当大雪飞过那个小镇<br>我哪儿都不去，我将想你<br>在零度以下，想你是一种温暖<br>是我的幸福  </p>
<p><br></p>
<h4 id="16"><a href="#16" class="headerlink" title="16"></a>16</h4><p>早晨五点半，想起你和我挨着<br>很暖和。还有早餐<br>早餐和早晨一样和你一样清新<br>你说早市上的青菜和萝卜都是爱情<br>看来，你是对的<br><br><br>你因为热爱生活<br>所以遇上了我。可你走了<br>你还有别的事，只是对于我<br>这件事太简单，我还没准备好<br>这件事太简单，要我一生来接受<br><br><br>你走了，你比孤单还瘦  </p>
<p><br></p>
<h4 id="17"><a href="#17" class="headerlink" title="17"></a>17</h4><p>是不是神怕我们不小心弄脏了爱情<br>所以只让我们看见它<br>只让我们亲它一小囗<br>便珍爱有加地收回<br>然后要我们在这艰难的人间<br>找一个能相依相守的人<br>恩恩爱爱，建筑家园<br>如果真是这样，那么<br>当我在世界的尽头遇见你<br><br><br>你怎么说呢<br>当你就在那儿我不喊你<br>如果你也看见我而我走过去<br><br><br>你还能否如初次那般微笑<br>对我说：嗨。  </p>
<p><br></p>
<h4 id="18"><a href="#18" class="headerlink" title="18"></a>18</h4><p>结束了。<br>画个句号。<br>像一滴泪。<br>握你的手，最后握你的手<br>再松开，一松手，就是——<br>一千里<br><br><br>路在那儿等你。<br>不知道去哪儿的路在那儿等你。<br>我含泪的眼没有希望<br>就这样，是再见  </p>
<p><br></p>
<h4 id="19"><a href="#19" class="headerlink" title="19"></a>19</h4><p>我的心平平静静地合上<br>你在外边，早晨在外边<br>你和早晨是一个人<br>身后是泪眼天堂<br><br><br>很多事情都会突然过去<br>愿意你好，一生都健康安全<br>我也会准时起床，干活、吃饭<br>累了，就歇一会儿<br>伤心了，也笑一笑<br>不管生活把你藏在什么地方<br>我知道，只一伸手<br>我摸得到你的寂寞<br>就像这个早晨，那么凉<br><br></p>
<h4 id="20"><a href="#20" class="headerlink" title="20"></a>20</h4><p>请求你允许我，下辈子<br>偿还你的一生。而我今生<br>必须好好地，好好地学会幸福<br>如果你在一千里之外很好<br>请告诉我，好让我在孤单的时间<br>里找到另一个女人，而放下你<br>如果你找了再找都没有你的地方<br>而你仍执意不回头，一千一万都不<br>那么也好吧，你知道<br>我们是两个一样寂寞的人<br>当我想哭，当你想哭<br>哭你我曾经相遇相识<br>生活它必须重新开始<br>一步一难，向着幸福</p>
<p><br></p>
<h4 id="21"><a href="#21" class="headerlink" title="21"></a>21</h4><p>我不曾爱过你<br>我只是担心你的一生<br>只是想知道你在那儿很好<br>想着你已经找到幸福<br>如果我说过爱你，请原谅我<br>我只是无法忍住伤心<br>于是你终于离开<br>可你离开得已经太迟</p>
<p><br></p>
<h4 id="22"><a href="#22" class="headerlink" title="22"></a>22</h4><p>我的心无法安慰<br>我的心需要忘记<br>所以我要到一个很远很远的地方<br>去忘记一个人<br>去忘记一些事<br>然后回来，以双手进入生活</p>
<p><br></p>
<h4 id="23"><a href="#23" class="headerlink" title="23"></a>23</h4><p>最终我必将接受现实<br>但我知道——<br>生活一思索都是疑问<br>唱出来才是歌<br>我选择后者</p>
<p><br></p>
<h4 id="24"><a href="#24" class="headerlink" title="24"></a>24</h4><p>下一个一千年，如果有<br>如果我可以再一次做人，而遇上你<br>我要挣很多钱，在水边，买一幢<br>有玫瑰花有咖啡的房子<br>然后娶你为妻——<br>月光是我们的，水声是我们的<br><br><br>我们纯洁地做爱<br>慢慢讲美丽的故事<br>然后养一百个漂亮的孩子<br><br><br>围着我，围着你<br>而这一次，我一生对不起<br>你因为我是个如此住在梦中的人<br><br><br>有一天，当我死了，想到你会流泪<br>我已如此幸福。真想告诉你<br>你是我一生中的一件最美好的事<br><br><br>当你死了，当你回到落叶化成的泥土<br>我将认出你，我的心将挨着你<br>不声不响，你知道是我，我知道是你<br><br><br>完。</p>
<p><br>ikook<br>2017.08.17</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文来自 App Store 软件「青稞 - 找寻诗和远方」推文，作者：王海桑&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="观文记" scheme="http://ikookblog.com/categories/%E8%A7%82%E6%96%87%E8%AE%B0/"/>
    
    
      <category term="感悟" scheme="http://ikookblog.com/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="转载" scheme="http://ikookblog.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="观文" scheme="http://ikookblog.com/tags/%E8%A7%82%E6%96%87/"/>
    
      <category term="诗歌" scheme="http://ikookblog.com/tags/%E8%AF%97%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>java 实现排序算法之「选择排序」</title>
    <link href="http://ikookblog.com/2017/08/11/java_sort_algorithm_series2/"/>
    <id>http://ikookblog.com/2017/08/11/java_sort_algorithm_series2/</id>
    <published>2017-08-10T16:00:00.000Z</published>
    <updated>2017-08-11T12:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>java 实现排序算法系列</p>
</blockquote>
<a id="more"></a>
<p>继冒泡排序算法之后，选择排序终于和大家见面了。为什么冒泡排序之后要说选择排序呢，是因为它俩是最相似的两种排序算法，血缘关系最为接近。</p>
<p>还是那句话，本人能力拙劣，有不当之处还请不吝赐教，可关注我公号后台留言，见底部二维码。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序（Selection sort）是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度。可以把它看做是冒泡排序算法的一种改进算法。</p>
<h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>假设要给有 n 个元素的数组 arr[] 排序。注意，在数组中第一个元素的下标为 0</p>
<h5 id="n-1"><a href="#n-1" class="headerlink" title="n = 1:"></a>n = 1:</h5><p>无需排序</p>
<h5 id="n-gt-1"><a href="#n-gt-1" class="headerlink" title="n &gt; 1:"></a>n &gt; 1:</h5><ul>
<li>将第一个元素和第二个元素进行比较，如果 arr[0] 大于 arr[1]，那么 arr[0] 一定不是最小元素。这里我们暂时不交换元素，而是设置临时变量 a，用来存储较小变量 arr[1] 的下标。然后将目前较小元素 arr[a] 继续和第三个元素比较，如果 arr[a] 大于 arr[2]，则修改 a 的值为 arr[2] 的下标，再接着往下比较；如果不大于 arr[2]，则将 arr[a] 和第四个元素比较，如前者大，则修改 a 的值为 arr[3] 的下标。以此类推，直到与最后一个元素比较，则 a 的值肯定是最小值的下标。<br><br></li>
<li>如果 a 的值不为 0（即不是元素 arr[0] 的下标)，则交换下标为 0 和 a 的元素，即将 arr[a] 和 arr[0] 进行交换。 <br><br></li>
<li>至此，第一趟排序完成，将最小值找出来了，然后进行第二趟排序。重复上述过程，从第二个元素（即 arr[1]）开始比较。第一个元素已经是最小元素了，不参与比较。 <br><br></li>
<li>重复步骤直到剩下最后一个元素，即 arr[n-1]，可以肯定这个值为最大值。 <br><br></li>
<li>排序完成，不够直观？见下面示例动画。</li>
</ul>
<center><br><img src="http://meto.chinakook.com/blog-images/java_sort_algorithm_series2.gif" alt=""></center>

<blockquote>
<p>注: 红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。</p>
</blockquote>
<p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n 个元素进行排序总共进行至多 n-1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。 </p>
<p>需要注意的是，上述过程只是每次找最小值的办法。实际上也可以每次找最大值，思路是一样的。</p>
<p>选择排序的示意图（图片来自维基百科）：</p>
<center><br><img src="http://meto.chinakook.com/blog-images/Selection_sort_animation.gif" alt=""></center>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>设要给数组 arr[] 排序，它有 n 个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> min, temp, len = arr.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</div><div class="line">            min = i;<span class="comment">//未排序序列中最小数据数组下标</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123; <span class="comment">//在未排序元素中继续寻找最小元素，并保存其下标</span></div><div class="line">                <span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</div><div class="line">                    min = j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (min != i) &#123;</div><div class="line">                temp = arr[min]; <span class="comment">//将最小元素放到已排序序列的末尾</span></div><div class="line">                arr[min] = arr[i];</div><div class="line">                arr[i] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>选择排序需要进行 n-1 轮比较。很显然，比较次数 O(n^2)，比较次数与关键字的初始状态无关，总的比较次数 N = (n-1) + (n-2) + … + 1 = n x (n-1) / 2。</p>
<p>交换次数 O(n)，最好情况是，已经有序，交换 0 次；最坏情况是，逆序，交换 n-1 次。交换次数比冒泡排序较少，由于交换所需 CPU 时间比比较所需的 CPU 时间多，n 值较小时，选择排序比冒泡排序快。</p>
<p>选择排序的赋值次数：最坏情形下需要交换 n-1 次，对于上面的代码，需要赋值 3(n-1) 次。而最佳情况下，则需要 0 次。如果假定平均分布，大约需要 3n/2。</p>
<p>冒泡排序可以在最佳情况下有 O(n) 复杂度，那么选择排序行不行呢？ 很遗憾，不行。选择排序每次只找最小值，但它并不能知道其他值是否有序排列。因此，选择排序在最优、最坏、平均情况下的<strong>时间复杂度</strong>均为 O(n^2)，<strong>空间复杂度</strong>（额外空间）为 O(1).</p>
<h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><p>对于选择排序的稳定性是存在一定争议的。但在本例中，最小值和另一个值相同的时候我们并不需要交换它们，选择排序是稳定排序。其实排序算法中，有些稳定算法可以变换成不稳定算法，而不稳定排序算法又有很多办法可以变成稳定的，这在《算法》第四版中有所提及。所以，没有严格意义上的稳定与不稳定排序。</p>
<h3 id="算法适用场景"><a href="#算法适用场景" class="headerlink" title="算法适用场景"></a>算法适用场景</h3><p>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的 O(n^2) 复杂度，选择排序在数据量较大的时候显得力不从心。因此，它适用于简单数据排序。</p>
<p><br>ikook<br>2017.08.11</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;java 实现排序算法系列&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="论算法" scheme="http://ikookblog.com/categories/%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://ikookblog.com/tags/java/"/>
    
      <category term="计算机技术" scheme="http://ikookblog.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"/>
    
      <category term="排序算法" scheme="http://ikookblog.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ikookblog.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>宗教和苹果</title>
    <link href="http://ikookblog.com/2017/08/07/religion-and-apply/"/>
    <id>http://ikookblog.com/2017/08/07/religion-and-apply/</id>
    <published>2017-08-07T15:11:08.000Z</published>
    <updated>2017-08-16T15:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文转载自《一天世界》博客，作者：不鸟万如一</p>
</blockquote>
<a id="more"></a>
<p>苹果第八号员工贴了一张苹果早期天使投资人 Mike Markkula 一九七七年写的营销哲学，只有短短三段，翻译如下：</p>
<ul>
<li>同理心：我们真的要比任何其它公司更了解她们的需求。<br><br></li>
<li>专注：为了把决定要做的事做好，我们必须放弃所有不重要的机会。<br><br></li>
<li>转嫁：以貌取人乃人类天性。就算我们的产品品质最高，软件最有用，如果用潦草的方式呈现出来，人们就会认为它们是潦草的。若用富于创意的、专业的方式呈现出来，我们就能把那些吸引人的品质转嫁给顾客。</li>
</ul>
<p>一九七七年的电脑世界和今天大不相同。微软成立两年，苹果才成立一年。那是「家酿电脑俱乐部」的玩票时代，组织、管理和规范都还远未成形。大多数人完全不知道电脑能干什么，以及为什么家里要放台电脑。这也是为什么今人看 Markkula 的这份文档，只看到了一些人尽皆知的大白话道理。这些道理在当年是需要特地提出的。</p>
<p>不过最奇特的还是「转嫁」一词。原文 impute，今天比较少见，通常的意思是指把某种不好的东西归咎于人。这是怎么回事？</p>
<p>查《New Oxford American Dictionary》（macOS 自带），impute 在神学语境有如下涵义：</p>
<blockquote>
<p>Ascribe (righteousness, guilt, etc.) to someone by virtue of a similar quality in another: Christ’s righteousness has been imputed to us.</p>
</blockquote>
<p>稍稍搜索可知，impute 的确是《圣经》里常用的词。和日后的一般用法不同，在神学领域，转嫁的有时是好东西，有时是坏东西。例如上帝把正义转嫁给信众，而有罪的世人则把罪转嫁给基督。（《圣经》中文版往往根据具体的上下文简单译成「归于」。）</p>
<p>如果用今天的语言改写 Markkula 的第三段，同样会变成平淡无奇的教条。光是产品好是不够的，这是看脸的世界，设计不只是漂亮的皮囊，更是内在品质的外化反映。恐怕没人会觉得这是什么了不起的洞见。</p>
<p>这并不是早年的苹果使用的唯一有宗教意味的词。软件传教士（evangelist）就是 Mac 部门的 Mike Murray 发明的说法，早期在苹果负责营销的川崎盖伊（Guy Kawasaki）也很可能是史上最有名的软件传教士。今人戏称苹果为苹果教，但苹果的宗教情绪是从创始之初就浸透在企业文化当中的。活用 impute 这样的词，甚至把它单独拎出来作为小标题，反映了苹果的使命感和道德义务感。我们可以转嫁各种东西于她人，有好的东西，也有坏的东西，请诸君谨记自己所负担的义务，扬善惩恶。</p>
<p>这是扮演上帝的狂妄吗？我认为这是诚实。产品的设计者在消费者面前拥有的绝对权力，在产品被使用的过程中，完全可以比之于上帝。而恰恰由于产品设计者是会犯错的人而非上帝，才需要如履薄冰的道德义务感。这个道理，在今天耻谈道德的「Don’t judge」主义、相对主义、和中立至上主义年代，是需要特地提出的。</p>
<p>而作为顾客的我们，又转嫁了什么样的东西给产品的设计者呢？</p>
<p>完。</p>
<p>PS：<a href="https://t.me/yifenshijie/313" target="_blank" rel="external">https://t.me/yifenshijie/313</a> ，复制链接至浏览器，在《一分世界》收听本文语音版。（需要 <strong>Telegram</strong>）</p>
<p>PPS：点击<a href="https://blog.yitianshijie.net/2017/08/07/religion-and-apple/" target="_blank" rel="external">阅读原文</a>可跳转至原文</p>
<p><br>ikook<br>2017.08.07</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自《一天世界》博客，作者：不鸟万如一&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="观文记" scheme="http://ikookblog.com/categories/%E8%A7%82%E6%96%87%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="http://ikookblog.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="感悟" scheme="http://ikookblog.com/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="转载" scheme="http://ikookblog.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="观文" scheme="http://ikookblog.com/tags/%E8%A7%82%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>公众号排版指南「下」</title>
    <link href="http://ikookblog.com/2017/08/03/wechat02/"/>
    <id>http://ikookblog.com/2017/08/03/wechat02/</id>
    <published>2017-08-02T16:00:00.000Z</published>
    <updated>2017-08-11T13:02:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>愚者用肉体监视心灵，智者用心灵监视肉体。<br>—— 李嘉诚</p>
<blockquote>
<p>首发于公众号，地址：<a href="http://mp.weixin.qq.com/s/kzFSe-gxyQomRWhaGM90kw" target="_blank" rel="external">公众号排版指南「下」</a></p>
</blockquote>
</blockquote>
<p>接着上次没扯完的蛋，继续扯，扯碎为止。</p>
<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>文字排版</p>
<p>文字排版其实很简单，只要用心多设置一下，稍微折腾下就能学会很好的文字排版技巧。如果实在不愿折腾，看下面，我已经折腾好了。</p>
<p>1.主要的文字排版参数</p>
<p><strong>字号</strong>，正文部分建议使用 14-16 号字体，我经常使用的是 15 号字体，手机上显示效果很不错；标题建议 16-22 号字体，我使用标题比较少，用的时候基本上是 16 号字体然后加粗。这个可以根据自己文章的需要进行调整，适合自己的才是最好的。</p>
<p><strong>行间距</strong>，行间距建议使用 1.5-2.0 倍左右，这样行之间不会显得太密集，看上去美观。我使用的是 1.75 倍，效果不错。</p>
<p><strong>字间距</strong>，我想这个参数也许很少人设置吧，字间距设置之后会给读者更好的阅读体验，建议设置为 1 像素，秀米可以设置，壹伴小插件也可以。</p>
<p><strong>页边距</strong>，页边距设置之后效果非常好，页边距就是页面有一定的留白，上篇也提到过。建议设置在 12-15 像素之间，设置留白太宽了也不好，我经常使用的是 12 像素。</p>
<p><strong>对齐方式</strong>，建议正文部分使用两端对齐的方式，这样在手机上显示出来会更加的整洁，不会出现长短不一的效果。</p>
<p>2.文字色彩搭配</p>
<p>文字色彩搭配方面，我之前试过不少的方案，最后找到了一个比较不错的配色方案，也形成了自己的一套配色方案。建议大家在文字色彩方面形成自己的一套体系，这样会增加你公众号的特点。具体配色方案建议，见下。</p>
<p>标题颜色：#f79646 | #3daad6 | #2e6e9e<br>正文颜色：#3f3f3f | #4f4f4f | #7f7f7f | #545454 | #595959，这几个颜色比较相近，但也可以看出差别。我使用的是 #595959。<br>注释颜色：#d99694 | #a5a5a5。</p>
<p>关于文字排版大概就是这些，使用上面介绍的这些就能做出很好的文字排版，能够形成自己的一套体系就更完美了。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>封面图</p>
<p>封面图对一篇文章具有很大的重要性，现在毕竟是看脸的时代。</p>
<p>怎么选择封面图？</p>
<p>对于如何选择封面图，前面已经提到了如何找到优质的图片。用作封面图有两个关键点，一个是要展示出文章主题，比如写一篇关于使用苹果电脑的文章，找一张苹果电脑的图片最合适不过了。第二是不要有太多的字，并且千万不要把标题的字放到封面图，如果和标题一样的字，那还有什么意义。</p>
<p>另外，在尺寸方面，建议图片比例保持在 9:5 的状态，因为微信官方给出封面尺寸是 900*500 像素。</p>
<p>推荐一款非常适合来做封面图的工具给大家，叫创客贴，地址：<a href="https://www.chuangkit.com/" target="_blank" rel="external">https://www.chuangkit.com/</a> ，我的文章封面图基本都是在创客贴上做。</p>
<p><img src="http://meto.chinakook.com/blog-images/%E5%85%AC%E5%8F%B7%E6%8E%92%E7%89%88_%E5%88%9B%E5%AE%A2%E8%B4%B4.png" alt=""></p>
<p>建议大家去试试它，很好用，在线做，做完下载，非常方便快捷。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>其他</p>
<p>关于公众号排版的重要东西差不多也就这些，如果再说几点的话，那就是摘要和预览了，我认为这两点也比较重要。</p>
<p><strong>摘要</strong>，关于摘要就简单说下吧。第一，形成自己的风格；第二，不要写过于冗长的摘要，一定不要，几个字能写明白你文章要写什么最好。</p>
<p><strong>预览</strong>，预览非常重要，常重要，重要，要！！！预览可以认真的查看是否有错别字，是否有排版问题，是否有语义错误、语句不通顺等问题，所以，一定要预览。</p>
<p>另外，建议大家把自己常用的样式做成模板保存在微信后台，比如顶部的引用、底部引导关注的图片等，这样在编辑新图文的时候就可以很方便的使用。</p>
<p>最后，给大家分享一个小技巧，当你在别人公众号看到喜欢的样式后，也想拿过来用怎么办呢？在电脑浏览器打开文章直接复制想要使用的样式或者效果，然后粘贴到自己的微信公众号后台，完事。你甚至可以把全文直接复制到你的后台，并且样式排版保持不变。这种方式简单粗暴，却非常有效。</p>
<p>ok，到此为止，公众号排版指南完结，其实想想就那么简单，没多少东西，我倒是啰嗦的不少。</p>
<p>另外我说明一件事，这两篇文章绝对不是在打广告，文中提到的所有产品都是我亲身体验之后，觉得好用才推荐给大家的。再者说了，我这个号才开几天，一共也没几个人，谁会来找我做广告啊。</p>
<p><br>ikook<br>2017.08.03</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;愚者用肉体监视心灵，智者用心灵监视肉体。&lt;br&gt;—— 李嘉诚&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首发于公众号，地址：&lt;a href=&quot;http://mp.weixin.qq.com/s/kzFSe-gxyQomRWhaGM90kw&quot; targ
    
    </summary>
    
      <category term="技术栈" scheme="http://ikookblog.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="公号运营" scheme="http://ikookblog.com/tags/%E5%85%AC%E5%8F%B7%E8%BF%90%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>公众号排版指南「上」</title>
    <link href="http://ikookblog.com/2017/08/01/wechat01/"/>
    <id>http://ikookblog.com/2017/08/01/wechat01/</id>
    <published>2017-07-31T16:00:00.000Z</published>
    <updated>2017-08-11T12:56:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>人生就像一本书，傻子们走马看花似的随手翻阅它，聪明的人用心地阅读它。因为他知道这本书只能读一次<br>—— 尚·保罗</p>
<blockquote>
<p>首发于公众号，地址：<a href="https://mp.weixin.qq.com/s/OuWsuIToMPE-md8_5PP5qA" target="_blank" rel="external">公众号排版指南「上」</a></p>
</blockquote>
</blockquote>
<p>说到公众号排版，也许是很多刚刚运营公号者的痛处，我也是。当初玩第一个公众号的时候，实在不明白别人怎么做出那些好看的样式和效果的。之后经过自己不停地折腾终于知道了是怎么回事，下面就和大家说说。</p>
<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>排版工具</p>
<p>随着微信的极速发展，公众号体量越来越大，随之产生了很多的排版工具，我自己也折腾过不少的第三方排版工具，可以说各有千秋，各有各的好处。下面几款是我比较常用的、也是比较好用的排版工具。</p>
<p><strong>i 排版</strong></p>
<p>地址：<a href="http://ipaiban.com/" target="_blank" rel="external">http://ipaiban.com/</a> 。i 排版是我比较喜欢的一个排版工具，它的特点是功能强大，有很多贴心的服务，比如新媒体课程之类的，不缺钱的可以去看看。还有就是它的界面与其他相比较为美观。</p>
<p><img src="http://meto.chinakook.com/blog-images/%E5%85%AC%E5%8F%B7%E6%8E%92%E7%89%88_i%E6%8E%92%E7%89%88.png" alt=""></p>
<p>i 排版会提供一些比较好玩的样式，而且还有一些公众号运营的经验技巧，很多都值得学习，所以推荐给大家。</p>
<p><strong>秀米</strong></p>
<p>地址：<a href="https://xiumi.us/" target="_blank" rel="external">https://xiumi.us/</a> 。秀米是很多人都在使用的排版工具，它的特点是样式较多，而且都很主流；秀米的排版器操作方便、简单，新手也可以很快上手，并且模板拖拽即用，非常方便。</p>
<p><img src="http://meto.chinakook.com/blog-images/%E5%85%AC%E5%8F%B7%E6%8E%92%E7%89%88_%E7%A7%80%E7%B1%B3.png" alt=""></p>
<p>它设置文字排版样式的功能非常好用，比如字与字之间的间距宽于标准间距，文章对于手机边框的留白间距等，这些都可以通过秀米设置。</p>
<p><strong>135 编辑器</strong></p>
<p>地址：<a href="http://www.135editor.com/" target="_blank" rel="external">http://www.135editor.com/</a> 。135 编辑器应该也是很多人在用的一款编辑器。它的最大特点就是：样式非常多，而且都很好看，并且一键复制到微信后台，非常方便。</p>
<p><img src="http://meto.chinakook.com/blog-images/%E5%85%AC%E5%8F%B7%E6%8E%92%E7%89%88_135%E7%BC%96%E8%BE%91%E5%99%A8.png" alt=""></p>
<p>使用 135 编辑器最好是注册一个账号，它上面很多样式需要收藏到样式库里面之后使用，可以选择自己喜欢常用的样式收藏，下次登录账号就可以直接使用。</p>
<p>135 编辑器有一点必须要介绍给大家，那就是 HTML 编辑模式，对于我们有开发能力的人来说简直是福音，可以玩出很多新花样。</p>
<p>建议有条件的人可以开一个会员，开通会员后使用起来更加的方便快捷，并且开通会员后所获得的权限和样式也会更多。</p>
<p><strong>壹伴·小插件（重点推荐）</strong></p>
<p>地址：<a href="https://yiban.io/" target="_blank" rel="external">https://yiban.io/</a> 。重点推荐，现在我写公号主要就是用它来完成，它的最大特点就是方便；可以直接在微信公众号后台使用，并且非常好用。</p>
<p><img src="http://meto.chinakook.com/blog-images/%E5%85%AC%E5%8F%B7%E6%8E%92%E7%89%88_%E5%A3%B9%E4%BC%B4.png" alt=""></p>
<p>壹伴·小插件可以安装在各大主流浏览器（Chrome、360、UC、猎豹等）。安装之后，它将会对微信公众号后台页面进行优化升级，提供一些非常实用的功能，比如两端缩进、字间距等。</p>
<p>具体先介绍下它提供的图文排版功能，后面再说它提供的其他功能。</p>
<p>图文排版：<br>排版增强，对后台自带的编辑器提供排版增强；素材导入，提供样式导入，可以将复制的样式直接导入到自己常用的样式库；编辑增强，表情包、GIF、无版权图等。</p>
<p>关于排版工具就说这些，能用好上面四个排版工具就不会为编辑不出精美图文而发愁了。对于上面提到的三个编辑器，建议大家抽出一段时间来好好看一下，把这些编辑器的样式、操作方式和风格都熟悉一下，做到流畅使用，这样以后做图文也就不会不知所措。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>图片排版</p>
<p>图片排版优先考虑的应该是好看的优质图片，下面先来看下如何找到优质的图片，然后再说图片排版。</p>
<p>怎么找到优质图片？</p>
<p><strong>高质量图片网站</strong><br>关于高质量的图片网站，我不会推荐太多，只推荐我经常使用的几个网站，有时候推荐太多了反而会让一些人不知道该怎么选择。不废话，上图，上链接（噢，对了，链接不能跳转，应该都知道，复制到浏览器吧）。</p>
<p>1.Pixabay，地址：<a href="https://pixabay.com/" target="_blank" rel="external">https://pixabay.com/</a><br>这个网站上的所有图片都是没有版权的，可以随意使用， 这是一个非常大的好处，优先推荐。</p>
<p><img src="http://meto.chinakook.com/blog-images/%E5%85%AC%E5%8F%B7%E6%8E%92%E7%89%88_Pixabay.png" alt=""></p>
<p>2.500px，地址：<a href="https://500px.com/" target="_blank" rel="external">https://500px.com/</a> ，简直不要太美。</p>
<p><img src="http://meto.chinakook.com/blog-images/%E5%85%AC%E5%8F%B7%E6%8E%92%E7%89%88_500px.png" alt=""></p>
<p>3.Flickr，地址：<a href="https://www.flickr.com/" target="_blank" rel="external">https://www.flickr.com/</a> ，雅虎旗下产品，要想访问，你懂得。</p>
<p><img src="http://meto.chinakook.com/blog-images/%E5%85%AC%E5%8F%B7%E6%8E%92%E7%89%88_Flickr.png" alt=""></p>
<p>我就推荐这几个，优质图片网站还有很多，像 “花瓣网”、“全景网” 等，推荐多了反而会影响大家选择，可以自己去这几个网站看看，找几个比较喜欢的长期使用。</p>
<p><strong>图片搜索引擎</strong><br>图片搜索引擎也有不少，比如：Google 图库、百度图库、必应图库，还有就是站酷。关于图片搜索引擎我优先推荐 Google 图库，数据库非常强大，搜索结果的可选择性也非常大，来张图体验下。</p>
<p><img src="http://meto.chinakook.com/blog-images/%E5%85%AC%E5%8F%B7%E6%8E%92%E7%89%88_Google.png" alt=""></p>
<p><img src="http://meto.chinakook.com/blog-images/%E5%85%AC%E5%8F%B7%E6%8E%92%E7%89%88_Google01.png" alt=""></p>
<p>搜索出来结果非常精准，并且质量非常高。不过，要想访问，还是那句话，你懂得。这就是为什么刚才要提百度图库的原因，如果实在看不到外面的世界，那就用百度图库吧，当然还可以用站酷（地址：<a href="http://www.zcool.com.cn/" target="_blank" rel="external">http://www.zcool.com.cn/</a> ）。</p>
<p>再给大家推荐一个图片采集工具，就是上面提到的「壹伴·小插件」，它提供了几种对图片采集和上传图片到素材库的功能。下面介绍给大家：</p>
<p>一键采图，可以对网页上喜欢的图片一键采取，图片就自动上传到微信素材库；截屏上传，插件提供网页截屏功能，截屏直接上传到素材库；手机相册传图，手机微信关注「壹伴助手」公众号，只需发送图片到公众号，就可以上传到素材库；桌面传图，可以使用壹伴本地上传器，只需将图片拖动到桌面的同步文件夹即可上传。</p>
<p>好了，关于怎么找优质图片就说这些，还有其他途径，大家有兴趣的自己折腾。</p>
<p>怎么设置图片尺寸？</p>
<p>很多人排版都不会在意图片尺寸，以为只要在手机上显示出来就好了，其实这是完全错误的观念。一篇好的图文里面包含的每一张图片的尺寸应该差不多都是统一的，这样整篇文章在手机和电脑上显示出来会非常的美观。图片尺寸建议设置为宽度 900px，保持宽高比不变。</p>
<p>怎么进行图片排版？</p>
<p>图片加入文章之后一定要把对齐方式设置为居中，这样可以保证在电脑上查看文章时也很整齐美观。</p>
<p>再就是留白，留白已经成为一种主流的排版方式，留白会给人以美观的感受，所以建议在文字和图片之间留一行空白，这样看上去会更加美观，同时在手机上阅读体验会更好。</p>
<p>PS: 本来想要一篇文章写完，但由于篇幅较长，就分成了两篇，下篇已经写好。如果你等不了下次推送，可在公众号后台回复「公众号排版指南下」获取。</p>
<p><br>ikook<br>2017.08.01</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人生就像一本书，傻子们走马看花似的随手翻阅它，聪明的人用心地阅读它。因为他知道这本书只能读一次&lt;br&gt;—— 尚·保罗&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首发于公众号，地址：&lt;a href=&quot;https://mp.weixin.qq.com/s
    
    </summary>
    
      <category term="技术栈" scheme="http://ikookblog.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="公号运营" scheme="http://ikookblog.com/tags/%E5%85%AC%E5%8F%B7%E8%BF%90%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>你付费了吗？</title>
    <link href="http://ikookblog.com/2017/07/28/essay01/"/>
    <id>http://ikookblog.com/2017/07/28/essay01/</id>
    <published>2017-07-27T16:00:00.000Z</published>
    <updated>2017-08-16T15:05:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>时间是世界上的一切成就的土壤。时间给空想者痛苦，给创造者幸福。  —— 麦金西</p>
</blockquote>
<a id="more"></a>
<p>今天的重点不是时间，上面的引用语也许会误导你。今天，我要和你们说说付费。付费省下来的就是时间，所以拿时间做引用也就合理了。</p>
<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>免费，免除费用，也就是不要钱。可免费真的就是「免费」吗？免费，免掉的是钱，可付出的是时间和效率成本。</p>
<p>之前一直想学习投资理财，可苦于不知道如何入手迟迟没有接触。前些日子无意中在一位前辈的博客中看到「21 天小白理财训练营」，付费，9 块钱。钱很少，但就是有人不买单。</p>
<p>我加了，因为最起码能让我了解理财是个什么东西，能让我了解以后怎么去学。我之前一直自己找书，找资料看，光找资料就花费很多时间，然后看到各种术语、各种看不懂，就放弃了。付出了时间不说，关键是还什么都没有学到。</p>
<p>前天「21 天小白理财训练营」结束了，我知道了到底什么是理财，知道了常见的理财产品有哪些，知道了哪些产品低风险低收入，哪些产品高风险高收入，还知道了以后该怎么继续深入学习理财。对了，我还在华泰证券开了户，就是用于买股票和基金的账户。这就是我花 9 块钱得到的东西，结束的时候还抢了 6 块钱的红包，比我自己折腾半年学到得多的多。</p>
<p>松浦太郎说过：“想要真正学到东西，就得花钱”，这件事正好说明了这个道理。</p>
<p>其实我不能理解，为什么社会上每天都有人想要绞尽脑汁去免费学东西。学习这件事，免费的东西，永远是最昂贵的。除了钱之外，你必然要花掉人际、时间、心情等各方面的成本。这个世界上，好的、可共享的资源或思想，必然是别人付出心血的结果，为别人的时间和精力还有知识成本付费，是现代人的基本操守。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>为什么付费的东西就能够快速掌握？</p>
<p>付过费的东西，下意识就会去重视，因为你花了钱。花了钱的东西你会不在意吗？不会。并且花钱买的东西，是别人花时间和精力打磨出来的，必然会是一套整体的事物，省去了自己筛选和过滤的时间，自然就能够快速掌握。往往自己折腾过程中会偏离主线，会走错路。</p>
<p>在这个时代，我们要努力培养的，是维系雇佣关系的能力，而不是人情关系的能力。</p>
<p>很多人，有些事情需要别人帮助，第一时间想到的是亲戚，而不是雇佣劳动力。但往往最后发现反而不比请一个需要的专业人员来的轻松。那是因为，你没办法展现出你雇主的本色，不能坦率的提出你的需求，达到一种合作的平衡，所以，往往找朋友找亲戚帮助永远觉得很累很疲倦。</p>
<p>一旦成为了雇主，你们的关系就不一样了。关系就是一切，一切为了关系。相比人情，雇佣关系是最飒爽的关系，它让你们双方都绽放出最舒服的工作状态。不满意的雇员可以一换再换，换到满意为止，亲戚朋友你能这样吗？</p>
<p>其实，我们就生活在一个雇佣的时代，每天我们每个人都在服务别人，也被别人服务。有些人会觉得自己很迷茫，生活没有改进，那是因为，你既不知道怎么服务别人，也不知道如何服务自己、如何被别人服务。</p>
<p>如果不知道，那就去花钱吧，从花钱开始，花小钱开始。</p>
<p>花钱是一门艺术，一旦开始把钱花对了地方，你的状态就活了，你的人际关系，你的专业，你的社交，你的眼界，随即就会开始发生变化。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>那么该如何花钱呢？</p>
<p>不管你现在一个月有多少收入，你一定要养成每个月「 为自己的未来花点钱的习惯」，一开始，最低要把这个标准订到 5%，以后根据自己的经济实力调整。</p>
<p>就好比我一个月有 1500 元的生活费，我每月都会拿出 200 元花给未来的自己。</p>
<p>怎么花呢？为一切优质内容付费。</p>
<p>订阅对你有用的内容。比如我加入了刘欣老师组织的「2017编程能力提高社群」，每季 300 元，一季 3 个月，时长为一年；我还加入了stormzhang 的小密圈，一年 129 元；我还准备学习长投学堂的投资理财初级课；我每月都会买书，技术类、文学类等都有。这些都是为优质内容付费。</p>
<p>这些优质内容，都会结结实实长在我的气质和见识上，就算我很瘦弱。我相信 30 岁之后，我就会知道我是如何成为一个更好的人的。</p>
<p>当你学会花钱的时候，周围人的才会觉得你是一个不为花钱拧巴的人， 才会愿意和你分享更多的资源。就好比 stormzhang （开发者，目前做管理，维护了一个优质的公众号）做付费订阅的时候，就是因为我懂得为他的内容赞赏，所以才邀请了我。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>学会远离一切免费的东西。</p>
<p>在这个信息爆炸的时代，有很多免费的东西已经可以让我们生活得比较好，不花钱也不会有什么问题。</p>
<p>可是你想想，你会为免费的东西付出多少钱之外的东西，时间、精力哪样都比钱值钱。慢慢你会发现，你通过免费所得永远都不比你花钱所得到的来容易和轻松，并且你花的时间要比付费多得多。</p>
<p>我们整个社会正在进入转型期，很多东西都会收费，很多人都会为优质内容付费。未来你是否进步，一定是我们能否自己拿钱去买别人的技能、思想，你有多愿意为知识付费，你就成长得有多快。未来最值钱的， 一定是你需要为别人的专业付费。</p>
<p>你为别人的思想输出付费，他们有了经济输入，才能更好地输出。这个时代，一定要学会付费，一定要学会远离免费的东西。这个观念一定要有。学会了为优质内容付费，你就会收获金钱以外的很多东西，知识、时间、气质、内涵 …</p>
<p><br>ikook<br>2017.07.28</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时间是世界上的一切成就的土壤。时间给空想者痛苦，给创造者幸福。  —— 麦金西&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔集" scheme="http://ikookblog.com/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
      <category term="随笔" scheme="http://ikookblog.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="http://ikookblog.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>这次，我认真了</title>
    <link href="http://ikookblog.com/2017/07/27/2017.07.27-gnosis/"/>
    <id>http://ikookblog.com/2017/07/27/2017.07.27-gnosis/</id>
    <published>2017-07-26T16:00:00.000Z</published>
    <updated>2017-08-11T12:40:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>没有人知道自己将来会从事何种职业，认真对待每一件事才是最重要的。—— (美)特怀拉·萨普<br><a id="more"></a></p>
<blockquote>
<p>文在公众号首发，原文：<a href="https://mp.weixin.qq.com/s/zO66EnIWROhv0xbpxhl0nQ" target="_blank" rel="external">这次，我认真了</a>。底部可扫码关注</p>
</blockquote>
</blockquote>
<p>我是 ikook，也许你并不知道我是谁，也许你在其他地方了解过我。但，今天我们在这里相遇便是缘分。</p>
<p>两年间我断断续续玩过三个公众号，包括你正在的看这一个。前两个我都没有认真的对待过，并且都没有坚持维护下来，都被我无情的丢在那里，可以说是任何人都不得而知。</p>
<p>第二号我曾试图维护，但好景不长，连续推送一周之后，被我的感冒所打倒，再也没有起来过。那时也许是真想好好维护下去，可唯独没有非常认真的对待，不然也不会因为一个小小的感冒就放弃了。我想就算没有那场感冒，也会给自己找无数个理由放弃。</p>
<p>那次感冒之后，我不光放弃维护公号，好像也放弃了自己。我开始停止学习，停止前进的脚步，停止了一切让我有所成长的做法。我开始各种玩游戏，整天混迹在王者大陆不能自拔。</p>
<p>这一切都是人的惰性所指使，你没有以一颗坚定不移的心开始，抱着试试的心态，注定要失败。可这次，我认真了。</p>
<p>我认真了，不知道原因，也许是因为自己颓废了太久，也许是因为连自己都开始讨厌游离状态下的自己，也许我就是想认真干一件事。无论什么原因，我就想把这件事坚持下去。每天有那么一件事总在提醒着我，鞭策着我，也许改变就会发生在不知不觉中。</p>
<p>有人会问，为什么选择了这种方式呢，为什么要写公众号呢？我不知道啊，想写。我热爱文字，喜欢记录。有个能够记录自己成长的地方不是很好吗。你不是有博客吗？我想利用这种方式让更多人知道我，我想换种方式改变自己，想要用不同的方式来激励自己。</p>
<p>今天我看了自己在 17 年年初写下的文章（想看这篇文章点击下方阅读原文）。想来惭愧，定下的目标慢慢都忘记了，忘记了去履行自己的诺言，忘记了自己定下的目标 —— 学习的目标、生活的目标。当初定下的学习目标包括「继续学习 Android、Java、React Native、英语、阅读还有实习等」，看到这也许会问，这么多学的过来么？其实如果把这些任务量化到一年当中去学习是很轻松的事情。</p>
<p>我会拾起年初定下的目标，努力把每件事情做好。同时，我会用心认真的去维护这个公众号，我会坚持下去。我在写下这篇文章的时候就已经下定决心了，改变自己。不为了什么，就为了看看自己还有救没。在此立个 flag，17 年年末，完成年初定下的目标；认真维护公号和博客；认真对待每一天。</p>
<p>改变从现在开始，我就想认认真真的做自己，不要再混下去，况且我还有理想，我还有梦。</p>
<p><br>ikook<br>2017.07.27</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;没有人知道自己将来会从事何种职业，认真对待每一件事才是最重要的。—— (美)特怀拉·萨普&lt;br&gt;
    
    </summary>
    
      <category term="随笔集" scheme="http://ikookblog.com/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
      <category term="随笔" scheme="http://ikookblog.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="http://ikookblog.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="感悟" scheme="http://ikookblog.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 常用命令归纳</title>
    <link href="http://ikookblog.com/2017/07/24/mysql_crash_course/"/>
    <id>http://ikookblog.com/2017/07/24/mysql_crash_course/</id>
    <published>2017-07-23T16:00:00.000Z</published>
    <updated>2017-08-06T13:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>《MySQL 必知必会》学习总结&amp;&amp;常用命令归纳，看完这篇文章就不用买《MySQL 必知必会》了，这篇就够了。</p>
</blockquote>
<h2 id="数据库基础概念-amp-amp-什么是-SQL、MySQL"><a href="#数据库基础概念-amp-amp-什么是-SQL、MySQL" class="headerlink" title="数据库基础概念&amp;&amp;什么是 SQL、MySQL"></a>数据库基础概念&amp;&amp;什么是 SQL、MySQL</h2><h3 id="数据库基础概念"><a href="#数据库基础概念" class="headerlink" title="数据库基础概念"></a>数据库基础概念</h3><ul>
<li><strong>数据库(database)</strong> 保存有组织的数据的容器(通常是一个文件或者一组文件)。<br><br></li>
<li><strong>表(table)</strong> 某种特定类型数据的结构化清单。<br><br></li>
<li><strong>模式(schema)</strong> 关于数据库和表的布局及特定的信息。<br><br>模式可以用来描述数据库中特定的表以及整个数据库(和其中表的关系)。<br><br></li>
<li><strong>列(column)</strong> 表中的一个字段。所有表都是由一个或者多个列组成的。<br><br></li>
<li><strong>数据类型(datatype)</strong> 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。<br><br></li>
<li><strong>行(row)</strong> 表中的一个记录。<br><br></li>
<li><strong>主键(primary key)</strong> 一列（或一组列），其值能够唯一区分表中每个行。<br>主键的条件：<br>1.任意两行都不具有相同的主键值；<br>2.每个行都必须具有一个主键值（主键列不允许 NULL 值）</li>
</ul>
<h3 id="什么是-SQL"><a href="#什么是-SQL" class="headerlink" title="什么是 SQL"></a>什么是 SQL</h3><p>SQL 是结构化查询语言（Structured Query Language）的缩写。SQL 是一种专门用来与数据库通信的语言。</p>
<h5 id="SQL-有以下优点："><a href="#SQL-有以下优点：" class="headerlink" title="SQL 有以下优点："></a>SQL 有以下优点：</h5><ul>
<li>SQL 不是某个特定数据库供应商专有的语言。几乎所有重要的 DBMS 都支持 SQL，所以，学习此语言几乎能与所有数据库打交道。<br><br></li>
<li>SQL 简单易学。它的语句全都是由描述性很强的英语单词组成，而且这些单词的数目不多。<br><br></li>
<li>SQL 尽管看上去很简单，但它实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库错操作。</li>
</ul>
<h3 id="什么是-MySQL"><a href="#什么是-MySQL" class="headerlink" title="什么是 MySQL"></a>什么是 MySQL</h3><p>数据的所有存储、检索、管理和处理实际上是由数据库软件 —— DBMS（数据库管理系统）完成的。MySQL 是一种 DBMS，即它是一种数据库软件。</p>
<h5 id="MySQL-的优点："><a href="#MySQL-的优点：" class="headerlink" title="MySQL 的优点："></a>MySQL 的优点：</h5><ul>
<li>成本 —— MySQL 是开放源代码的，一般可以免费使用（甚至可以免费修改）。<br><br></li>
<li>性能 —— MySQL 执行很快，非常快。<br><br></li>
<li>可信赖 —— 某些非常重要和声望很高的公司、站点使用 MySQL，这些公司和站点都用 MySQL 来处理自己的重要数据。<br><br></li>
<li>简单 —— MySQL 很容易安装和使用。</li>
</ul>
<h2 id="使用-MySQL-的常用命令归纳（前方高能，很长，很详细）"><a href="#使用-MySQL-的常用命令归纳（前方高能，很长，很详细）" class="headerlink" title="使用 MySQL 的常用命令归纳（前方高能，很长，很详细）"></a>使用 MySQL 的常用命令归纳（前方高能，很长，很详细）</h2><h3 id="USE-mysql"><a href="#USE-mysql" class="headerlink" title="USE mysql;"></a>USE mysql;</h3><p>  输出：<code>Database changed</code><br>  分析：选择并打开「mysql」这个数据库，记住，必须先使用 USE 打开数据库，才能读取其中的数据。</p>
<blockquote>
<p>注：这里的 mysql 是指所选数据库的名字。该数据库是 MySQL 软件内部使用的数据库。</p>
</blockquote>
<h3 id="SHOW-语句"><a href="#SHOW-语句" class="headerlink" title="SHOW 语句"></a>SHOW 语句</h3><ul>
<li><code>SHOW DATABASES;</code><br><br>分析：返回一个可用的数据库列表。该列表中可能包含 MySQL 内部使用的数据库。<br><br></li>
<li><code>SHOW TABLES;</code><br><br>分析：获得一个所选数据库内的表的列表，即返回当前选择的数据库内可用表的列表。<br><br></li>
<li><code>SHOW COLUMNS FROM test_table;</code><br><br>分析：返回要求显示的表的表列。<code>SHOW COLUMNS</code> 要求给出一个表名(这里例子中的 FROM test_table，test_table 为表名)，它对每个字段返回一行，行中包括字段名、数据类型、是否允许 NULL、键信息、默认值以及其他信息。<br><br>注：DESCRIBE 语句，MySQL 支持用 DESCRIBE 作为 SHOW COLUMNS FROM 的一种快捷方式。即 <code>DESCRIBE test_table;</code> 是 <code>SHOW COLUMNS FROM test_table;</code> 的一种快捷方式。<br><br></li>
<li>所支持的其他 <code>SHOW</code> 语句还有：<br><br>1.<code>SHOW STATUS;</code> 用于显示广泛的服务器状态信息；<br><br>2.<code>SHOW CREATE DATABASE;</code> 和 <code>SHOW CREATE TABLE;</code> 分别用来显示创建特定数据库或表的 MySQL 语句；<br><br>3.<code>SHOW GRANTS;</code> 用来显示授予用户（所有用户或特定用户）的安全权限；<br><br>4.<code>SHOW ERRORS;</code> 和 <code>SHOW WARNINGS;</code> 用来显示服务器错误或者警告信息。<br><blockquote>
<p>注：在 MySQL 命令行程序中，执行命令 <code>HELP SHOW</code> 显示允许操作的 SHOW 语句。</p>
</blockquote>
</li>
</ul>
<h3 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h3><p>最经常使用的 SQL 语句可能就是 SELECT 语句了，它的用途是从一个或多个表中检索信息。为了使用 SELECT 检索表数据，必须至少给出两条信息 —— 想选择什么，以及从什么地方选择。</p>
<blockquote>
<p>注：以下例子使用的数据库、表名、以及表列等如下：<br>数据库：<br>crashcourse<br>表：<br><img src="http://meto.chinakook.com/blog-images/mysql/tables.png" alt="SHOW TABLES"><br><br>表列：</p>
<ul>
<li>customers<br><img src="http://meto.chinakook.com/blog-images/mysql/customers.png" alt=""><br><br></li>
<li>orderitems<br><img src="http://meto.chinakook.com/blog-images/mysql/orderitems.png" alt=""><br><br></li>
<li>orders;<br><img src="http://meto.chinakook.com/blog-images/mysql/orders.png" alt=""><br><br></li>
<li>productnotes;<br><img src="http://meto.chinakook.com/blog-images/mysql/productnotes.png" alt=""><br><br></li>
<li>products;<br><img src="http://meto.chinakook.com/blog-images/mysql/products.png" alt=""><br><br></li>
<li>vendors;<br><img src="http://meto.chinakook.com/blog-images/mysql/vendors.png" alt=""></li>
</ul>
</blockquote>
<h4 id="检索单个列"><a href="#检索单个列" class="headerlink" title="检索单个列"></a>检索单个列</h4><p>输入：<code>SELECT prod_name FROM products;</code><br>分析：上述语句利用 SELECT 语句从 products 表中检索一个名为 prod_name 的列。所需的列名在 SELECT 关键字之后给出，FROM 关键字指出从其中检索数据的表名。</p>
<blockquote>
<p>注： 输出的结果为未排序的数据；SQL 语句是不区分大小写的，但是建议对所有 SQL 关键字使用大写，而对所有列和表名使用小写，这样做有助于使代码更加易于阅读和调试。</p>
</blockquote>
<h4 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h4><p>输入：<code>SELECT prod_id, prod_name, prod_price FROM products;</code><br>分析：从一个表中检索多个列，和前一个例子使用相同的 SELECT 语句，唯一不同的地方是必须在 SELECT 关键字后给出多个列名，列名之间必须用逗号分隔。</p>
<h4 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h4><p>输入：<code>SELECT * FROM products;</code> 命令<br>分析：如果给定一个通配符*，则返回表中所有列。列的顺序一般是列在表定义中出现的顺序。</p>
<blockquote>
<p>注： 一般，除非你确实需要表中的每个列，否则最 好别使用*通配符。虽然使用通配符可能会使你自己省事，不 用明确列出所需列，但检索不需要的列通常会降低检索和应 用程序的性能。</p>
</blockquote>
<h4 id="检索不同的行"><a href="#检索不同的行" class="headerlink" title="检索不同的行"></a>检索不同的行</h4><p>如何检索出有不同值的列表呢？解决办法是使用 DISTINCT 关键字，顾名思义，此关键字指示 MySQL 只返回不同的值。</p>
<p>输入：<code>SELECT DISTINCT vend_id FROM products;</code><br>分析：SELECT DISTINCT vend_id 告诉 MySQL 只返回不同（唯一）的 vend_id 行。如果使用 DISTINCT 关键字，它必须直接放在列名的前面。</p>
<blockquote>
<p>注：不能部分使用 DISTINCT。DISTINCT 关键字应用于所有列而不仅是前置它的列。如果给出 SELECT DISTINCT vend_id, prod_price，除非指定的两个列的值相同，否则所有行都将被检索出来。<br>如下：<br>没有使用 DISTINCT 关键字<br><img src="http://meto.chinakook.com/blog-images/mysql/no_distinct.png" alt=""><br><br><br>使用 DISTINCT 关键字<br><img src="http://meto.chinakook.com/blog-images/mysql/distinct.png" alt=""></p>
</blockquote>
<h4 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h4><p>输入：<code>SELECT prod_name FROM products LIMIT 5;</code><br>分析：为了返回第一行或者前几行，可使用 LIMIT 子句。此语句使用 SELECT 语句检索单个列。LIMIT 5 指示 MySQL 返回不多于5行。</p>
<p>为得出下一个 5 行，可指定要检索的开始行和行数。</p>
<p>输入：<code>SELECT prod_name FROM products LIMIT 5,5;</code><br>分析：LIMIT 5, 5 指示 MySQL 返回从行 5 开始的 5 行。第一个数为开始位置，第二个数为要检索的行数。</p>
<p>所以，带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始。</p>
<blockquote>
<p>注：检索出来的第一行为行 0 而不是行 1。因此，LIMIT 1, 1将检索出第二行而不是第一行；MySQL 5 支持 LIMIT 的另一种替代语法。LIMIT4OFFSET 3意为从行 3 开始取 4 行，就像 LIMIT 3, 4 一样。</p>
</blockquote>
<h4 id="使用完全限定的表名"><a href="#使用完全限定的表名" class="headerlink" title="使用完全限定的表名"></a>使用完全限定的表名</h4><p>到此为止使用的 SQL 例子只通过列名引用列。也可能会使用完全限定的名字来引用列（同时使用表名和列字）。请看以下例子：</p>
<p>输入：<code>SELECT products.prod_name FROM products;</code><br>分析：这条语句在功能上和 <code>SELECT prod_name FROM products;</code> 语句是一样的。但这里指定了一个完全限定的列名。</p>
<p>表名也是可以完全限定的，例如：<code>SELECT products.prod_name FROM crashcourse.products;</code> 这条语句和刚才的那条语句是一样的。</p>
<h3 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h3><p>如何使用 SELECT 语句的 ORDER BY 子句，根据需要排序检索出来的数据呢？下面我们来看一下。</p>
<h4 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h4><p>我们上面使用 SELECT 语句检索出来的数据都是没有经过排序的。关系数据库理论认为，如果不明确规定排序顺序，则不应该假定检索出来的数据的顺序有意义。</p>
<p>为了明确地排序用 SELECT 语句检索出来的数据，可使用 ORDER BY 子句。</p>
<p>输入：<code>SELECT prod_name FROM products ORDER BY prod_name;</code><br>分析：<br>未完待续…</p>
<p><br>ikook<br>2017.07.24</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《MySQL 必知必会》学习总结&amp;amp;&amp;amp;常用命令归纳，看完这篇文章就不用买《MySQL 必知必会》了，这篇就够了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数据库基础概念-amp-amp-什么是-SQL、MySQL&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="数据库" scheme="http://ikookblog.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://ikookblog.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://ikookblog.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>如果你很忙，你一定在什么地方做错了</title>
    <link href="http://ikookblog.com/2017/06/18/view-text-01/"/>
    <id>http://ikookblog.com/2017/06/18/view-text-01/</id>
    <published>2017-06-17T16:00:00.000Z</published>
    <updated>2017-07-02T10:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文为观文记，原文链接：<a href="http://www.jianshu.com/p/4dc3518089a0" target="_blank" rel="external">http://www.jianshu.com/p/4dc3518089a0</a></p>
</blockquote>
<a id="more"></a>
<p>如果你很忙，你一定是在什么地方做错了。我们不应艰苦地工作，而应艰苦工作。艰苦工作不是艰苦地工作，两个有本质的区别。如果你的目标是为了创造一种卓越的人生和生活，那么，忙碌和精疲力竭就是你最大的敌人。</p>
<h2 id="柏林研究项目"><a href="#柏林研究项目" class="headerlink" title="柏林研究项目"></a>柏林研究项目</h2><p>1990 年初，三名心理学家组成研究小组拜访了柏林艺术大学。他们此行的目的是为了专门研究小提琴演奏者。</p>
<p>他们分别对比研究了两个小组：优秀演奏者小组、普通演奏者小组。这三位研究者参照不同主题安排了一系列的深度访谈。他们给了两个小组的每个成员人手一册日记本，日记本把每 24 小时划分为一个个 50 分钟的时间区块。他们请小组成员返回宿舍并且要求他们对今后每天的活动情况进行详细的记录。</p>
<center> <img src="http://meto.chinakook.com/blog-images/view-text-01.jpg" alt="Violinist Diana Yukawa"> </center><br><center> <em>Violinist Diana Yukawa</em> </center>

<p>研究者们希望通过这些数据分析出一个最基本的问题： <strong>为什么优秀演奏者比普通演奏者更加出色？</strong></p>
<h2 id="解密优秀演奏者模式"><a href="#解密优秀演奏者模式" class="headerlink" title="解密优秀演奏者模式"></a>解密优秀演奏者模式</h2><p>在时间上，<strong>两个小组花费在音乐上的时间，平均计算的话，几乎完全一样（大约每周 50 个小时）。</strong> 差异在于他们如何利用这些时间。<strong>优秀演奏者在刻意练习「deliberate practice」上投入的时间几乎是普通演奏者的三倍。</strong></p>
<p>研究者们着手研究这些学生到底是如何安排他们的时间的。那些<strong>普通演奏者</strong>，他们发现，把正常的音乐课业和练习分配在一个全天范围。他们几乎均匀地分配了学习和练习的时间。<strong>优秀演奏者</strong>，与之形成强烈的对比，优秀演奏者把他们的学习和练习都集中在两个预先精心规划好的时段。这两个时段分别为：早上、下午。</p>
<p>这种将课业学习和休闲生活相互隔离的做法，已经在这些演奏者生活的其他方面产生了相应的影响。睡眠就是一个很好的例证：<strong>优秀演奏者平均来说，要比普通演奏者在睡眠方面至少多出一个小时。</strong></p>
<p>再来看看演奏者们的放松和休闲活动。统计显示，<strong>优秀演奏者的休闲时间要大大多于普通演奏者，</strong> 而且，那些最佳演奏者，精英中的精英，在放松和休闲上的时间花费更加突出。</p>
<h2 id="艰苦工作「Hard-Work」不同于艰苦地工作「Hard-to-Do-Work」"><a href="#艰苦工作「Hard-Work」不同于艰苦地工作「Hard-to-Do-Work」" class="headerlink" title="艰苦工作「Hard Work」不同于艰苦地工作「Hard to Do Work」"></a>艰苦工作「Hard Work」不同于艰苦地工作「Hard to Do Work」</h2><p>针对研究结果的结论：</p>
<ul>
<li>普通演奏者花费练习时间和优秀演奏者一样多<br><br></li>
<li>普通演奏者没有将主要精力用在必要的练习类型上「在一些关键性的刻意练习上花费的时间几乎只有优秀演奏者的三分之一」<br><br></li>
<li>普通演奏者将其学习和练习时间近乎随意地安排在一天之中。因此，即使他们花费在课业上时间不比优秀演奏者更长的话，他们每天用于睡眠的时间也会减少，而且在心理方面同样会感受到更多的压力。不言而明，在小提琴演奏方面，他们仍然会处于平庸的状态。</li>
</ul>
<p>柏林研究提供了一项重要的实验依据，证明了艰苦工作与艰苦地工作之间的差异：</p>
<ul>
<li><strong>艰苦工作</strong> 就是刻意练习。当你进行这些刻意练习时，它其实很缺乏趣味性，但是你没有必要在一天中过多地进行这项活动。刻意练习提供了一个可测量技能进展的工具 - 它可以让你产生强烈的满足感和足够的动机。因而，尽管刻意练习的确非常辛苦，但他不会使你精疲力尽，而且它还可以很好地与轻松和惬意生活相融合。<br><br></li>
<li><strong>艰苦地工作</strong>，与之恰恰相反，它几乎让你精疲力竭。你一整天都处在一种错误的忙碌状态中。就像来自柏林研究报告中那些普通演奏者一样，不断感受疲惫和压力。但同时，正如你所看到的，对你的实际成就或能力的改进却只能产生很小的影响。</li>
</ul>
<p>这项分析引发了一个重要的结论。无论你是一名学生，还是一名正走在职业发展道路上的专业人士，<strong>如果你的目标是为了创造一种卓越的人生和生活，那么，忙碌和精疲力竭就是你最大的敌人。</strong> 如果你正在经历周而复始的工作或生活压力，你一定是在什么地方做错了！你就是那些来自柏林艺术大学的普通演奏者 - 而不是优秀演奏者。你将你的生活（错误地）构建在艰苦地工作之上，而不是（正确的）艰苦工作。</p>
<p>这项研究报告建议的解决方案，正如我经常倡导的那样，超乎寻常的简单：Do less 。但必须全情投入，而且聚焦在关键环节。在你完成它们之后，请尽情享受一天之中的剩余时光并且快乐地生活吧。</p>
<h2 id="我的感悟"><a href="#我的感悟" class="headerlink" title="我的感悟"></a>我的感悟</h2><p>这篇文章很好的讲述了「艰苦工作」与「艰苦地工作」 的区别。我们应当在学习提高时全身心的投入其中，并享受其中的乐趣。在完成任务或者疲倦之后尽情享受欢乐的时光，释放自己，尽情玩耍，喝杯农药。主题是，不要让自己陷入 <strong>假学习</strong> 的状态，千万不要每天都在学习，却不知道自己在干什么，到头来学习娱乐两悲伤，抛弃了惬意的生活更远离了优秀的自己。</p>
<p>如果你的目标是为了创造一种卓越的人生和生活，那么，忙碌和精疲力竭就是你最大的敌人 | 刻意练习很重要 | Do less</p>
<hr>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27506733&auto=1&height=66"></iframe></p>
<center> Oh Father，Happy Father’s Day </center>

<p><br><br><br>ikook<br>2017.06.18</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文为观文记，原文链接：&lt;a href=&quot;http://www.jianshu.com/p/4dc3518089a0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/4dc3518089a0&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="观文记" scheme="http://ikookblog.com/categories/%E8%A7%82%E6%96%87%E8%AE%B0/"/>
    
    
      <category term="感悟" scheme="http://ikookblog.com/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="观文" scheme="http://ikookblog.com/tags/%E8%A7%82%E6%96%87/"/>
    
      <category term="学习技巧" scheme="http://ikookblog.com/tags/%E5%AD%A6%E4%B9%A0%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin-开始</title>
    <link href="http://ikookblog.com/2017/06/16/kotlin01/"/>
    <id>http://ikookblog.com/2017/06/16/kotlin01/</id>
    <published>2017-06-15T16:00:00.000Z</published>
    <updated>2017-07-02T10:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Kotlin 从入门到放弃–开始</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是-Kotlin"><a href="#什么是-Kotlin" class="headerlink" title="什么是 Kotlin"></a>什么是 Kotlin</h2><p>简单来说，Kotlin 是一门由「JetBrains」开发的基于 JVM 的静态类型编程语言，它 100% 兼容 Java。</p>
<p>它可以用于：</p>
<ul>
<li>服务器开发</li>
<li>Android 开发</li>
<li>前端开发</li>
<li>本地执行程序</li>
</ul>
<p>这是要全栈的节奏啊，它的目标应该就是要成为一门全栈编程语言。</p>
<h3 id="维基百科介绍"><a href="#维基百科介绍" class="headerlink" title="维基百科介绍"></a>维基百科介绍</h3><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，它也可以被编译成为 JavaScript 源代码。它主要是由俄罗斯圣彼得堡的 JetBrains 开发团队所发展出来的编程语言，其名称来自于圣彼得堡附近的科特林岛。2012 年 1 月，著名期刊《 Dr. Dobb’s Journal 》中 Kotlin 被认定为该月的最佳语言。虽然与 Java 语法并不兼容，但 Kotlin 被设计成可以和 Java 代码相互运作，并可以重复使用如 Java 集合框架等的现有 Java 类库。</p>
<h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><p>2011 年 7 月，JetBrains 推出 Kotlin 项目，这是一个面向 JVM 的新语言，它已被开发一年之久。JetBrains 负责人Dmitry Jemerov 说，大多数语言没有他们正在寻找的特性，Scala 除外，他指出了 Scala 的编译时间慢这一明显缺陷。Kotlin 的既定目标之一是像 Java 一样快速编译。</p>
<p>2012 年 2 月，JetBrains 以 Apache 2 许可证开源此项目，Jetbrains 希望这个新语言能够推动 IntelliJ IDEA 的销售。</p>
<p>Kotlin v1.0 于 2016 年 2 月 15 日发布。这被认为是第一个官方稳定版本，并且 JetBrains 已准备从该版本开始的长期向后兼容性。</p>
<p>在 Google I/O 2017 中，Google 宣布在 Android 上为 Kotlin 提供支持。</p>
<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><h3 id="安装-Java"><a href="#安装-Java" class="headerlink" title="安装 Java"></a>安装 Java</h3><p>Kotlin 是基于 JVM 的编程语言，所以首先一定要先安装好 Java 开发环境，并配置好环境变量。点击链接：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">Java SE</a> 下载对应版本，安装完成后配置环境变量。安装过程自行 Google。</p>
<p>下面贴一下 Windows 下配置环境变量的过程。</p>
<ol>
<li>打开，我的电脑 –&gt; 属性 –&gt; 高级 –&gt; 环境变量 <br><br></li>
<li>新建系统变量 JAVA_HOME 和 CLASSPATH：<br>变量名：JAVA_HOME<br>  变量值：C:\Program Files\Java\jdk1.7.0（这个是你JDK安装的位置，注意变量值到JAVA JDK文件夹，复制粘贴）<br>变量名：CLASSPATH<br>变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;（复制即可）<br><br></li>
<li>选择「系统变量」中变量名为「Path」的环境变量，双击该变量，把 JDK 安装路径中 bin 目录的绝对路径，添加到「Path」变量的值中，并使用半角的分号和已有的路径进行分隔。 <br>变量名：Path <br>变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;（在系统变量中找到「Path」变量，把前面的变量放到原有变量最前面）</li>
</ol>
<h3 id="安装-Kotlin"><a href="#安装-Kotlin" class="headerlink" title="安装 Kotlin"></a>安装 Kotlin</h3><p>我这里选择 Working with the Command Line Compiler 的方式来开始学习 Kotlin。使用这种方式便于理解 Kotlin 的运行原理，并且命令行其实也是蛮炫酷的，更没有想象的那么难，命令不会可以查。</p>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>在  <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.1.2-5" target="_blank" rel="external">GitHub</a> 中下载安装包，然后手动解压到自己想要的目录，解压完成后，配置环境变量。将 Kotlin 解压目录下的 bin 路径添加到环境变量的「系统变量」中「Path」下。</p>
<h4 id="Mac-amp-Linux"><a href="#Mac-amp-Linux" class="headerlink" title="Mac &amp; Linux"></a>Mac &amp; Linux</h4><p>如果你是 Mac 或者 Linux 系统可以使用下面方式中的任意一种。由于我用的是 Windows，不保证下列方式均可行，并且没有测试过，只是将官方的方法照搬过来而已。</p>
<h5 id="SDKMAN"><a href="#SDKMAN" class="headerlink" title="SDKMAN!"></a>SDKMAN!</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ curl -s https://get.sdkman.io | bash</div><div class="line">$ sdk install kotlin</div></pre></td></tr></table></figure>
<h5 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ brew update</div><div class="line">$ brew install kotlin</div></pre></td></tr></table></figure>
<h5 id="MacPorts"><a href="#MacPorts" class="headerlink" title="MacPorts"></a>MacPorts</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo port install kotlin</div></pre></td></tr></table></figure>
<h2 id="创建并运行第一个-Kotlin-程序"><a href="#创建并运行第一个-Kotlin-程序" class="headerlink" title="创建并运行第一个 Kotlin 程序"></a>创建并运行第一个 Kotlin 程序</h2><p>新建一个名为 hell.kt 的文件，扩展名 .kt 代表是 Kotlin 文件。在文件中输入以下内容：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    println(<span class="string">"Hello, World!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在终端(Terminal)中输入以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kotlinc hello.kt -include-runtime -d hello.jar</div></pre></td></tr></table></figure></p>
<p>注：「kotlinc」 是编译的意思，类似于 javac；「hello.kt」 是需要编译的文件名；「-include-runtime」代表包含进 kotlin 运行时库来运行 hello.kt 的代码来生成 .jar 文件；「-d」代表打包成 .jar 文件的名字。由于 Kotlin 是 JVM 语言，所以最终是转换成 jar 包的。</p>
<p>然后，继续在终端输入以下命令来运行程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ java -jar hello.jar</div></pre></td></tr></table></figure></p>
<p>输出 <code>Hello, World!</code> 代表运行成功。</p>
<hr>
<p>如果要开发由其他 Kotlin 程序使用的库，则可以生成 .jar 文件，而不包含运行时库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kotlinc hello.kt -d hello.jar</div></pre></td></tr></table></figure></p>
<p>在使用该 library 时，需要依赖 Kotlin 运行时环境，所以在编译时，应将出现在类路径中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kotlin -classpath hello.jar HelloKt</div></pre></td></tr></table></figure></p>
<p>注：HelloKt 是 Kotlin 编译器为 hello.kt 文件生成的主类名。</p>
<p>这种方式和上面的区别在于第二步给 hello.jar 指定了一个类 HelloKt，让 hello.jar 中的代码运行在 HelloKt 类里。</p>
<h2 id="交互式-Kotlin-shell"><a href="#交互式-Kotlin-shell" class="headerlink" title="交互式 Kotlin shell"></a>交互式 Kotlin shell</h2><p>Kotlin 内置有一个交互式的 Shell。交互式 shell 的意思是可以直接在 shell 里输入代码，然后回车直接立即执行。</p>
<p>在终端输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kotlinc-jvm</div></pre></td></tr></table></figure></p>
<p>会输出以下欢迎信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Welcome to Kotlin version 1.1.2-5 (JRE 1.8.0_112-b15)</div><div class="line">Type :help for help, :quit for quit</div></pre></td></tr></table></figure></p>
<p>欢迎信息中给出了退出的方式「:quit」</p>
<h2 id="Kotlin-脚本"><a href="#Kotlin-脚本" class="headerlink" title="Kotlin 脚本"></a>Kotlin 脚本</h2><p>Kotlin 也可以直接执行脚本。「脚本」就是在一个文件中写入想要执行的代码，然后输入一个命令就可以直接执行脚本里面的代码，不需要编译。Kotlin 脚本以 .kts 拓展名结尾。</p>
<p>例如：<br>新建名为 hello.kts 的脚本，在其中输入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">println(&quot;Hello Kotlin Script!&quot;)</div></pre></td></tr></table></figure></p>
<p>然后在终端输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kotlinc -script hello.kts</div></pre></td></tr></table></figure></p>
<p>脚本执行，然后输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello Kotlin Script!</div></pre></td></tr></table></figure></p>
<p>至此，Kotlin 从入门到放弃的第一篇「开始」就介绍完了，本文介绍了 Kotlin 的安装方式以及使用命令执行 Kotlin 程序的方法。建议其中内容均手动实践几遍，实践出真知。</p>
<p>本文参考及学习地址：<a href="http://kotlinlang.org/docs/tutorials/command-line.html" target="_blank" rel="external">JetBrains/kotlin: Working with the Command Line Compiler</a></p>
<p><br>ikook<br>2017.06.16</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Kotlin 从入门到放弃–开始&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://ikookblog.com/categories/Kotlin/"/>
    
    
      <category term="kotlin" scheme="http://ikookblog.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之「概述」</title>
    <link href="http://ikookblog.com/2017/04/18/design_pattern_summarize/"/>
    <id>http://ikookblog.com/2017/04/18/design_pattern_summarize/</id>
    <published>2017-04-17T16:00:00.000Z</published>
    <updated>2017-06-03T18:08:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>设计模式学习系列总结笔记之「概述」</p>
</blockquote>
<a id="more"></a>
<p>本文内容均来自「刘伟」前辈 CSDN 博客，只是将内容抽取，作为自己学习总结以及日后复习之用。</p>
<p>原文链接：<a href="http://blog.csdn.net/LoveLion/article/category/738450/13" target="_blank" rel="external">http://blog.csdn.net/LoveLion/article/category/738450/13</a></p>
<h2 id="设计模式从何而来"><a href="#设计模式从何而来" class="headerlink" title="设计模式从何而来"></a>设计模式从何而来</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>Christopher Alexander 在其出版的书中归纳出 253 个模式，对每一个模式（Pattern）都从 Context「前提条件」、Theme 或 Proble「目标问题」、 Solution「解决问题」三个方面进行了描述。</p>
<p>Christopher Alexander 在其另一著作中提出了模式的定义：</p>
<p><strong> 每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无须再重复相同的工作。 </strong></p>
<p>简单来说：</p>
<p><strong> 模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。「A pattern is a successful or efficient solution to a recurring problem within a context」 </strong></p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>最早将模式的思想引入软件工程方法学的是1991-1992年以“四人组(Gang of Four，简称GoF，分别是Erich Gamma, Richard Helm, Ralph Johnson和John Vlissides)”自称的四位著名软件工程学者，在1994年归纳发表了23种在软件开发中使用频率较高的设计模式，旨在用模式来统一沟通面向对象方法在分析、设计和实现间的鸿沟。</p>
<p>软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等</p>
<p>软件模式是在软件开发中某些可重现问题的一些有效解决方法，软件模式的基础结构主要由四部分构成，包括问题描述「待解决的问题是什么」、前提条件「在何种环境或约束条件下使用」解法「如何解决」和效果「有哪些优缺点」</p>
<p>在软件模式中，设计模式是研究最为深入的分支，设计模式用于在特定的条件下为一些重复出现的软件设计问题提供合理的、有效的解决方案。</p>
<h2 id="设计模式是什么"><a href="#设计模式是什么" class="headerlink" title="设计模式是什么"></a>设计模式是什么</h2><p>设计模式的一般定义如下：</p>
<p><strong> 设计模式「Design Pattern」是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码的可靠性。 </strong></p>
<p>设计模式一般包括模式名称、问题、目的、解决方法、效果等组成要素，其中关键要素是模式名称、问题、解决方法和效果。</p>
<ul>
<li><p><strong> 模式名称「Pattren Name」</strong> 通过一两个词来描述模式的问题、解决方案和效果；</p>
</li>
<li><p><strong> 问题「Problem」</strong> 描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因；</p>
</li>
<li><p><strong> 解决方案「Solution」</strong> 描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过 UML 类图和核心代码来进行描述；</p>
</li>
<li><p><strong> 效果「Consequences」</strong> 描述了模式的优缺点以及在使用模式时应权衡的问题。</p>
</li>
</ul>
<p>设计模式可分为创建型「Creational」，结构型「Structural」和行为型「Behavioral」三种：</p>
<p><strong> 创建型模式主要用于描述如何创建对象；结构型模式主要用于描述如何实现类或对象的组合；行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。 </strong></p>
<p>在 GoF 23 种设计模式中包含 5 中创建型设计模式、7 种结构型设计模式、11 种行为型设计模式。</p>
<p>此外，根据某个模式主要是用于处理类之间的关系还是对象之间的关系，设计模式还可以分为类模式和对象模式。我们经常将两种分类方式结合使用，如单例模式是对象创建型模式，模板方法模式是类行为型模式。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">模式名称</th>
<th style="text-align:center">学习难度</th>
<th>使用频率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建型模式 Creational Pattern</td>
<td style="text-align:center">单例模式 Singleton Pattern</td>
<td style="text-align:center">★☆☆☆☆</td>
<td>★★★★☆</td>
</tr>
<tr>
<td style="text-align:center">创建型模式 Creational Pattern</td>
<td style="text-align:center">简单工厂模式 Simple Factory Pattern</td>
<td style="text-align:center">★★☆☆☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td style="text-align:center">创建型模式 Creational Pattern</td>
<td style="text-align:center">工厂方法模式 Factory Method Pattern</td>
<td style="text-align:center">★★☆☆☆</td>
<td>★★★★★</td>
</tr>
<tr>
<td style="text-align:center">创建型模式 Creational Pattern</td>
<td style="text-align:center">抽象工厂模式 Abstract Factory Pattern</td>
<td style="text-align:center">★★★★☆</td>
<td>★★★★★</td>
</tr>
<tr>
<td style="text-align:center">创建型模式 Creational Pattern</td>
<td style="text-align:center">原型模式 Prototype Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td style="text-align:center">创建型模式 Creational Pattern</td>
<td style="text-align:center">建造者模式 Builder Pattern</td>
<td style="text-align:center">★★★★☆</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">适配器模式 Adapter Pattern</td>
<td style="text-align:center">★★☆☆☆</td>
<td>★★★★☆</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">桥接模式 Bridge Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">组合模式 Composite Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★★☆</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">装饰模式 Decorator Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">外观模式 Façade Pattern</td>
<td style="text-align:center">★☆☆☆☆</td>
<td>★★★★★</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">享元模式 Flyweight Pattern</td>
<td style="text-align:center">★★★★☆</td>
<td>★☆☆☆☆</td>
</tr>
<tr>
<td style="text-align:center">结构型模式 Structural Pattern</td>
<td style="text-align:center">代理模式 Proxy Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★★☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">职责链模式 Chain of Responsibility Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">命令模式 Command Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★★☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">解释器模式 Interpreter Pattern</td>
<td style="text-align:center">★★★★★</td>
<td>★☆☆☆☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">迭代器模式 Iterator Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★★★</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">中介者模式 Mediator Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">备忘录模式 Memento Pattern</td>
<td style="text-align:center">★★☆☆☆</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">观察者模式 Observer Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★★★</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">状态模式 State Pattern</td>
<td style="text-align:center">★★★☆☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">策略模式 Strategy Pattern</td>
<td style="text-align:center">★☆☆☆☆</td>
<td>★★★★☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">模板方法模式 Template Method Pattern</td>
<td style="text-align:center">★★☆☆☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td style="text-align:center">行为型模式 Behavioral Pattern</td>
<td style="text-align:center">访问者模式 Visitor Pattern</td>
<td style="text-align:center">★★★★☆</td>
<td>★☆☆☆☆</td>
</tr>
</tbody>
</table>
<h2 id="设计模式有什么用"><a href="#设计模式有什么用" class="headerlink" title="设计模式有什么用"></a>设计模式有什么用</h2><p>设计模式来自众多专家的经验和智慧，它们是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作。</p>
<p>设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。当面对同一个设计模式时，你和别人的理解并无而已（编程语不同，跨国界的团队等），因为设计模式是跨语言、跨平台、跨应用、跨国界的。</p>
<p>大部分设计模式都兼顾了系统的可重用性和可拓展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码。许多设计模式将有助于提高系统的灵活性和可拓展性。</p>
<p>合理的使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统。可以让别人能都很快的理解我们的设计思路和实现方案。</p>
<p>学习设计模式将有助于初学者更加深入地理解面向对象思想。「让你知道：如何将代码分散在几个不同的类中？为什么要有“接口”？何谓针对抽象编程？何时不应该使用继承？如何不修改源代码增加新功能？同时还让你能够更好地阅读和理解现有类库（如JDK）与其他系统中的源代码」</p>
<h2 id="刘伟前辈的个人观点"><a href="#刘伟前辈的个人观点" class="headerlink" title="刘伟前辈的个人观点"></a>刘伟前辈的个人观点</h2><p>掌握设计模式并不是一件很难的事情，关键在于多思考、多实践</p>
<p>在学习每一个设计模式时至少应该掌握如下几点：这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；它是如何解决的，掌握它的结构图，记住它的关键代码；能够想到至少两个它的应用实例，一个生活中的，一个软件中的；这个模式的优缺点是什么，在使用时要注意什么。</p>
<p>懂得运用设计模式，「少说多做」</p>
<p>千万不要滥用模式。每个模式都有自己的适用场景，不能为了使用模式而使用模式，滥用模式不如不用模式。</p>
<p>「每一个模式都是一种计策」，它为解决某一类问题而诞生，不管这个设计模式的难度如何，使用频率高不高，都应该好好学学。</p>
<p>设计模式的“上乘”境界：“手中无模式，心中有模式”。模式使用的最高境界是你已经不知道具体某个设计模式的定义和结构了，但你会灵活自如地选择一种设计方案「其实就是某个设计模式」来解决某个问题。所以，对模式的学习不要急于求成。</p>
<p>最后一点来自 GoF 已故成员 John Vlissides 的著作《设计模式沉思录》：模式从不保证任何东西，它不能保证你一定能够做出可复用的软件，提高你的生产率，更不能保证世界和平。模式并不能替代人来完成软件系统的创造，它们只不过会给那些缺乏经验但却具备才能和创造力的人带来希望。</p>
<p><br>ikook<br>2017.04.18</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;设计模式学习系列总结笔记之「概述」&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术栈" scheme="http://ikookblog.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="java" scheme="http://ikookblog.com/tags/java/"/>
    
      <category term="设计模式" scheme="http://ikookblog.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>学习是个啥？</title>
    <link href="http://ikookblog.com/2017/03/23/what_is_learn/"/>
    <id>http://ikookblog.com/2017/03/23/what_is_learn/</id>
    <published>2017-03-22T16:00:00.000Z</published>
    <updated>2017-06-03T17:54:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>聊聊「学习」和我为什么「爱上了」学习。</p>
</blockquote>
<a id="more"></a>
<h2 id="我为什么「爱上了」学习"><a href="#我为什么「爱上了」学习" class="headerlink" title="我为什么「爱上了」学习"></a>我为什么「爱上了」学习</h2><p>首先，先来聊聊我为什么「爱上」学习了。</p>
<p>我在上大学之前是非常讨厌学习的，对学任何东西都不来感。记得在高中和同学们口口声声说自己非常喜欢数学和物理。是，是挺喜欢的，可这种喜欢是建立在不得不学之上，是在数 10 门课程中，相对而言的，如果没人逼我学，我会「喜欢」？ 未必。</p>
<p>在大一上学期，也许是因为高中留下的后遗症，还和高中一样本本分分上课，课下老老实实做留下的丁点作业。唯一不同的就是把课余时间都用在了到处浪上。</p>
<p>大一上学期末，我突然头脑发热想要学点东西，然后就找了个编程语言学。现在想想当初想学东西的主要原因是：闲的。开始抱着玩玩的心态，却玩上了瘾。当我用代码在电脑屏幕上输出一些东西的时候，那种自豪感和成就感无比强烈，我喜欢这种感觉。</p>
<p>也许就是这样我找到了自己的兴趣所在，慢慢我接触到 IT 领域的东西越来越多，我能用电脑做的东西越来越多，我学的东西就多了起来。这就是兴趣，当你对某个事物产生兴趣之后，你就会不由自主的去了解它，学习它。</p>
<p>今天重点不是我为什么「爱上了」学习，重点是「学习」本身，所以就不再「扯淡」</p>
<h2 id="学习这件破事"><a href="#学习这件破事" class="headerlink" title="学习这件破事"></a>学习这件破事</h2><p>高考前，也许老师们都会说 , 要上了大学，你们就轻松了，就不用这么辛苦的学习了。然而，事实是 ，人生的任何阶段都需要学习，别想偷懒。</p>
<p>一旦你在某一时刻停止了学习，那你的人生就会就此止步，不会再有什么好的发展。想想看哪个你能够想起来的牛B的人是不学习的。</p>
<p>学习有什么方法？学习没有捷径可取，那些你以为已经过时的方法，看书、记笔记、背诵、总结… 其实可以拿来用一辈子，最原始的方法才是最管用的。</p>
<p>其实所有通往成功的方法都不会很新奇，因为没有捷径，关键是看你是否能坚持下去。</p>
<p>当你特别热爱一件事的时候，你从来不会觉得勉强，也从不会觉得苦逼。就像我特别热爱软件编程，即使敲代码到深夜也毫无困意，而自得其乐。</p>
<p>总会听到有人会说「光是在起跑线上就比别人差远了，还谈什么努力，学个毛！」其实我想说，没有谁和你在同一起跑线上的，姑且不谈家庭背景，光谈天赋、身体这些方面，大家就都不一样。要想成功，努力和机遇都不可少，机遇这种东西只能靠运气，而努力，是由你自己去控制的。当然如果机遇来了，你却没有能力去迎接机遇，那岂不可惜。唯一让你有能力去迎接机遇的道路只有一条，就是学习。所以从现在开始，学习！！！</p>
<p>努力？我该往哪方面努力？我连自己想干什么都不知道。所以，你要学习，最艰难的其实就是起步，就是一个选择。你应该想清楚自己想要干什么。哪怕一件很卑微的事，你也应该花一定的时间去学习了解它现有知识，然后通过不断学习，不断创新和发展。</p>
<p>在上面说的我为什么「爱上了」学习中你们也看到了，我为什么爱上了学习。因为我找到了自己兴趣，因为我特别的热爱。能在自己热爱的领域中成长并不断学习还有什么比这更爽的事情了吗？</p>
<p>柴静就说了「什么是幸福？进步就是幸福」，那怎么才能进步，学习才能进步。</p>
<p>就像海尔集团董事长张瑞敏退休以后，还继续保持每周看两本书的速度，一年读100本书的速度。这种不断学习的精神值得任何一个人去学习。</p>
<p>希望我们都能保持阅读和学习，直到老去。</p>
<p><br>ikook<br>2017.03.23</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;聊聊「学习」和我为什么「爱上了」学习。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔集" scheme="http://ikookblog.com/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
      <category term="生活" scheme="http://ikookblog.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="感悟" scheme="http://ikookblog.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Android 官方 Training 文档学习总结系列之「支持不同的设备」</title>
    <link href="http://ikookblog.com/2017/03/16/android_training_study2/"/>
    <id>http://ikookblog.com/2017/03/16/android_training_study2/</id>
    <published>2017-03-15T16:00:00.000Z</published>
    <updated>2017-06-16T07:03:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Android 官方 Training 文档学习总结系列</p>
</blockquote>
<a id="more"></a>
<p>官方 Training 总结系列第二篇：支持不同的设备。</p>
<h2 id="支持不同的语言"><a href="#支持不同的语言" class="headerlink" title="支持不同的语言"></a>支持不同的语言</h2><p>在任何情况下，从应用代码中提取 UI 字符串并将其存放在外部文件中都是个好办法。Android 可以通过工程中的资源目录轻松实现这一功能。</p>
<h3 id="创建语言区域目录和字符串文件"><a href="#创建语言区域目录和字符串文件" class="headerlink" title="创建语言区域目录和字符串文件"></a>创建语言区域目录和字符串文件</h3><p>如需添加对更多语言的支持，在res/中创建一个额外的values目录，并以连字符和ISO国家代码结尾命名。例如，values-es/ 目录包含的简单资源用于语言代码为“es”的语言区域。Android 根据运行时设备的语言区域设置加载相应的资源。</p>
<p>一旦确定了为哪些语言提供支持，便可创建资源子目录和字符串资源文件。例如：</p>
<p>MyProject/<br>    res/<br>    values/<br>      strings.xml<br>    values-es/<br>      strings.xml<br>    values-fr/<br>      strings.xml</p>
<p>将各个语言区域的字符串值添加到相应文件中。</p>
<p>在运行时，Android 系统会根据当前为用户设备设置的语言区域使用相应的字符串资源集。</p>
<p>例如：英文，/values/strings.xml：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span>My Application<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"hello_world"</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>西班牙文，/values-es/strings.xml：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span>Mi Aplicación<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"hello_world"</span>&gt;</span>Hola Mundo!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>注：可以在任何资源类型上使用语言区域限定符（或任何配置限定符），例如，可以提供本地化版本的可绘制位图。</p>
</blockquote>
<h3 id="使用字符串资源"><a href="#使用字符串资源" class="headerlink" title="使用字符串资源"></a>使用字符串资源</h3><p>可以在源代码和其他 XML 文件中通过 &lt; string >元素的 name 属性来引用自己的字符串资源。</p>
<p>在源代码中，可以使用语法 R.string.&lt; string_name > 引用字符串资源。有许多方法都接受以这种方式引用的字符串资源。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Get a string resource from your app's Resources</span></div><div class="line">String hello = getResources().getString(R.string.hello_world);</div><div class="line"></div><div class="line"><span class="comment">// Or supply a string resource to a method that requires a string</span></div><div class="line">TextView textView = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</div><div class="line">textView.setText(R.string.hello_world);</div></pre></td></tr></table></figure>
<p>在其他 XML 文件中，只要 XML 属性接受字符串值，可以使用语法 @string/<string_name> 引用字符串资源。</string_name></p>
<p>例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:text</span>=<span class="string">"@string/hello_world"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h2 id="适配不同的屏幕"><a href="#适配不同的屏幕" class="headerlink" title="适配不同的屏幕"></a>适配不同的屏幕</h2><p>Android 使用两种常规属性对不同的设备屏幕进行分类：尺寸和密度。我们应该在 APP 中包含一些替代资源，来适应不同的屏幕尺寸和密度，以优化 APP 的外观。</p>
<ul>
<li>4 种普遍尺寸：小(small)，普通(normal)，大(large)，超大(xlarge)</li>
<li>4 种普遍密度：低精度(ldpi), 中精度(mdpi), 高精度(hdpi), 超高精度(xhdpi)</li>
</ul>
<p>要为不同的屏幕声明不同的 layout 和 bitmap，必须将这些替代资源放在不同的目录中，类似于对不同语言字符串的做法</p>
<p>另请注意，屏幕方向（横向或纵向）被认为是屏幕尺寸的变化，因此许多应用程序应修改 layout，以优化每个方向的用户体验。</p>
<h3 id="创建不同的-layout"><a href="#创建不同的-layout" class="headerlink" title="创建不同的 layout"></a>创建不同的 layout</h3><p>要在不同的屏幕尺寸上优化用户体验，应该为要支持的每个屏幕尺寸创建一个唯一的布局 XML 文件。每个 layout 都应该保存到相应的资源目录中，并以 -&lt; screen_size &gt; 为后缀命名。例如，大尺寸屏幕(large screens)的唯一的 layout 文件应该保存在 res/layout-large/ 中。</p>
<blockquote>
<p>注意: 为了匹配合适的屏幕尺寸Android会自动地测量我们的layout文件。所以不需要因不同的屏幕尺寸去担心UI元素的大小，而应该专注于layout结构对用户体验的影响。(比如关键视图相对于同级视图的尺寸或位置)</p>
</blockquote>
<p>例如，此项目包括默认 layout 和大尺寸屏幕的替代布局：</p>
<p>MyProject/<br>    res/<br>    layout/<br>      main.xml<br>    layout-large/<br>      main.xml</p>
<p>layout 文件的名字必须完全一样，为了对相应的屏幕尺寸提供最优的 UI，文件的内容不同。</p>
<p>如平常一样在 app 中简单引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.main);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>系统会根据 app 所运行的设备屏幕尺寸，在与之对应的 layout 目录中加载 layout。</p>
<blockquote>
<p>注意：Android 3.2及以上版本支持定义屏幕尺寸的高级方法，它允许我们根据屏幕最小长度和宽度，为各种屏幕尺寸指定与密度无关的layout资源。</p>
</blockquote>
<h3 id="创建不同的位图"><a href="#创建不同的位图" class="headerlink" title="创建不同的位图"></a>创建不同的位图</h3><p>应该为 4 种普遍密度(分辨率):低，中，高，超高精度，都提供相适配的 bitmap 资源。这能使 app 在所有屏幕分辨率中都能有良好的画质和效果。</p>
<p>要生成这些图像，应该从原始的矢量图像资源着手，然后根据下列尺寸比例，生成各种密度下的图像。</p>
<ul>
<li>xhdpi: 2.0</li>
<li>hdpi: 1.5</li>
<li>mdpi: 1.0 (基准)</li>
<li>ldpi: 0.75</li>
</ul>
<p>这意味着，如果针对 xhdpi 的设备生成了一张 200x200 的图像，那么应该为 hdpi 生成 150x150,为 mdpi 生成 100x100, 和为 ldpi 生成 75x75 的图片资源。</p>
<p>然后，将文件放在相应的 drawable 资源目录中：</p>
<p>MyProject/<br>    res/<br>     drawable-xhdpi/<br>      awesomeimage.png<br>    drawable-hdpi/<br>      awesomeimage.png<br>    drawable-mdpi/<br>      awesomeimage.png<br>    drawable-ldpi/<br>      awesomeimage.png</p>
<p>任何时候引用@ drawable / awesomeimage，系统都会根据屏幕的密度选择适当的 bitmap。</p>
<blockquote>
<p>注意：低密度(ldpi)资源是非必要的，当提供了hdpi的图像，系统会把hdpi的图像按比例缩小一半，去适配ldpi的屏幕。</p>
</blockquote>
<h2 id="支持不同的平台版本"><a href="#支持不同的平台版本" class="headerlink" title="支持不同的平台版本"></a>支持不同的平台版本</h2><p>一般情况下，在更新 app 至最新 Android 版本时，最好先保证新版的 app 可以支持 90% 的设备使用。</p>
<blockquote>
<p>注：为了能在几个 Android 版本中都能提供最好的特性和功能，应该在我们的 app 中使用 Android Support Library，它能使我们的app能在旧平台上使用最近的几个平台的APIs。</p>
</blockquote>
<h3 id="指定最小和目标API级别"><a href="#指定最小和目标API级别" class="headerlink" title="指定最小和目标API级别"></a>指定最小和目标API级别</h3><p>AndroidManifest.xml 文件中描述了 app 的细节及 app 支持哪些 Android 版本。具体来说，&lt; uses-sdk &gt; 元素中的 minSdkVersion 和 targetSdkVersion 属性，标明在设计和测试 app 时，最低兼容 API 的级别和最高适用的 API 级别(这个最高的级别是需要通过测试的)。例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> <span class="attr">...</span> &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:minSdkVersion</span>=<span class="string">"4"</span> <span class="attr">android:targetSdkVersion</span>=<span class="string">"15"</span> /&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>随着新版本 Android 的发布，一些风格和行为可能会改变，为了能使app能利用这些变化，而且能适配不同风格的用户的设备，应该将 targetSdkVersion 的值尽量的设置与最新可用的 Android 版本匹配。</p>
<h3 id="运行时检查系统版本"><a href="#运行时检查系统版本" class="headerlink" title="运行时检查系统版本"></a>运行时检查系统版本</h3><p>Android 在 Build 常量类中提供了对每一个版本的唯一代号，在 app 中使用这些代号可以建立条件，保证依赖于高级别的 API 的代码，只会在这些 API 在当前系统中可用时，才会执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpActionBar</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Make sure we're running on Honeycomb or higher to use ActionBar APIs</span></div><div class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">        ActionBar actionBar = getActionBar();</div><div class="line">        actionBar.setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：当解析 XML 资源时，Android 会忽略当前设备不支持的 XML 属性。所以可以安全地使用较新版本的 XML 属性，而不需要担心旧版本 Android 遇到这些代码时会崩溃。例如如果设置 targetSdkVersion=”11”，app 会在 Android 3.0 或更高时默认包含 ActionBar。然后添加 menu items到 action bar 时，需要在自己的 menu XML 资源中设置 android:showAsAction=”ifRoom”。在跨版本的 XML 文件中这么做是安全的，因为旧版本的 Android 会简单地忽略 showAsAction 属性(就是这样，你并不需要用到 res/menu-v11/ 中单独版本的文件)。</p>
</blockquote>
<h3 id="使用平台样式和主题"><a href="#使用平台样式和主题" class="headerlink" title="使用平台样式和主题"></a>使用平台样式和主题</h3><p>Android 提供了用户体验主题，为 app 提供基础操作系统的外观和体验。这些主题可以在 manifest 文件中被应用于 app 中。通过使用内置的风格和主题，app 自然地随着 Android 新版本的发布，自动适配最新的外观和体验。</p>
<p>使 activity 看起来像对话框：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.Dialog"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>使 activity 有一个透明背景：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.Translucent"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>应用在 /res/values/styles.xml 中定义的自定义主题：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:theme</span>=<span class="string">"@style/CustomTheme"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>使整个app应用一个主题(全部 activities )在元素中添加 android:theme 属性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">"@style/CustomTheme"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><br>ikook<br>2017.03.16</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android 官方 Training 文档学习总结系列&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ikookblog.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://ikookblog.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 官方 Training 文档学习总结系列之「My First App涉及知识总结」</title>
    <link href="http://ikookblog.com/2017/03/13/android_training_study1/"/>
    <id>http://ikookblog.com/2017/03/13/android_training_study1/</id>
    <published>2017-03-12T16:00:00.000Z</published>
    <updated>2017-06-16T07:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Android 官方 Training 文档学习总结系列</p>
</blockquote>
<a id="more"></a>
<p>由于自己学习 Android 到现在，都是通过视频和书籍。感觉到现在还是什么都不会的状态，比如实现一个小功能，也许有思路，但是去实现却实现不出来。回头想想自己都学会了 Android 的哪些知识点，一头雾水，回忆不起什么来，不知道学习了什么。</p>
<p>于是决定系统学习官方 Training 文档，学习不总结是不会提高的。也许之前学的一塌糊涂，甚至导致学过之后都不知道学了什么，可能就是不总结不思考造成的。然后，就有了这个系列的总结。</p>
<p>总结系列第一篇：My First App涉及知识点总结。代码仓库: <a href="https://github.com/china-kook/Android-Official_Training_Study/tree/master/MyFirstApp" target="_blank" rel="external">Training First App</a></p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>Android 应用的图形界面使用 View 对象以及 ViewGroup对象层次结构而构建。View 对象通常为按钮或文本字段之类的 UI 小部件。而 ViewGroup 对象则为不可见的视图容器，它们定义子视图的布局。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2012773-b1a9438498f9b2de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewGroup 对象如何在布局中形成分支并容纳其他 View 对象的图解"></p>
<h2 id="替代布局"><a href="#替代布局" class="headerlink" title="替代布局"></a>替代布局</h2><p>以 XML 格式（而不是运行时代码的方式）声明 UI 布局有若干用处，但其中最重要的用处便是，可以创建不同的布局来适应不同的屏幕尺寸。 例如，可以创建两个版本的布局，并指示系统在“小”屏幕上使用哪个版本，在“大”屏幕上使用哪个版本。</p>
<h2 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h2><p>LinearLayout 是一个视图组(ViewGroup的子类)，它会按照 android:orientation 属性的指定，将子视图设置为垂直或水平方向布局。LinearLayout 的每个子视图都会按照它们各自在 XML 中的出现顺序显示在屏幕上。</p>
<p>如果 LinearLayout 是布局中的根视图，则应将宽度和高度设置为 “match_parent”，从而填满可供应用使用的整个屏幕区域。 该值表示视图应扩大其宽度或高度，以匹配父视图的宽度或高度。</p>
<h2 id="布局相关属性"><a href="#布局相关属性" class="headerlink" title="布局相关属性"></a>布局相关属性</h2><ul>
<li><h4 id="android-id"><a href="#android-id" class="headerlink" title="android:id"></a>android:id</h4><p>这会为视图赋予唯一的标识符，可以使用该标识符从应用代码中引用对象，例如读取和操作对象。<br>从 XML 引用任何资源对象时，都需要使用 @ 符号。 请在该符号后依次输入资源类型、斜杠和资源名称：android:id=”@+id/edit_message(例子)。</p>
<p>只有在第一次定义资源 ID 时，才需要在资源类型之前加一个加号 (+)。 当编译应用时，SDK 工具会使用 ID 名称在项目的 R.java 文件中新建一个引用 EditText(例子) 元素的资源 ID。一旦以此方式声明资源 ID，其他对该 ID 的引用皆无需使用加号。 只有在指定新资源 ID 时才必须使用加号，对于字符串或布局等具体资源则不必如此。</p>
</li>
<li><h4 id="android-layout-width-和-android-layout-height"><a href="#android-layout-width-和-android-layout-height" class="headerlink" title="android:layout_width 和 android:layout_height"></a>android:layout_width 和 android:layout_height</h4><p>“wrap_content” 值并不规定宽度和高度的具体大小，而是指定根据需要缩放视图，使其适合视图的内容。 如果要改用 “match_parent”，则 EditText 元素将填满屏幕，因为它会匹配父 LinearLayout(例子) 的大小。</p>
</li>
<li><h4 id="android-hint"><a href="#android-hint" class="headerlink" title="android:hint"></a>android:hint</h4><p>这是文本字段为空时显示的默认字符串。@string/edit_message(例子) 并非使用硬编码字符串作为其值，而是引用另一个文件中定义的一个字符串资源。 由于它引用的是一个具体资源（而不仅仅是标识符），因此不需要加号。</p>
</li>
<li><h4 id="android-layout-weight"><a href="#android-layout-weight" class="headerlink" title="android:layout_weight"></a>android:layout_weight</h4><p>weight 值是一个数字，用于指定每个视图与其他同级视图在剩余空间中的占比。 这有点像饮料配方中各种成分的比例： “2 份苏打、1 份糖浆”是指饮料中三分之二是苏打。例如，如果将一个视图的 weight 值指定为 2，将另一个视图的 weight 值指定为 1，总和是 3，那么第一个视图将填满剩余空间的 2/3，而第二个视图则填满其余部分。 如果添加了第三个视图，将其 weight 值指定为 1，那么现在第一个视图（weight 值为 2）将获得 1/2 的剩余空间，其余两个视图则各占 1/4。</p>
<p>所有视图的默认 weight 值都为 0，所以如果仅将一个视图的 weight 值指定为大于 0，那么等到其他所有视图都获得所需空间后，该视图便会填满所有剩余空间。</p>
<p>优化: 如需使其一个部件的宽度或者高度占满剩余屏幕空间时，例如在宽度方向占满屏幕剩余空间。设置 android:layout_weight=”1” 属性后，将宽度设置为零 (0dp) 可提高布局性能，这是因为如果将宽度设置为”wrap_content”或其他值，则会要求系统计算宽度，而该计算最终毫无意义，因为 weight 值还需要计算另一个宽度，才能填满剩余空间。</p>
</li>
</ul>
<blockquote>
<p>注：对资源的引用始终都按资源类型（如 id 或 string）确定其作用域，因此使用相同的名称不会引起冲突</p>
</blockquote>
<h2 id="资源对象"><a href="#资源对象" class="headerlink" title="资源对象"></a>资源对象</h2><p>资源对象是一个唯一的整型名称，它与应用资源（如位图、布局文件或字符串）相关联。</p>
<p>每个资源在项目的 R.java 文件中都定义有相应的资源对象。可以使用 R 类中的对象名称来引用资源，例如当需要为 android:hint 属性指定字符串值时，就可以这样做。也可以使用 android:id 属性创建任意与视图相关联的资源 ID，从而可以从其他代码中引用该视图。</p>
<p>SDK 工具会在您每次编译应用时生成 R.java 文件。切勿手动修改该文件。</p>
<h2 id="字符串资源"><a href="#字符串资源" class="headerlink" title="字符串资源"></a>字符串资源</h2><p>对于用户界面中的文本，务必将每个字符串都指定为资源。 字符串资源允许在单一位置管理所有 UI 文本，从而简化文本的查找和更新。 此外，将字符串外部化还可为每个字符串资源提供替代定义，从而将应用本地化为不同的语言。</p>
<h2 id="响应按钮"><a href="#响应按钮" class="headerlink" title="响应按钮"></a>响应按钮</h2><p>可在布局文件的 Button 元素中添加 android:onClick 属性，如 android:onClick=”sendMessage”。每次用户点击按钮时，此属性均会提示系统调用 Activity 中的 sendMessage() 方法。</p>
<p>还需在布局文件对应的 Activity 类中添加与 onClick 属性对应的方法。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**Called when the user clicks the Send button */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    <span class="comment">// Do something in response to button</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要让系统将此方法与为 android:onClick 指定的方法名称匹配，签名必须与所示内容完全相同。具体而言，该方法必须：</p>
<ul>
<li>是公共方法</li>
<li>具有空返回值</li>
<li>以 View 作为唯一参数（这将是之前点击的 View）</li>
</ul>
<h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>Intent 是指在相互独立的组件（如两个 Activity）之间提供运行时绑定功能的对象。Intent 表示一个应用“执行某项操作的 Intent”。 可以将 Intent 用于各种任务。例如：Intent 用于启动另一个 Activity。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Called when the user clicks the Send button */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, DisplayMessageActivity.class);</div><div class="line">    EditText editText = (EditText) findViewById(R.id.edit_message);</div><div class="line">    String message = editText.getText().toString();</div><div class="line">    intent.putExtra(EXTRA_MESSAGE, message);</div><div class="line">    startActivity(intent);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Intent 构造函数采用两个参数：</p>
<ul>
<li>Context 是第一个参数（之所以使用 this ，是因为 Activity 类是 Context 的子类）</li>
<li>应用组件的 Class，系统应将 Intent（在本例中，为应启动的 Activity）传递至该类。</li>
</ul>
<p>putExtra() 方法将 EditText 的值添加到 Intent。Intent 能够以名为 extra 的键值对形式携带数据类型。键是一个公共常量 EXTRA_MESSAGE，因为下一个 Activity 将使用该键来检索文本值。为 Intent extra 定义键时最好使用应用的软件包名称作为前缀。这可以确保在应用与其他应用交互过程中这些键始终保持唯一。</p>
<p>startActivity() 方法将启动 Intent 指定的 DisplayMessageActivity 实例。</p>
<p>编写 DisplayMessageActivity.java 类，用于显示第一个 Activity 传递的消息。代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">   <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">   setContentView(R.layout.activity_display_message);</div><div class="line"></div><div class="line">   Intent intent = getIntent();</div><div class="line">   String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE);</div><div class="line">   TextView textView = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</div><div class="line">   textView.setTextSize(<span class="number">40</span>);</div><div class="line">   textView.setText(message);</div><div class="line"></div><div class="line">   ViewGroup layout = (ViewGroup) findViewById(R.id.activity_display_message);</div><div class="line">   layout.addView(textView);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此处会执行大量操作，因此我们接着解释：</p>
<ul>
<li>调用 getIntent() 采集启动 Activity 的 intent。无论用户如何导航到目的地，每个 Activity 都由一个 Intent 调用。 调用 getStringExtra() 将检索第一个 Activity 中的数据。</li>
<li>可以使用编程方式创建 TextView 并设置其大小和消息。</li>
<li>可将 TextView 添加到 R.id.activity_display_message 标识的布局。可将布局投射到 ViewGroup，因为它是所有布局的超类且包含 addView() 方法。</li>
</ul>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局定义用户界面的视觉结构，如Activity或应用小部件的 UI。可以通过两种方式声明布局：</p>
<ul>
<li>在 XML 中声明 UI 元素。Android 提供了对应于 View 类及其子类的简明 XML 词汇，如用于小部件和布局的词汇；</li>
<li>运行时实例化布局元素。应用可以通过编程创建 View 对象和 ViewGroup 对象（并操纵其属性）。</li>
</ul>
<p>Android 框架可以灵活地使用以下一种或两种方法来声明和管理应用的 UI。例如，可以在 XML 中声明应用的默认布局，包括将出现在布局中的屏幕元素及其属性。然后，可以在应用中添加可在运行时修改屏幕对象（包括那些已在 XML 中声明的对象）状态的代码。</p>
<p>在 XML 中声明 UI 的优点在于，可以更好地将应用的外观与控制应用行为的代码隔离。UI 描述位于应用代码外部，这意味着在修改或调整描述时无需修改源代码并重新编译。例如，可以创建适用于不同屏幕方向、不同设备屏幕尺寸和不同语言的 XML 布局。此外，在 XML 中声明布局还能更轻松地显示 UI 的结构，从而简化问题调试过程。</p>
<p>一般而言，用于声明 UI 元素的 XML 词汇严格遵循类和方法的结构和命名方式，其中元素名称对应于类名称，属性名称对应于方法。实际上，这种对应关系往往非常直接，可以猜到对应于类方法的 XML 属性，或对应于给定 XML 元素的类。但请注意，并非所有词汇都完全相同。在某些情况下，在命名上略有差异。例如，EditText 元素具有的 text 属性对应的类方法是 EditText.setText()。</p>
<h3 id="编写-XML"><a href="#编写-XML" class="headerlink" title="编写 XML"></a>编写 XML</h3><p>可以利用 Android 的 XML 词汇，按照在 HTML 中创建包含一系列嵌套元素的网页的相同方式快速设计 UI 布局及其包含的屏幕元素。</p>
<p>每个布局文件都必须只包含一个根元素，并且该元素必须是视图对象或 ViewGroup 对象。定义根元素之后，即可再以子元素的形式添加其他布局对象或小部件，从而逐步构建定义布局的视图层次结构。例如，以下这个 XML 布局使用垂直 LinearLayout 来储存一个 TextView 和一个 Button：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">              <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@+id/text"</span></span></div><div class="line">              <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">              <span class="attr">android:text</span>=<span class="string">"Hello, I am a TextView"</span> /&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/button"</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:text</span>=<span class="string">"Hello, I am a Button"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在 XML 中声明布局后，请在 Android 项目 res/layout/ 目录中以 .xml 扩展名保存文件，以便其能够正确编译。</p>
<h3 id="加载-XML-资源"><a href="#加载-XML-资源" class="headerlink" title="加载 XML 资源"></a>加载 XML 资源</h3><p>当编译应用时，每个 XML 布局文件都会编译到一个 View 资源中。 应该在 Activity.onCreate() 回调实现中从应用代码加载布局资源。通过调用 setContentView()，以 R.layout.layout_file_name 形式向其传递对布局资源的引用来执行此操作。例如，如果 XML 布局保存为 main_layout.xml，则需要像下面这样为 Activity 加载该布局：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.main_layout);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动 Activity 时，Android 框架会调用 Activity 中的 onCreate() 回调方法</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>每个视图对象和 ViewGroup 对象都支持各自的各类 XML 属性。某些属性是视图对象的专用属性（例如，TextView 支持 textSize 属性），但这些属性也会被任何可以扩展此类的视图对象继承。某些属性通用于所有 View 对象，因为它们继承自根 View 类（如 id 属性）。此外，其他属性被视为“布局参数”，即描述 View 对象特定布局方向的属性，如该对象的父 ViewGroup 对象所定义的属性。</p>
<ul>
<li><h4 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h4><p>任何视图对象都可能具有关联的整型 ID，此 ID 用于在结构树中对 View 对象进行唯一标识。编译应用后，此 ID 将作为整型数引用，但在布局 XML 文件中，通常会在 id 属性中为该 ID 赋予字符串值。这是所有 View 对象共用的 XML 属性（由 View 类定义），经常会用到它。XML 标记内部的 ID 语法是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:id="@+id/my_button"</div></pre></td></tr></table></figure>
<p>字符串开头处的 @ 符号指示 XML 解析程序应该解析并展开 ID 字符串的其余部分，并将其标识为 ID 资源。加号 (+) 表示这是一个新的资源名称，必须创建该名称并将其添加到我们的资源（在 R.java 文件中）内。Android 框架还提供了许多其他 ID 资源。 引用 Android 资源 ID 时，不需要加号，但必须添加 android 软件包命名空间，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:id="@android:id/empty"</div></pre></td></tr></table></figure>
<p>添加 android 软件包命名空间之后，现在，将从 android.R 资源类而非本地资源类引用 ID。</p>
<p>要想创建视图并从应用中引用它们，常见的模式是：</p>
<ul>
<li><p>在布局文件中定义一个视图/小部件，并为其分配一个唯一的 ID：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/my_button"</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"@string/my_button_text"</span>/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>然后创建一个 view 对象实例，并从布局中捕获它（通常使用 onCreate() 方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Button myButton = (Button)findViewById(R.id.my_button);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>创建 RelativeLayout 时，为 view 对象定义 ID 非常重要。在相对布局中，同级视图可以定义其相对于其他同级视图的布局，同级视图通过唯一的 ID 进行引用。</p>
<p>ID 不需要在整个结构树中具有唯一性，但在要搜索的结构树部分应具有唯一性（要搜索的部分往往是整个结构树，因此最好尽可能具有全局唯一性）。</p>
</li>
<li><h4 id="布局参数"><a href="#布局参数" class="headerlink" title="布局参数"></a>布局参数</h4><p>名为 layout_something 的 XML 布局属性可为视图定义与其所在的 ViewGroup 相适的布局参数。</p>
<p>每个 ViewGroup 类都会实现一个扩展 ViewGroup.LayoutParams 的嵌套类。此子类包含的属性类型会根据需要为视图组的每个子视图定义尺寸和位置。 正如在下图中所见，父视图组为每个子视图（包括子视图组）定义布局参数。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2012773-665b837668ca7fb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以可视化方式表示的视图层次结构，其中包含与每个视图关联的布局参数"></p>
<p>请注意，每个 LayoutParams 子类都有自己的值设置语法。 每个子元素都必须定义适合其父元素的 LayoutParams，但父元素也可为其子元素定义不同的 LayoutParams。</p>
<p>所有视图组都包括宽度和高度（layout_width 和 layout_height），并且每个视图都必须定义它们。许多 LayoutParams 还包括可选的外边距和边框。</p>
<p>可以指定具有确切尺寸的宽度和高度，但多半不想经常这样做。 在更多的情况下，会使用以下常量之一来设置宽度或高度：</p>
<ul>
<li>wrap_content 指示您的视图将其大小调整为内容所需的尺寸。</li>
<li>match_parent 指示您的视图尽可能采用其父视图组所允许的最大尺寸。<br></li>
</ul>
<p>一般而言，建议不要使用绝对单位（如像素）来指定布局宽度和高度， 而是使用相对测量单位，如密度无关像素单位 (dp)、wrap_content 或 match_parent，这种方法更好，因为它有助于确保应用在各类尺寸的设备屏幕上正确显示。</p>
</li>
</ul>
<h3 id="布局位置"><a href="#布局位置" class="headerlink" title="布局位置"></a>布局位置</h3><p>视图的几何形状就是矩形的几何形状。视图具有一个位置（以一对水平向左和垂直向上坐标表示）和两个尺寸（以宽度和高度表示）。 位置和尺寸的单位是像素。</p>
<p> 可以通过调用方法 getLeft() 和方法 getTop() 来检索视图的位置。前者会返回表示视图的矩形的水平向左（或称 X 轴） 坐标。后者会返回表示视图的矩形的垂直向上（或称 Y 轴）坐标。 这些方法都会返回视图相对于其父项的位置。 例如，如果 getLeft() 返回 20，则意味着视图位于其直接父项左边缘向右 20 个像素处。</p>
<p> 此外，系统还提供了几种便捷方法来避免不必要的计算，即 getRight() 和 getBottom()。 这些方法会返回表示视图的矩形的右边缘和下边缘的坐标。 例如，调用 getRight() 类似于进行以下计算：getLeft() + getWidth()。</p>
<h3 id="尺寸、内边距和外边距"><a href="#尺寸、内边距和外边距" class="headerlink" title="尺寸、内边距和外边距"></a>尺寸、内边距和外边距</h3><p>视图的尺寸通过宽度和高度表示。视图实际上具有两对宽度和高度值。</p>
<p> 第一对称为测量宽度和测量高度。 这些尺寸定义视图想要在其父项内具有的大小。 这些测量尺寸可以通过调用 getMeasuredWidth() 和 getMeasuredHeight() 来获得。</p>
<p> 第二对简称为宽度和高度，有时称为绘制宽度和绘制高度。 这些尺寸定义视图在绘制时和布局后在屏幕上的实际尺寸。 这些值可以（但不必）与测量宽度和测量高度不同。 宽度和高度可以通过调用 getWidth() 和 getHeight() 来获得。</p>
<p> 要想测量其尺寸，视图需要将其内边距考虑在内。内边距以视图左侧、顶部、右侧和底部各部分的像素数表示。 内边距可用于以特定数量的像素弥补视图的内容。 例如，左侧内边距为 2，会将视图的内容从左边缘向右推 2 个像素。 可以使用 setPadding(int, int, int, int) 方法设置内边距，并通过调用 getPaddingLeft()、getPaddingTop()、getPaddingRight() 和 getPaddingBottom() 进行查询。</p>
<p> 尽管视图可以定义内边距，但它并不支持外边距。 不过，视图组可以提供此类支持。</p>
<h3 id="常见布局"><a href="#常见布局" class="headerlink" title="常见布局"></a>常见布局</h3><p>ViewGroup 类的每个子类都提供了一种独特的方式来显示在其中嵌套的视图。以下是 Android 平台中内置的一些较为常见的布局类型。</p>
<blockquote>
<p>注：尽管可以通过将一个或多个布局嵌套在另一个布局内来实现您的 UI 设计，但应该使您的布局层次结构尽可能简略。布局的嵌套布局越少，绘制速度越快（扁平的视图层次结构优于深层的视图层次结构）。</p>
</blockquote>
<p> <strong>线性布局：</strong> 一种使用单个水平行或垂直行来组织子项的布局。它会在窗口长度超出屏幕长度时创建一个滚动条。</p>
<p>   <img src="http://upload-images.jianshu.io/upload_images/2012773-aca120b19beb318d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> <strong>相对布局：</strong> 能够指定子对象彼此之间的相对位置（子对象 A 在子对象 B 左侧）或子对象与父对象的相对位置（与父对象顶部对齐）。</p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/2012773-fef7943700710fda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> <strong>网页视图：</strong> 显示网页。</p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/2012773-fb76e8f7ba6eee92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="使用适配器构建布局"><a href="#使用适配器构建布局" class="headerlink" title="使用适配器构建布局"></a>使用适配器构建布局</h3><p>如果布局的内容是属于动态或未预先确定的内容，您可以使用这样一种布局：在运行时通过子类 AdapterView 用视图填充布局。 AdapterView 类的子类使用 Adapter 将数据与其布局绑定。Adapter 充当数据源与 AdapterView 布局之间的中间人—Adapter（从数组或数据库查询等来源）检索数据，并将每个条目转换为可以添加到 AdapterView 布局中的视图。</p>
<p> 适配器支持的常见布局包括：</p>
<p> <strong>列表视图：</strong> 显示滚动的单列列表。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/2012773-7aa83a3ea429eea8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> <strong>网格视图：</strong> 显示滚动的行列网格。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/2012773-f1643ed1a47e1026.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li><h4 id="使用数据填充适配器视图"><a href="#使用数据填充适配器视图" class="headerlink" title="使用数据填充适配器视图"></a>使用数据填充适配器视图</h4><p>可以通过将 AdapterView 实例与 Adapter 绑定来填充 AdapterView（如 ListView 或 GridView），此操作会从外部来源检索数据，并创建表示每个数据条目的 View。</p>
<p>Android 提供了几个 Adapter 子类，用于检索不同种类的数据和构建 AdapterView 的视图。 两种最常见的适配器是：</p>
<ul>
<li><h5 id="ArrayAdpater"><a href="#ArrayAdpater" class="headerlink" title="ArrayAdpater:"></a>ArrayAdpater:</h5><p>请在数据源为数组时使用此适配器。默认情况下，ArrayAdapter 会通过在每个项目上调用 toString() 并将内容放入 TextView 来为每个数组项创建视图。</p>
<p>例如，如果具有想要在 ListView 中显示的字符串数组，请使用构造函数初始化一个新的 ArrayAdapter，为每个字符串和字符串数组指定布局：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>,</div><div class="line">android.R.layout.simple_list_item_1, myStringArray);</div></pre></td></tr></table></figure>
<p>此构造函数的参数是：</p>
<ul>
<li>应用 Context</li>
<li>包含数组中每个字符串的 TextView 的布局</li>
<li>字符串数组</li>
</ul>
<p>然后，只需在 ListView 上调用 setAdapter()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ListView listView = (ListView) findViewById(R.id.listview);</div><div class="line">listView.setAdapter(adapter);</div></pre></td></tr></table></figure>
<p>要想自定义每个项的外观，您可以重写数组中各个对象的 toString() 方法。或者，要想为 TextView 之外的每个项创建视图（例如，如果想为每个数组项创建一个 ImageView），请扩展 ArrayAdapter 类并重写 getView() 以返回想要为每个项获取的视图类型。</p>
</li>
<li><h5 id="SimpleCursorAdapter"><a href="#SimpleCursorAdapter" class="headerlink" title="SimpleCursorAdapter:"></a>SimpleCursorAdapter:</h5><p>请在数据来自 Cursor 时使用此适配器。使用 SimpleCursorAdapter 时，必须指定要为 Cursor 中的每个行使用的布局，以及应该在哪些布局视图中插入 Cursor 中的哪些列。 例如，如果想创建人员姓名和电话号码列表，则可以执行一个返回 Cursor（包含对应每个人的行，以及对应姓名和号码的列）的查询。 然后，可以创建一个字符串数组，指定想要在每个结果的布局中包含 Cursor 中的哪些列，并创建一个整型数组，指定应该将每个列放入的对应视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String[] fromColumns = &#123;ContactsContract.Data.DISPLAY_NAME,</div><div class="line">                  ContactsContract.CommonDataKinds.Phone.NUMBER&#125;;</div><div class="line"><span class="keyword">int</span>[] toViews = &#123;R.id.display_name, R.id.phone_number&#125;;</div></pre></td></tr></table></figure>
<p>当实例化 SimpleCursorAdapter 时，请传递要用于每个结果的布局、包含结果的 Cursor 以及以下两个数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SimpleCursorAdapter adapter = <span class="keyword">new</span> SimpleCursorAdapter(<span class="keyword">this</span>,</div><div class="line">         R.layout.person_name_and_number, cursor, fromColumns, toViews, <span class="number">0</span>);</div><div class="line">ListView listView = getListView();</div><div class="line">listView.setAdapter(adapter);</div></pre></td></tr></table></figure>
<p>然后，SimpleCursorAdapter 会使用提供的布局，将每个 fromColumns 项插入对应的 toViews 视图，为 Cursor 中的每个行创建一个视图。</p>
</li>
</ul>
<p>如果在应用的生命周期中更改了适配器读取的底层数据，则应调用 notifyDataSetChanged()。此操作会通知附加的视图，数据发生了变化，它应该自行刷新。</p>
</li>
<li><h4 id="处理点击事件"><a href="#处理点击事件" class="headerlink" title="处理点击事件"></a>处理点击事件</h4><p>可以通过实现 AdapterView.OnItemClickListener 界面来响应 AdapterView 中每一项上的点击事件。 例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个匿名类作为消息处理对象。</span></div><div class="line"><span class="keyword">private</span> OnItemClickListener mMessageClickedHandler = <span class="keyword">new</span> OnItemClickListener() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView parent, View v, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">        <span class="comment">// Do something in response to the click</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">listView.setOnItemClickListener(mMessageClickedHandler);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><br>ikook<br>2017.03.13</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android 官方 Training 文档学习总结系列&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ikookblog.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://ikookblog.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>java 实现排序算法之「冒泡排序」</title>
    <link href="http://ikookblog.com/2017/03/09/java_sort_algorithm_series1/"/>
    <id>http://ikookblog.com/2017/03/09/java_sort_algorithm_series1/</id>
    <published>2017-03-08T16:00:00.000Z</published>
    <updated>2017-06-03T17:41:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>java 实现排序算法系列</p>
</blockquote>
<a id="more"></a>
<p>从今天开始我准备写一系列有关于排序算法的文章，当然不止排序算法，以后还会写其他的算法。自己算法方面薄弱，大一上数据结构课的时候也没有好好听课，更别说学了。所以从这篇文章开始，我会巩固一下算法，并写一系列的算法文章，写文章的好处在于把所学知识梳理成章，并且希望可以帮助其他同学。</p>
<p>由于自己水平有限，开学后各种事情也比较多，文章可能会有纰漏，望各位批评指正。</p>
<p>同时，在各类的排序算法中，我们应把注意力放在算法本身，为简单起见，示例代码均使用 int 数据类型，且均为升序排列。</p>
<h2 id="算法简述"><a href="#算法简述" class="headerlink" title="算法简述"></a>算法简述</h2><p>算法，何为算法？</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>算法(Algorithm)是为了解决某类问题而规定的一个有限长的操作序列。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>输入：一个算法必须有零个或以上的输入量。</li>
<li>输出：一个算法应有一个或以上的输出量，输出量是算法计算的结果。</li>
<li>有限性：一个算法必须总是在执行有限步后结束，且每一步都必须在有限时间内完成。</li>
<li>确定性： 算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望，通常要求实际运行结果是确定的。</li>
<li>可行性：即算法能够实现，算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序(Bubble sort)是一种最简单的交换排序算法。大概是所有程序员都会用的算法吧。</p>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>假如有 n 个元素要进行排序。</p>
<h4 id="n-1"><a href="#n-1" class="headerlink" title="n = 1:"></a>n = 1:</h4><p>无需排序。</p>
<h4 id="n-gt-1"><a href="#n-gt-1" class="headerlink" title="n &gt; 1:"></a>n &gt; 1:</h4><ul>
<li><h5 id="第一轮排序"><a href="#第一轮排序" class="headerlink" title="第一轮排序"></a>第一轮排序</h5><p>比较相邻两个元素，如果第一个比第二个大，则交换两个元素的值。<br><br>进行下两个元素的比较，即比较第二个和第三个元素，如前者大于后者，则交换。<br><br>再进行下两个元素的比较。直到第 n-1 个元素和第 n 元素进行比较，如前者大于后者，则交换。<br><br>可以肯定，最后一个元素 n，肯定是 n 个元素中最大的元素。</p>
</li>
<li><h5 id="第二轮排序"><a href="#第二轮排序" class="headerlink" title="第二轮排序"></a>第二轮排序</h5><p>重复执行第一轮执行的动作，直到第 n-2 个元素和第 n-1 个元素进行比较。如前者大于后者，则交换。<br><br>由于第一轮排序已经将最大元素放置到第 n 个位置，所以本次排序无考虑第 n 个元素。即第 n 个元素不参加本次排序。<br><br>…..<br><br>示例图片:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2012773-c645e3f59131b465.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><h5 id="重复执行"><a href="#重复执行" class="headerlink" title="重复执行"></a>重复执行</h5><p>直到只剩一个元素，那么这个元素一定是最小元素，排序结束。显然，进行了 n-1 次排序。</p>
</li>
</ul>
<p>上述过程，每次排序(即每轮排序)都会有一个元素从某个位置慢慢“浮动”到最终所属的位置,就像气泡总会浮动到水的最顶端。在冒泡排序中，每一轮排序都会有一个元素(气泡)替换到本次排序的最后一个位置(水的最顶端)，注意，是本次排序的最后一个位置(第一轮，则为 n；第二轮，则为 n-1；第三轮，则为 n-2 ~~~ )。</p>
<p>因为，排序的过程像是冒泡一样，则称为“冒泡排序”。如下为冒泡排序示意图(来自维基百科)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2012773-ce2db11388ddf4d1.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>设要给数组 arr[] 排序，它有 n 个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void bubbleSort(int[] arr) &#123;</div><div class="line">    int temp = 0;</div><div class="line">    for (int i = arr.length - 1; i &gt; 0; --i) &#123; // 每次需要排序的长度</div><div class="line">        for (int j = 0; j &lt; i; ++j) &#123; // 从第一个元素到第i个元素</div><div class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</div><div class="line">                temp = arr[j];</div><div class="line">                arr[j] = arr[j + 1];</div><div class="line">                arr[j + 1] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>假如有一组数据为：1,2,3,4,5,6,7,8,9,0。 如果用上面的方法实现排序会有什么情况，当然，实现排序肯定没有问题。但是，这组数据的前面一大部分已经是有序的了，如果还是用上面的代码会使效率降低很多(数据比较大的情况下)。所以，将代码进行优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static void bubbleSort(int[] arr) &#123;</div><div class="line">    int temp = 0;</div><div class="line">    boolean swap;</div><div class="line">    for (int i = arr.length - 1; i &gt; 0; --i) &#123; // 每次需要排序的长度</div><div class="line">        swap=false;</div><div class="line">        for (int j = 0; j &lt; i; ++j) &#123; // 从第一个元素到第i个元素</div><div class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</div><div class="line">                temp = arr[j];</div><div class="line">                arr[j] = arr[j + 1];</div><div class="line">                arr[j + 1] = temp;</div><div class="line">                swap=true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (swap==false)&#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在实际使用过程中，由于在大量数据的情况下几乎不使用冒泡排序，而使用小数据的时候增加的布尔变量反而会造成额外的开销。通常，冒泡排序就使用前一种就行了。</p>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul>
<li><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4>当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是n-1次的比较，没有数据交换，时间复杂度为O(n)。当最坏的情况，即待排序表是逆序的况，此时需要比较<img src="http://upload-images.jianshu.io/upload_images/2012773-7f485f78193e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""> 次，并作等数量级的记录移动。因此，总的时间复杂度为O(n^2)。</li>
<li><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4>由以上算法步骤分析，可轻易得知冒泡排序的空间复杂度为 O(n), 需要辅助空间 O(1)</li>
</ul>
<h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><p>容易看出，在相邻元素相等时，我们并不需要交换它们的位置，所以，冒泡排序是稳定排序。</p>
<h3 id="算法适用场景"><a href="#算法适用场景" class="headerlink" title="算法适用场景"></a>算法适用场景</h3><p>在算法优化中提到过，实际使用过程中，在大量数据的情况下几乎不适用冒泡排序。冒泡排序思路简单，代码简单，特别适合小数据的排序。但是，由于算法复杂度较高，在数据量大的时候不适合使用。</p>
<p><br>ikook<br>2017.03.09</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;java 实现排序算法系列&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="论算法" scheme="http://ikookblog.com/categories/%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://ikookblog.com/tags/java/"/>
    
      <category term="计算机技术" scheme="http://ikookblog.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"/>
    
      <category term="排序算法" scheme="http://ikookblog.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ikookblog.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>关于怎样自学 java 和 Android 的回答</title>
    <link href="http://ikookblog.com/2017/03/08/introduction_learn_method/"/>
    <id>http://ikookblog.com/2017/03/08/introduction_learn_method/</id>
    <published>2017-03-07T16:00:00.000Z</published>
    <updated>2017-06-03T17:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在小密圈里发表了自己的博客地址。评论中无意帮助一位同学解答了他疑惑。然后发现同学们还是有不少初学者的。 <a id="more"></a> 所以把问题和回答贴着这里，希望可以帮助更多的同学少走些弯路，回答中主要针对自学者。</p>
<p>需要说明第一点的是，以下回答仅仅是个人学习的经历和总结，不一定适合所有人。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对于还是小白的我，也想自学安卓和java，请学长赐教对于初学者还从哪下手？看那些书？或者去哪个网站？谢谢！</p>
<h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>找一套入门的 java 视频和书籍，了解和掌握 java SE的知识后就可以开始学习 Android 了。java 入门书籍推荐《head first java》，看完这本之后推荐 《java 核心技术》(分为上下卷)，再之后强烈推荐 《java 编程思想》。</p>
<p>入门 java 建议时间在3个月左右，不要着急，多敲代码，我就是吃了入门 java 的时候太着急的亏，我当时就是很随意的看了一套入门的视频就去学 Android 了，导致 java 基础太差，现在又在补基础，所以一定要把 java 基础学好，以看书看文档为主，以视频为辅。</p>
<h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>学 Android ，我当时是直接找了本书看，我看到是郭霖的《第一行代码》，现在有《第二行代码》(第一行代码-第二版)了。在看书过程中不明白不理解的地方找视频看，视频方面我主要看慕课网和极客学院的。</p>
<p>看完《第一行代码》基本可以对 Android 有个大体的了解吧，可能还不能算真正入门。我看完第一行代码之后是做了个小的工具类 app ，也不是我一个人完成的，因为是参加比赛做的。之后我又看了《Android 编程权威指南》，现在也有第二版了。我一开始看的第一版，课本代码是用 eclipse 写的，我看的时候是使用 Android Studio 码的，没多大差别，有个别地方需要变通一下，不过强烈建议使用 AS。3月3号，就前几天，Google 发布了AS 2.3.0 正式版。知道有第二版之后又买了本第二版看了一遍，代码敲了一遍。然后差不多就看到现在的我了。</p>
<p>我学的时候也不是只是一味的学某一门技术，在学习 java 和 Android 期间我也了解和学习过其他东西，比如 git、GitHub、单元测试一类的。也参加过几个比赛。虽然比赛都没取得什么好的成绩，但也还是有好处的。</p>
<p>当然，这也导致我现在对 Android 还只是有个大体的了解，我写东西还是无从下手，还是处在入门阶段，同时现在我还仍在继续努力学习。不过现在我已经不再看视频了，而是看书、文档、博客等，文档也会看官方的。官网现在有中文的，不过只是部分，所以还是要看英文版。我自己在看的时候就是边看边用翻译软件翻译，慢慢来，我相信会改变的。</p>
<h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><p>关于学习资源可以见我 GitHub 的一个仓库，里面收集了我知道的所有资料，当然里面也有我还没有学习的。<br>地址：<a href="https://github.com/china-kook/Skill-learn-collect" target="_blank" rel="external">Skill-learn-collect</a></p>
<p>说到自学 Android，不得不提 stormzhang 的那篇<a href="http://stormzhang.com/android/2016/01/21/learn-android-byself/" target="_blank" rel="external">《如何自学Android 编程》</a>以及<a href="http://stormzhang.com/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="external">《Android 学习之路》</a>。</p>
<p><br>ikook<br>2017.03.08</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天在小密圈里发表了自己的博客地址。评论中无意帮助一位同学解答了他疑惑。然后发现同学们还是有不少初学者的。
    
    </summary>
    
      <category term="随笔集" scheme="http://ikookblog.com/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
      <category term="随笔" scheme="http://ikookblog.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Android" scheme="http://ikookblog.com/tags/Android/"/>
    
      <category term="java" scheme="http://ikookblog.com/tags/java/"/>
    
  </entry>
  
</feed>
